<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libsequence: Sequence Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsequence
   &#160;<span id="projectnumber">1.8.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceSequence.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Sequence Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The namespace in which this library resides.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceSequence_1_1Alignment"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence_1_1Alignment.html">Alignment</a></td></tr>
<tr class="memdesc:namespaceSequence_1_1Alignment"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routines fundamental to aligned data. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceSequence_1_1Recombination"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence_1_1Recombination.html">Recombination</a></td></tr>
<tr class="memdesc:namespaceSequence_1_1Recombination"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods dealing with recombination. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceSequence_1_1sambits"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence_1_1sambits.html">sambits</a></td></tr>
<tr class="memdesc:namespaceSequence_1_1sambits"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the hex flags used by a SAM file flag field in an easy-to-read format. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1AlignStream.html">AlignStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual interface to alignment streams.  <a href="classSequence_1_1AlignStream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1bamreader.html">bamreader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class managing input from BAM files.  <a href="classSequence_1_1bamreader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1bamaux.html">bamaux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The extra data types at the end of a bam record.  <a href="structSequence_1_1bamaux.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1bamrecord.html">bamrecord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single alignment record from a BAM file.  <a href="classSequence_1_1bamrecord.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1ClustalW.html">ClustalW</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSequence_1_1ClustalW.html" title="ClustalW streams. ">ClustalW</a> streams.  <a href="classSequence_1_1ClustalW.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1segment.html">segment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A portion of a recombining chromosome.  <a href="structSequence_1_1segment.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1chromosome.html">chromosome</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A chromosome is a container of segments.  <a href="structSequence_1_1chromosome.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1node.html">node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point on a marginal tree at which a coalescent event occurs.  <a href="structSequence_1_1node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1marginal.html">marginal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The genealogy of a portion of a chromosome on which no recombination has occurred.  <a href="structSequence_1_1marginal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1newick__stream__marginal__tree.html">newick_stream_marginal_tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides a typecast-on-output of a marginal tree to a newick tree Example use:  <a href="classSequence_1_1newick__stream__marginal__tree.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1Comeron95.html">Comeron95</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ka and Ks by Comeron's (1995) method.  <a href="classSequence_1_1Comeron95.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1ComplementBase.html">ComplementBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1ProductMoment.html">ProductMoment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pearson's product-moment correlation.  <a href="structSequence_1_1ProductMoment.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1SpearmansRank.html">SpearmansRank</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spearman's rank correlation.  <a href="structSequence_1_1SpearmansRank.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1upperCrit.html">upperCrit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the upper critical value of a sorted list.  <a href="structSequence_1_1upperCrit.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1lowerCrit.html">lowerCrit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the upper critical value of a sorted list.  <a href="structSequence_1_1lowerCrit.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1Sums.html">Sums</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1Fasta.html">Fasta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FASTA sequence stream.  <a href="classSequence_1_1Fasta.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1fastq.html">fastq</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1FST.html">FST</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">analysis of population structure using <img class="formulaInl" alt="$F_{ST}$" src="form_3.png"/>  <a href="classSequence_1_1FST.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1Grantham.html">Grantham</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classSequence_1_1Grantham.html" title="Grantham&#39;s distances. ">Grantham</a>'s distances.  <a href="classSequence_1_1Grantham.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1GranthamWeights2.html">GranthamWeights2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights paths by <a class="el" href="classSequence_1_1Grantham.html" title="Grantham&#39;s distances. ">Grantham</a>'s distances for codons differing at 2 sites.  <a href="classSequence_1_1GranthamWeights2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1GranthamWeights3.html">GranthamWeights3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights paths by <a class="el" href="classSequence_1_1Grantham.html" title="Grantham&#39;s distances. ">Grantham</a>'s distances for codons differing at 3 sites.  <a href="classSequence_1_1GranthamWeights3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1HKAdata.html">HKAdata</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data from a single locus for an HKA test.  <a href="structSequence_1_1HKAdata.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1HKAresults.html">HKAresults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">results of calculations of the HKA test  <a href="structSequence_1_1HKAresults.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1Kimura80.html">Kimura80</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kimura's 2-parameter distance.  <a href="classSequence_1_1Kimura80.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1phylipData.html">phylipData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1countStates.html">countStates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to count the number of states, excluding gaps and missing data, in a range of characters.  <a href="structSequence_1_1countStates.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1countDerivedStates.html">countDerivedStates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to count the number of derived states, excluding gaps and missing data, in a range of characters.  <a href="structSequence_1_1countDerivedStates.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1ssh.html">ssh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate nucleotide diversity from a polymorphic site.  <a href="structSequence_1_1ssh.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1nmuts.html">nmuts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the number of mutations at a polymorphic site.  <a href="structSequence_1_1nmuts.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1PolySIM.html">PolySIM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analysis of coalescent simulation data.  <a href="classSequence_1_1PolySIM.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1PolySites.html">PolySites</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphism tables for sequence data.  <a href="classSequence_1_1PolySites.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1PolySNP.html">PolySNP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Molecular population genetic analysis.  <a href="classSequence_1_1PolySNP.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1__PolySNPImpl.html">_PolySNPImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1PolyTable.html">PolyTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for polymorphism tables.  <a href="classSequence_1_1PolyTable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1PolyTableSlice.html">PolyTableSlice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container class for "sliding windows" along a polymorphism table.  <a href="classSequence_1_1PolyTableSlice.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1Ptable.html">Ptable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1RedundancyCom95.html">RedundancyCom95</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate redundancy of a genetic code using Comeron's counting scheme.  <a href="classSequence_1_1RedundancyCom95.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1samflag.html">samflag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The flag field of a SAM record.  <a href="classSequence_1_1samflag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1samrecord.html">samrecord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single alignment record from a SAM file.  <a href="classSequence_1_1samrecord.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1Seq.html">Seq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract interface to sequence objects.  <a href="classSequence_1_1Seq.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1SeqException.html">SeqException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for exceptions that may be thrown.  <a href="classSequence_1_1SeqException.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1badFormat.html">badFormat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1shortestPath.html">shortestPath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate shortest path between 2 codons.  <a href="classSequence_1_1shortestPath.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1SimData.html">SimData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data from coalescent simulations.  <a href="classSequence_1_1SimData.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1SimParams.html">SimParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for Hudson's simulation program.  <a href="classSequence_1_1SimParams.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1SimpleSNP.html">SimpleSNP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SNP table data format.  <a href="classSequence_1_1SimpleSNP.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1SingleSub.html">SingleSub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deal with codons differing at 1 position.  <a href="classSequence_1_1SingleSub.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1Sites.html">Sites</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate length statistics for divergence calculations.  <a href="classSequence_1_1Sites.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1stateCounter.html">stateCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">keep track of state counts at a site in an alignment or along a sequence  <a href="classSequence_1_1stateCounter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1ThreeSubs.html">ThreeSubs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deal with codons differing at all 3 positions.  <a href="classSequence_1_1ThreeSubs.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1TwoSubs.html">TwoSubs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deal with codons differing at 2 positions.  <a href="classSequence_1_1TwoSubs.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1Unweighted2.html">Unweighted2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">weights all pathways equally  <a href="classSequence_1_1Unweighted2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1Unweighted3.html">Unweighted3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">weights all pathways equally  <a href="classSequence_1_1Unweighted3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1WeightingScheme2.html">WeightingScheme2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface to weighting schemes when codons differ at 2 positions  <a href="classSequence_1_1WeightingScheme2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1WeightingScheme3.html">WeightingScheme3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract interface to weighting schemes when codons differ at 3 positions  <a href="classSequence_1_1WeightingScheme3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1newick__stream__marginal__tree__impl.html">newick_stream_marginal_tree_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1bamreaderImpl.html">bamreaderImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impl class for bamreader.  <a href="classSequence_1_1bamreaderImpl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1samtag.html">samtag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a96805101cc44223ba818eabb7db36b4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96805101cc44223ba818eabb7db36b4c"></a>
typedef std::vector<br class="typebreak"/>
&lt; std::string &gt;::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_SEG_T</b></td></tr>
<tr class="separator:a96805101cc44223ba818eabb7db36b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48c093934ec4ec1c477415f86a2ffed3"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; std::vector<br class="typebreak"/>
&lt; double &gt;, std::vector<br class="typebreak"/>
&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga48c093934ec4ec1c477415f86a2ffed3">gamete_storage_type</a></td></tr>
<tr class="memdesc:ga48c093934ec4ec1c477415f86a2ffed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">an object to store simulated gametes An object of this type will tend to exist in the calling environment of your program. If you are simulating a sample of n chromosomes, you would initialize the object as follows:  <a href="group__coalescent.html#ga48c093934ec4ec1c477415f86a2ffed3">More...</a><br/></td></tr>
<tr class="separator:ga48c093934ec4ec1c477415f86a2ffed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1116020585e7246433b28c69b0623a20"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; <a class="el" href="structSequence_1_1marginal.html">marginal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a></td></tr>
<tr class="memdesc:ga1116020585e7246433b28c69b0623a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ancestral <a class="el" href="namespaceSequence_1_1Recombination.html" title="Methods dealing with recombination. ">Recombination</a> Graph.  <a href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">More...</a><br/></td></tr>
<tr class="separator:ga1116020585e7246433b28c69b0623a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a78a357cd48c9cca26a24550865ada"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90a78a357cd48c9cca26a24550865ada"></a>
typedef <a class="el" href="classSequence_1_1SimpleSNP.html">SimpleSNP</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Hudson2001</b></td></tr>
<tr class="separator:a90a78a357cd48c9cca26a24550865ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11ceda37fe03bcacea2e98c49723f90"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; std::pair<br class="typebreak"/>
&lt; std::string, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#aa11ceda37fe03bcacea2e98c49723f90">CodonUsageTable</a></td></tr>
<tr class="separator:aa11ceda37fe03bcacea2e98c49723f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaaf89009878664a009249c537dc802a"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; double, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#afaaf89009878664a009249c537dc802a">polymorphicSite</a></td></tr>
<tr class="separator:afaaf89009878664a009249c537dc802a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ee74454170cd8bfd22d7515405149c"><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="namespaceSequence.html#afaaf89009878664a009249c537dc802a">polymorphicSite</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a32ee74454170cd8bfd22d7515405149c">polySiteVector</a></td></tr>
<tr class="separator:a32ee74454170cd8bfd22d7515405149c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac99ec02d15d22dbf0fdbbcfed36eab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ac99ec02d15d22dbf0fdbbcfed36eab"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>I32</b> = std::int32_t</td></tr>
<tr class="separator:a6ac99ec02d15d22dbf0fdbbcfed36eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a27b0d28a22fbebd8b2407eda21caaacc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a27b0d28a22fbebd8b2407eda21caaacc">Nucleotides</a> { <br/>
&#160;&#160;<b>A</b>, 
<b>T</b>, 
<b>G</b>, 
<b>C</b>, 
<br/>
&#160;&#160;<b>N</b>, 
<b>GAP</b>
<br/>
 }</td></tr>
<tr class="separator:a27b0d28a22fbebd8b2407eda21caaacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4fe77c175b8c7b68ce94cb9880d82b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#aff4fe77c175b8c7b68ce94cb9880d82b">GeneticCodes</a> { <b>UNIVERSAL</b>
 }</td></tr>
<tr class="separator:aff4fe77c175b8c7b68ce94cb9880d82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2009c170f0f10cf641e08fb544a0374d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a2009c170f0f10cf641e08fb544a0374d">Mutations</a> { <b>Unknown</b>, 
<b>Ts</b>, 
<b>Tv</b>
 }</td></tr>
<tr class="separator:a2009c170f0f10cf641e08fb544a0374d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf30c61f076078e6be679a81646e33437"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf30c61f076078e6be679a81646e33437"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operators.html#gaf30c61f076078e6be679a81646e33437">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="classSequence_1_1AlignStream.html">AlignStream</a>&lt; T &gt; &amp;c)</td></tr>
<tr class="separator:gaf30c61f076078e6be679a81646e33437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63bec66d7221fc0057e34ba665ebc8b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga63bec66d7221fc0057e34ba665ebc8b6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operators.html#ga63bec66d7221fc0057e34ba665ebc8b6">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classSequence_1_1AlignStream.html">AlignStream</a>&lt; T &gt; &amp;c)</td></tr>
<tr class="separator:ga63bec66d7221fc0057e34ba665ebc8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf68b3b9b4b02142dd9ab51dbb016b7"><td class="memTemplParams" colspan="2"><a class="anchor" id="abdf68b3b9b4b02142dd9ab51dbb016b7"></a>
template&lt;typename iter1 , typename iter2 , typename correlation_type , typename comparison_function , typename shuffler &gt; </td></tr>
<tr class="memitem:abdf68b3b9b4b02142dd9ab51dbb016b7"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PermuteCorrelation_details</b> (iter1 beg_x, iter1 end_x, iter2 beg_y, const correlation_type &amp;corr, const comparison_function &amp;comp, shuffler &amp;s, const unsigned &amp;NPERM)</td></tr>
<tr class="separator:abdf68b3b9b4b02142dd9ab51dbb016b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad6da6579788349c3f9f442c31c3805"><td class="memTemplParams" colspan="2">template&lt;typename iter1 , typename iter2 , typename correlation_type , typename comparison_function , typename shuffler &gt; </td></tr>
<tr class="memitem:a8ad6da6579788349c3f9f442c31c3805"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a8ad6da6579788349c3f9f442c31c3805">PermuteCorrelation</a> (iter1 beg_x, iter1 end_x, iter2 beg_y, const correlation_type &amp;corr, const comparison_function &amp;comp, shuffler &amp;s, const unsigned &amp;NPERM)</td></tr>
<tr class="separator:a8ad6da6579788349c3f9f442c31c3805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24509f39ce9d1735556d677555fabfb"><td class="memTemplParams" colspan="2">template&lt;typename iter1 , typename iter2 , typename correlation_type , typename comparison_function , typename shuffler &gt; </td></tr>
<tr class="memitem:ac24509f39ce9d1735556d677555fabfb"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#ac24509f39ce9d1735556d677555fabfb">PermuteCorrelation</a> (iter1 beg_x, iter1 end_x, iter2 beg_y, const correlation_type &amp;corr, const comparison_function &amp;comp, const shuffler &amp;s, const unsigned &amp;NPERM)</td></tr>
<tr class="separator:ac24509f39ce9d1735556d677555fabfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga713d4527729a5c8cd265176b8894f41c"><td class="memTemplParams" colspan="2">template&lt;typename key , typename value &gt; </td></tr>
<tr class="memitem:ga713d4527729a5c8cd265176b8894f41c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; key, <br class="typebreak"/>
value &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operators.html#ga713d4527729a5c8cd265176b8894f41c">operator+</a> (const std::vector&lt; std::pair&lt; key, value &gt; &gt; &amp;lhs, const std::vector&lt; std::pair&lt; key, value &gt; &gt; &amp;rhs)</td></tr>
<tr class="separator:ga713d4527729a5c8cd265176b8894f41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82588ee5620abd5e50f8290e421a7c9e"><td class="memTemplParams" colspan="2">template&lt;typename key , typename value &gt; </td></tr>
<tr class="memitem:ga82588ee5620abd5e50f8290e421a7c9e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; key, <br class="typebreak"/>
value &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operators.html#ga82588ee5620abd5e50f8290e421a7c9e">operator+=</a> (std::vector&lt; std::pair&lt; key, value &gt; &gt; &amp;lhs, const std::vector&lt; std::pair&lt; key, value &gt; &gt; &amp;rhs)</td></tr>
<tr class="separator:ga82588ee5620abd5e50f8290e421a7c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9513410166fbc5922fa379bbb88927c"><td class="memTemplParams" colspan="2">template&lt;typename key , typename value , typename comparison &gt; </td></tr>
<tr class="memitem:gab9513410166fbc5922fa379bbb88927c"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; key, value, comparison &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operators.html#gab9513410166fbc5922fa379bbb88927c">operator+</a> (const std::map&lt; key, value, comparison &gt; &amp;lhs, const std::map&lt; key, value, comparison &gt; &amp;rhs)</td></tr>
<tr class="separator:gab9513410166fbc5922fa379bbb88927c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d092d1930cc4afd5eafa0ab567c7da7"><td class="memTemplParams" colspan="2">template&lt;typename key , typename value , typename comparison &gt; </td></tr>
<tr class="memitem:ga3d092d1930cc4afd5eafa0ab567c7da7"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; key, value, comparison &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__operators.html#ga3d092d1930cc4afd5eafa0ab567c7da7">operator+=</a> (std::map&lt; key, value, comparison &gt; &amp;lhs, const std::map&lt; key, value, comparison &gt; &amp;rhs)</td></tr>
<tr class="separator:ga3d092d1930cc4afd5eafa0ab567c7da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73c172220e70e5f3f1f67be8275c8299"><td class="memTemplParams" colspan="2">template&lt;typename iterator &gt; </td></tr>
<tr class="memitem:ga73c172220e70e5f3f1f67be8275c8299"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stats.html#ga73c172220e70e5f3f1f67be8275c8299">mean</a> (iterator beg, iterator end)</td></tr>
<tr class="separator:ga73c172220e70e5f3f1f67be8275c8299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae355805081a2bd7e93b276e43724b30"><td class="memTemplParams" colspan="2">template&lt;typename iterator &gt; </td></tr>
<tr class="memitem:gaae355805081a2bd7e93b276e43724b30"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stats.html#gaae355805081a2bd7e93b276e43724b30">variance</a> (iterator beg, iterator end)</td></tr>
<tr class="separator:gaae355805081a2bd7e93b276e43724b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11af83da11f8a27390d4c65758a04aff"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a11af83da11f8a27390d4c65758a04aff"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a11af83da11f8a27390d4c65758a04aff">meanAndVar</a> (ForwardIterator beg, ForwardIterator end)</td></tr>
<tr class="separator:a11af83da11f8a27390d4c65758a04aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2179bb0db84ab9d9de0960e6ed41017e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2179bb0db84ab9d9de0960e6ed41017e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2179bb0db84ab9d9de0960e6ed41017e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classSequence_1_1Sums.html">Sums</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classSequence_1_1Sums.html">Sums</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classSequence_1_1Sums.html">Sums</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a2179bb0db84ab9d9de0960e6ed41017e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272aa9567e3bd2d88ef8febecbd55703"><td class="memTemplParams" colspan="2"><a class="anchor" id="a272aa9567e3bd2d88ef8febecbd55703"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a272aa9567e3bd2d88ef8febecbd55703"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classSequence_1_1Sums.html">Sums</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classSequence_1_1Sums.html">Sums</a>&lt; T &gt; &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="separator:a272aa9567e3bd2d88ef8febecbd55703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b91600e1470c9738932a1b1713b5249"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8b91600e1470c9738932a1b1713b5249"></a>
template&lt;typename shuffler &gt; </td></tr>
<tr class="memitem:a8b91600e1470c9738932a1b1713b5249"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Snn_test_details</b> (const <a class="el" href="classSequence_1_1PolyTable.html">PolyTable</a> &amp;snpTable, const unsigned config[], const size_t &amp;npop, shuffler &amp;s, const unsigned &amp;nperms)</td></tr>
<tr class="separator:a8b91600e1470c9738932a1b1713b5249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367b82292e373c58d842f782649e71f5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a367b82292e373c58d842f782649e71f5"></a>
template&lt;typename shuffler &gt; </td></tr>
<tr class="memitem:a367b82292e373c58d842f782649e71f5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Snn_test_pairwise_details</b> (const <a class="el" href="classSequence_1_1PolyTable.html">PolyTable</a> &amp;snpTable, const unsigned config[], const size_t &amp;npop, shuffler &amp;s, const unsigned &amp;nperms)</td></tr>
<tr class="separator:a367b82292e373c58d842f782649e71f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1937fe206749689bd0d85fdd9bea9f3a"><td class="memTemplParams" colspan="2">template&lt;typename shuffler &gt; </td></tr>
<tr class="memitem:ga1937fe206749689bd0d85fdd9bea9f3a"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__popgenanalysis.html#ga1937fe206749689bd0d85fdd9bea9f3a">Snn_test</a> (const <a class="el" href="classSequence_1_1PolyTable.html">PolyTable</a> &amp;snpTable, const unsigned config[], const size_t &amp;npop, shuffler &amp;s, const unsigned &amp;nperms)</td></tr>
<tr class="memdesc:ga1937fe206749689bd0d85fdd9bea9f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conducts a permutation-test of Hudson's Snn (sequence nearest-neighbor) statistic.  <a href="group__popgenanalysis.html#ga1937fe206749689bd0d85fdd9bea9f3a">More...</a><br/></td></tr>
<tr class="separator:ga1937fe206749689bd0d85fdd9bea9f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4a1f267e38e289072e54a22bef1a0e6"><td class="memTemplParams" colspan="2">template&lt;typename shuffler &gt; </td></tr>
<tr class="memitem:gaf4a1f267e38e289072e54a22bef1a0e6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__popgenanalysis.html#gaf4a1f267e38e289072e54a22bef1a0e6">Snn_test_pairwise</a> (const <a class="el" href="classSequence_1_1PolyTable.html">PolyTable</a> &amp;snpTable, const unsigned config[], const size_t &amp;npop, shuffler &amp;s, const unsigned &amp;nperms)</td></tr>
<tr class="memdesc:gaf4a1f267e38e289072e54a22bef1a0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conducts a permutation-test of Hudson's Snn (sequence nearest-neighbor) statistic, for all pairwise combinations of populations.  <a href="group__popgenanalysis.html#gaf4a1f267e38e289072e54a22bef1a0e6">More...</a><br/></td></tr>
<tr class="separator:gaf4a1f267e38e289072e54a22bef1a0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aaea2e8c8e79530e7b537d3ab26a510"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga7aaea2e8c8e79530e7b537d3ab26a510"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga7aaea2e8c8e79530e7b537d3ab26a510">pick2_in_deme</a> (const uniform_generator &amp;uni, const std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">Sequence::chromosome</a> &gt; &amp;sample, const int &amp;current_nsam, const int &amp;deme_nsam, const int &amp;deme)</td></tr>
<tr class="memdesc:ga7aaea2e8c8e79530e7b537d3ab26a510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose two random chromosomes from the same deme.  <a href="group__coalescent.html#ga7aaea2e8c8e79530e7b537d3ab26a510">More...</a><br/></td></tr>
<tr class="separator:ga7aaea2e8c8e79530e7b537d3ab26a510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1da6ee3005af95c7da8538bbf31c3298"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga1da6ee3005af95c7da8538bbf31c3298"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga1da6ee3005af95c7da8538bbf31c3298">pick2</a> (uniform_generator &amp;uni, const int &amp;nsam)</td></tr>
<tr class="separator:ga1da6ee3005af95c7da8538bbf31c3298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade136a93206ae5aa4adb3399a541d07e"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:gade136a93206ae5aa4adb3399a541d07e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gade136a93206ae5aa4adb3399a541d07e">pick2</a> (const uniform_generator &amp;uni, const int &amp;nsam)</td></tr>
<tr class="separator:gade136a93206ae5aa4adb3399a541d07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3912c6722638e2f67d61caa4be52bcec"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </td></tr>
<tr class="memitem:ga3912c6722638e2f67d61caa4be52bcec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga3912c6722638e2f67d61caa4be52bcec">bottleneck</a> (uniform_generator &amp;uni, uniform01_generator &amp;uni01, exponential_generator &amp;expo, const std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">chromosome</a> &gt; &amp;initialized_sample, const <a class="el" href="structSequence_1_1marginal.html">marginal</a> &amp;initialized_marginal, const double &amp;tr, const double &amp;d, const double &amp;f, const double &amp;rho, const bool &amp;exponential_recovery, const double &amp;recovered_size)</td></tr>
<tr class="memdesc:ga3912c6722638e2f67d61caa4be52bcec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coalescent simulation of a population bottleneck Simulate a single, bottlenecked, population according to the Wright-Fisher model without selection. The population can recover from the bottleneck either instantaneously ("stepwise bottleneck"), or according to an exponential growth model. For the case of a stepwise bottleneck, this function is equivalent to the following options in Dick Hudson's program "ms": -eN 0 recovered_size -eN tr f -eN (tr+d) 1. For the case where recovery from the bottleneck is by exponential growth, the equivalent "ms" options are: -eN 0 recovered_size -eG tr (log(recovered_size)-log(f))/d -eG (tr+d) 0 -eN (tr+d) 1.  <a href="group__coalescent.html#ga3912c6722638e2f67d61caa4be52bcec">More...</a><br/></td></tr>
<tr class="separator:ga3912c6722638e2f67d61caa4be52bcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f25f44e663e7af13a8981adb8d4898f"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </td></tr>
<tr class="memitem:ga1f25f44e663e7af13a8981adb8d4898f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga1f25f44e663e7af13a8981adb8d4898f">bottleneck</a> (const uniform_generator &amp;uni, const uniform01_generator &amp;uni01, const exponential_generator &amp;expo, const std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">chromosome</a> &gt; &amp;initialized_sample, const <a class="el" href="structSequence_1_1marginal.html">marginal</a> &amp;initialized_marginal, const double &amp;tr, const double &amp;d, const double &amp;f, const double &amp;rho, const bool &amp;exponential_recovery, const double &amp;recovered_size)</td></tr>
<tr class="memdesc:ga1f25f44e663e7af13a8981adb8d4898f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coalescent simulation of a population bottleneck Simulate a single, bottlenecked, population according to the Wright-Fisher model without selection. The population can recover from the bottleneck either instantaneously ("stepwise bottleneck"), or according to an exponential growth model. For the case of a stepwise bottleneck, this function is equivalent to the following options in Dick Hudson's program "ms": -eN 0 recovered_size -eN tr f -eN (tr+d) 1. For the case where recovery from the bottleneck is by exponential growth, the equivalent "ms" options are: -eN 0 recovered_size -eG tr (log(recovered_size)-log(f))/d -eG (tr+d) 0 -eN (tr+d) 1.  <a href="group__coalescent.html#ga1f25f44e663e7af13a8981adb8d4898f">More...</a><br/></td></tr>
<tr class="separator:ga1f25f44e663e7af13a8981adb8d4898f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50a0f43f10ace15dc54a42f38ce598d8"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </td></tr>
<tr class="memitem:ga50a0f43f10ace15dc54a42f38ce598d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga50a0f43f10ace15dc54a42f38ce598d8">exponential_change</a> (uniform_generator &amp;uni, uniform01_generator &amp;uni01, exponential_generator &amp;expo, const std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">chromosome</a> &gt; &amp;initialized_sample, const <a class="el" href="structSequence_1_1marginal.html">marginal</a> &amp;initialized_marginal, const double &amp;G, const double &amp;t_begin, const double &amp;t_end, const double &amp;rho, const double &amp;size_at_end)</td></tr>
<tr class="memdesc:ga50a0f43f10ace15dc54a42f38ce598d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coalescent simulation of exponential change in population size Simulate a single population whose size changes exponentially during some period of time. The relevant command line options for Hudson's program "ms" would be: -eG t_begin G -eG t_end 0. -eN t_end size_at_end.  <a href="group__coalescent.html#ga50a0f43f10ace15dc54a42f38ce598d8">More...</a><br/></td></tr>
<tr class="separator:ga50a0f43f10ace15dc54a42f38ce598d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b46c1a1721fec3910aa1dda10a73ccd"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </td></tr>
<tr class="memitem:ga3b46c1a1721fec3910aa1dda10a73ccd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga3b46c1a1721fec3910aa1dda10a73ccd">exponential_change</a> (const uniform_generator &amp;uni, const uniform01_generator &amp;uni01, const exponential_generator &amp;expo, const std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">chromosome</a> &gt; &amp;initialized_sample, const <a class="el" href="structSequence_1_1marginal.html">marginal</a> &amp;initialized_marginal, const double &amp;G, const double &amp;t_begin, const double &amp;t_end, const double &amp;rho, const double &amp;size_at_end)</td></tr>
<tr class="memdesc:ga3b46c1a1721fec3910aa1dda10a73ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coalescent simulation of exponential change in population size Simulate a single population whose size changes exponentially during some period of time. The relevant command line options for Hudson's program "ms" would be: -eG t_begin -eG t_end 0. -eN t_end size_at_end.  <a href="group__coalescent.html#ga3b46c1a1721fec3910aa1dda10a73ccd">More...</a><br/></td></tr>
<tr class="separator:ga3b46c1a1721fec3910aa1dda10a73ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c57b5ac24a5009b8c4984ecae7c9e5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a45c57b5ac24a5009b8c4984ecae7c9e5"></a>
template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </td></tr>
<tr class="memitem:a45c57b5ac24a5009b8c4984ecae7c9e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>snm</b> (uniform_generator &amp;uni, uniform01_generator &amp;uni01, exponential_generator &amp;expo, const std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">chromosome</a> &gt; &amp;initialized_sample, const <a class="el" href="structSequence_1_1marginal.html">marginal</a> &amp;initialized_marginal, const double &amp;rho)</td></tr>
<tr class="separator:a45c57b5ac24a5009b8c4984ecae7c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5868735a870856df241006b05ec74a26"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5868735a870856df241006b05ec74a26"></a>
template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </td></tr>
<tr class="memitem:a5868735a870856df241006b05ec74a26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>snm</b> (const uniform_generator &amp;uni, const uniform01_generator &amp;uni01, const exponential_generator &amp;expo, const std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">chromosome</a> &gt; &amp;initialized_sample, const <a class="el" href="structSequence_1_1marginal.html">marginal</a> &amp;initialized_marginal, const double &amp;rho)</td></tr>
<tr class="separator:a5868735a870856df241006b05ec74a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0ebc12a347570625f4a5744b468fce"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga5a0ebc12a347570625f4a5744b468fce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga5a0ebc12a347570625f4a5744b468fce">add_S_inf_sites</a> (uniform_generator &amp;uni, marginal::const_iterator history, const double &amp;tt, const int &amp;beg, const int &amp;end, const int &amp;nsam, const int &amp;nsites, const int &amp;S, const int &amp;first_snp_index, <a class="el" href="group__coalescent.html#ga48c093934ec4ec1c477415f86a2ffed3">gamete_storage_type</a> *gametes)</td></tr>
<tr class="memdesc:ga5a0ebc12a347570625f4a5744b468fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add S segregating sites to sample with a particular marginal history, according to the infinitely-many sites model.  <a href="group__coalescent.html#ga5a0ebc12a347570625f4a5744b468fce">More...</a><br/></td></tr>
<tr class="separator:ga5a0ebc12a347570625f4a5744b468fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa308491171a00098f4fd4ef0b289e864"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:gaa308491171a00098f4fd4ef0b289e864"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gaa308491171a00098f4fd4ef0b289e864">add_S_inf_sites</a> (const uniform_generator &amp;uni, marginal::const_iterator history, const double &amp;tt, const int &amp;beg, const int &amp;end, const int &amp;nsam, const int &amp;nsites, const int &amp;S, const int &amp;first_snp_index, <a class="el" href="group__coalescent.html#ga48c093934ec4ec1c477415f86a2ffed3">gamete_storage_type</a> *gametes)</td></tr>
<tr class="memdesc:gaa308491171a00098f4fd4ef0b289e864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add S segregating sites to sample with a particular marginal history, according to the infinitely-many sites model.  <a href="group__coalescent.html#gaa308491171a00098f4fd4ef0b289e864">More...</a><br/></td></tr>
<tr class="separator:gaa308491171a00098f4fd4ef0b289e864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6380ab82353237eab66ee075d605356"><td class="memTemplParams" colspan="2">template&lt;typename poisson_generator , typename uniform_generator &gt; </td></tr>
<tr class="memitem:gac6380ab82353237eab66ee075d605356"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gac6380ab82353237eab66ee075d605356">infinite_sites</a> (poisson_generator &amp;poiss, uniform_generator &amp;uni, <a class="el" href="group__coalescent.html#ga48c093934ec4ec1c477415f86a2ffed3">gamete_storage_type</a> *gametes, const int &amp;nsites, const <a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a> &amp;history, const double &amp;theta)</td></tr>
<tr class="memdesc:gac6380ab82353237eab66ee075d605356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph.  <a href="group__coalescent.html#gac6380ab82353237eab66ee075d605356">More...</a><br/></td></tr>
<tr class="separator:gac6380ab82353237eab66ee075d605356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e16e642151c413353bae43c819524d4"><td class="memTemplParams" colspan="2">template&lt;typename poisson_generator , typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga7e16e642151c413353bae43c819524d4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga7e16e642151c413353bae43c819524d4">infinite_sites</a> (const poisson_generator &amp;poiss, const uniform_generator &amp;uni, <a class="el" href="group__coalescent.html#ga48c093934ec4ec1c477415f86a2ffed3">gamete_storage_type</a> *gametes, const int &amp;nsites, const <a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a> &amp;history, const double &amp;theta)</td></tr>
<tr class="memdesc:ga7e16e642151c413353bae43c819524d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph.  <a href="group__coalescent.html#ga7e16e642151c413353bae43c819524d4">More...</a><br/></td></tr>
<tr class="separator:ga7e16e642151c413353bae43c819524d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb4cc5187dfd09cfe2fe498a2a76c048"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:gadb4cc5187dfd09cfe2fe498a2a76c048"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gadb4cc5187dfd09cfe2fe498a2a76c048">infinite_sites</a> (uniform_generator &amp;uni, <a class="el" href="group__coalescent.html#ga48c093934ec4ec1c477415f86a2ffed3">gamete_storage_type</a> *gametes, const int &amp;nsites, const <a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a> &amp;history, const double *total_times, const unsigned *segsites)</td></tr>
<tr class="memdesc:gadb4cc5187dfd09cfe2fe498a2a76c048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites.  <a href="group__coalescent.html#gadb4cc5187dfd09cfe2fe498a2a76c048">More...</a><br/></td></tr>
<tr class="separator:gadb4cc5187dfd09cfe2fe498a2a76c048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3cda726603c5a1b2dc2af80eb170482"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:gac3cda726603c5a1b2dc2af80eb170482"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gac3cda726603c5a1b2dc2af80eb170482">infinite_sites</a> (const uniform_generator &amp;uni, <a class="el" href="group__coalescent.html#ga48c093934ec4ec1c477415f86a2ffed3">gamete_storage_type</a> *gametes, const int &amp;nsites, const <a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a> &amp;history, const double *total_times, const unsigned *segsites)</td></tr>
<tr class="memdesc:gac3cda726603c5a1b2dc2af80eb170482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites.  <a href="group__coalescent.html#gac3cda726603c5a1b2dc2af80eb170482">More...</a><br/></td></tr>
<tr class="separator:gac3cda726603c5a1b2dc2af80eb170482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65bfd963d90840b88f3b9c81e0598a59"><td class="memTemplParams" colspan="2">template&lt;typename poisson_generator , typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga65bfd963d90840b88f3b9c81e0598a59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSequence_1_1SimData.html">SimData</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga65bfd963d90840b88f3b9c81e0598a59">infinite_sites_sim_data</a> (poisson_generator &amp;poiss, uniform_generator &amp;uni, const int &amp;nsites, const <a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a> &amp;history, const double &amp;theta)</td></tr>
<tr class="memdesc:ga65bfd963d90840b88f3b9c81e0598a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph.  <a href="group__coalescent.html#ga65bfd963d90840b88f3b9c81e0598a59">More...</a><br/></td></tr>
<tr class="separator:ga65bfd963d90840b88f3b9c81e0598a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga924b35d3b4f42a1c29b6eda772bbe721"><td class="memTemplParams" colspan="2">template&lt;typename poisson_generator , typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga924b35d3b4f42a1c29b6eda772bbe721"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSequence_1_1SimData.html">SimData</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga924b35d3b4f42a1c29b6eda772bbe721">infinite_sites_sim_data</a> (const poisson_generator &amp;poiss, const uniform_generator &amp;uni, const int &amp;nsites, const <a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a> &amp;history, const double &amp;theta)</td></tr>
<tr class="memdesc:ga924b35d3b4f42a1c29b6eda772bbe721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph.  <a href="group__coalescent.html#ga924b35d3b4f42a1c29b6eda772bbe721">More...</a><br/></td></tr>
<tr class="separator:ga924b35d3b4f42a1c29b6eda772bbe721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f9a208ce162baf2202a13529692affa"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga3f9a208ce162baf2202a13529692affa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSequence_1_1SimData.html">SimData</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga3f9a208ce162baf2202a13529692affa">infinite_sites_sim_data</a> (uniform_generator &amp;uni, const int &amp;nsites, const <a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a> &amp;history, const double *total_times, const unsigned *segsites)</td></tr>
<tr class="memdesc:ga3f9a208ce162baf2202a13529692affa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites.  <a href="group__coalescent.html#ga3f9a208ce162baf2202a13529692affa">More...</a><br/></td></tr>
<tr class="separator:ga3f9a208ce162baf2202a13529692affa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e8d72f6eccc423582cb403fef97dcab"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga2e8d72f6eccc423582cb403fef97dcab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSequence_1_1SimData.html">SimData</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga2e8d72f6eccc423582cb403fef97dcab">infinite_sites_sim_data</a> (const uniform_generator &amp;uni, const int &amp;nsites, const <a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a> &amp;history, const double *total_times, const unsigned *segsites)</td></tr>
<tr class="memdesc:ga2e8d72f6eccc423582cb403fef97dcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites.  <a href="group__coalescent.html#ga2e8d72f6eccc423582cb403fef97dcab">More...</a><br/></td></tr>
<tr class="separator:ga2e8d72f6eccc423582cb403fef97dcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadba4c228558e6c0c4b0b89cea7315c4d"><td class="memTemplParams" colspan="2">template&lt;typename uniform01_generator &gt; </td></tr>
<tr class="memitem:gadba4c228558e6c0c4b0b89cea7315c4d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gadba4c228558e6c0c4b0b89cea7315c4d">pick_spot</a> (uniform01_generator &amp;uni01, const double &amp;total_reclen, const std::vector&lt; double &gt; &amp;reclens, std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">chromosome</a> &gt;::const_iterator sample_begin, const unsigned &amp;current_nsam, const double *rec_map)</td></tr>
<tr class="separator:gadba4c228558e6c0c4b0b89cea7315c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f690d4ac297fc6bd9583b735254547"><td class="memTemplParams" colspan="2">template&lt;typename uniform01_generator &gt; </td></tr>
<tr class="memitem:gab0f690d4ac297fc6bd9583b735254547"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gab0f690d4ac297fc6bd9583b735254547">pick_spot</a> (const uniform01_generator &amp;uni01, const double &amp;total_reclen, const std::vector&lt; double &gt; &amp;reclens, std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">chromosome</a> &gt;::const_iterator sample_begin, const unsigned &amp;current_nsam, const double *rec_map)</td></tr>
<tr class="separator:gab0f690d4ac297fc6bd9583b735254547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea4808f30d4863cf14362371c05e040"><td class="memTemplParams" colspan="2">template&lt;typename uni01_generator &gt; </td></tr>
<tr class="memitem:a4ea4808f30d4863cf14362371c05e040"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a4ea4808f30d4863cf14362371c05e040">ConditionalTraj_details</a> (uni01_generator &amp;uni01, std::vector&lt; double &gt; *traj, const unsigned &amp;N, const double &amp;s, const double &amp;dt, const double &amp;initial_frequency, const double &amp;final_frequency)</td></tr>
<tr class="separator:a4ea4808f30d4863cf14362371c05e040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065e92d81c4f66e39cd10eea8101013a"><td class="memTemplParams" colspan="2">template&lt;typename uni01_generator &gt; </td></tr>
<tr class="memitem:a065e92d81c4f66e39cd10eea8101013a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a065e92d81c4f66e39cd10eea8101013a">ConditionalTrajNeutral_details</a> (uni01_generator &amp;uni01, std::vector&lt; double &gt; *traj, const double &amp;dt, const double &amp;initial_freq, const double &amp;final_freq)</td></tr>
<tr class="separator:a065e92d81c4f66e39cd10eea8101013a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1023b5e091da3de628947bf1da0644c6"><td class="memTemplParams" colspan="2">template&lt;typename uni01_generator &gt; </td></tr>
<tr class="memitem:a1023b5e091da3de628947bf1da0644c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a1023b5e091da3de628947bf1da0644c6">ConditionalTraj</a> (uni01_generator &amp;uni01, std::vector&lt; double &gt; *traj, const unsigned &amp;N, const double &amp;s, const double &amp;dt, const double &amp;initial_frequency, const double &amp;final_frequency)</td></tr>
<tr class="separator:a1023b5e091da3de628947bf1da0644c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d6ccdace4b1873351b1813346819c5"><td class="memTemplParams" colspan="2">template&lt;typename uni01_generator &gt; </td></tr>
<tr class="memitem:af6d6ccdace4b1873351b1813346819c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#af6d6ccdace4b1873351b1813346819c5">ConditionalTraj</a> (const uni01_generator &amp;uni01, std::vector&lt; double &gt; *traj, const unsigned &amp;N, const double &amp;s, const double &amp;dt, const double &amp;initial_frequency, const double &amp;final_frequency)</td></tr>
<tr class="separator:af6d6ccdace4b1873351b1813346819c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f47432317cde97fc60fdc8dd23c63c0"><td class="memTemplParams" colspan="2">template&lt;typename uni01_generator &gt; </td></tr>
<tr class="memitem:a2f47432317cde97fc60fdc8dd23c63c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a2f47432317cde97fc60fdc8dd23c63c0">ConditionalTrajNeutral</a> (uni01_generator &amp;uni01, std::vector&lt; double &gt; *traj, const double &amp;dt, const double &amp;initial_freq, const double &amp;final_freq)</td></tr>
<tr class="separator:a2f47432317cde97fc60fdc8dd23c63c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e59fa7e04b60104f6e1436eb7ae1ea"><td class="memTemplParams" colspan="2">template&lt;typename uni01_generator &gt; </td></tr>
<tr class="memitem:a47e59fa7e04b60104f6e1436eb7ae1ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a47e59fa7e04b60104f6e1436eb7ae1ea">ConditionalTrajNeutral</a> (const uni01_generator &amp;uni01, std::vector&lt; double &gt; *traj, const double &amp;dt, const double &amp;initial_freq, const double &amp;final_freq)</td></tr>
<tr class="separator:a47e59fa7e04b60104f6e1436eb7ae1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c0955109616a1404e9cd32083e1f7a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad6c0955109616a1404e9cd32083e1f7a"></a>
template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ad6c0955109616a1404e9cd32083e1f7a"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pick2_in_deme</b> (uniform_generator &amp;uni, const std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">Sequence::chromosome</a> &gt; &amp;sample, const int &amp;ttl_nsam, const int &amp;deme_nsam, const int &amp;deme)</td></tr>
<tr class="separator:ad6c0955109616a1404e9cd32083e1f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc67bf45f19257a18e6a05ccc472c433"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gadc67bf45f19257a18e6a05ccc472c433">isseg</a> (<a class="el" href="structSequence_1_1segment.html">chromosome::const_iterator</a> seg, const unsigned &amp;nsegs, const int &amp;pos, unsigned *offset)</td></tr>
<tr class="memdesc:gadc67bf45f19257a18e6a05ccc472c433"><td class="mdescLeft">&#160;</td><td class="mdescRight">ask if a chromosome beginning at seg and containing nsegs contains a segment containing the position pos  <a href="group__coalescent.html#gadc67bf45f19257a18e6a05ccc472c433">More...</a><br/></td></tr>
<tr class="separator:gadc67bf45f19257a18e6a05ccc472c433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad689617c904bc44ec5fade5940273396"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gad689617c904bc44ec5fade5940273396">coalesce</a> (const double &amp;time, const int &amp;ttl_nsam, const int &amp;current_nsam, const int &amp;c1, const int &amp;c2, const int &amp;nsites, int *nlinks, std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">chromosome</a> &gt; *sample, <a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a> *sample_history)</td></tr>
<tr class="memdesc:gad689617c904bc44ec5fade5940273396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common ancestor routine for coalescent simulation. Merges chromosome segments and updates marginal trees.  <a href="group__coalescent.html#gad689617c904bc44ec5fade5940273396">More...</a><br/></td></tr>
<tr class="separator:gad689617c904bc44ec5fade5940273396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e686d875016adee17ea99e68d4eb127"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga1e686d875016adee17ea99e68d4eb127">sample_length</a> (const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;fragments)</td></tr>
<tr class="memdesc:ga1e686d875016adee17ea99e68d4eb127"><td class="mdescLeft">&#160;</td><td class="mdescRight">When simulating partially linked regions, return the total length of sample material that we are simulating.  <a href="group__coalescent.html#ga1e686d875016adee17ea99e68d4eb127">More...</a><br/></td></tr>
<tr class="separator:ga1e686d875016adee17ea99e68d4eb127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad76215f50d491cee38ed10fdc9abeae2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gad76215f50d491cee38ed10fdc9abeae2">total_length</a> (const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;fragments)</td></tr>
<tr class="memdesc:gad76215f50d491cee38ed10fdc9abeae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">When simulating partially linked regions, return the total length of the region.  <a href="group__coalescent.html#gad76215f50d491cee38ed10fdc9abeae2">More...</a><br/></td></tr>
<tr class="separator:gad76215f50d491cee38ed10fdc9abeae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6799b522bbd1873080aeb2107244172"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gaf6799b522bbd1873080aeb2107244172">calculate_scales</a> (const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;fragments, std::vector&lt; std::pair&lt; double, double &gt; &gt; *sample_scale, std::vector&lt; std::pair&lt; double, double &gt; &gt; *mutation_scale)</td></tr>
<tr class="memdesc:gaf6799b522bbd1873080aeb2107244172"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function that rescales physical distance in base pairs to continuous distance on the interval 0,1.  <a href="group__coalescent.html#gaf6799b522bbd1873080aeb2107244172">More...</a><br/></td></tr>
<tr class="separator:gaf6799b522bbd1873080aeb2107244172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c22215ad956c74d797ee8aa31333afa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga0c22215ad956c74d797ee8aa31333afa">rescale_mutation_positions</a> (<a class="el" href="classSequence_1_1SimData.html">SimData</a> *d, const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;sample_scale, const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;mutation_scale)</td></tr>
<tr class="memdesc:ga0c22215ad956c74d797ee8aa31333afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescales the positions of the mutations in <em>d</em> from the scale given in <em>sample_scale</em> to that given in <em>mutation_scale</em>.  <a href="group__coalescent.html#ga0c22215ad956c74d797ee8aa31333afa">More...</a><br/></td></tr>
<tr class="separator:ga0c22215ad956c74d797ee8aa31333afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac593c97e75254030b0dc5b793603ebcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac593c97e75254030b0dc5b793603ebcd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gac593c97e75254030b0dc5b793603ebcd">rescale_arg</a> (<a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a> *sample_history, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;fragments)</td></tr>
<tr class="memdesc:gac593c97e75254030b0dc5b793603ebcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescales the beginnings of marginal trees in an ancestral recombination graph from a genetic scale to a physical scale. <br/></td></tr>
<tr class="separator:gac593c97e75254030b0dc5b793603ebcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac820614c0309bd7c2b8c613cb33c4ad5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gac820614c0309bd7c2b8c613cb33c4ad5">integrate_genetic_map</a> (const std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">chromosome</a> &gt; &amp;sample, const int &amp;current_nsam, const std::vector&lt; double &gt; &amp;genetic_map, std::vector&lt; double &gt; *reclens)</td></tr>
<tr class="memdesc:gac820614c0309bd7c2b8c613cb33c4ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">When simulating non-uniform recombination rates, the probability of recombination at each point in the simulation needs to be obtained by integrating over the genetic map and the current sample configuration. This function does that.  <a href="group__coalescent.html#gac820614c0309bd7c2b8c613cb33c4ad5">More...</a><br/></td></tr>
<tr class="separator:gac820614c0309bd7c2b8c613cb33c4ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef587d0dd2c9f5fc9725cea9c166f73a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">chromosome</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gaef587d0dd2c9f5fc9725cea9c166f73a">init_sample</a> (const std::vector&lt; int &gt; &amp;pop_config, const int &amp;nsites)</td></tr>
<tr class="memdesc:gaef587d0dd2c9f5fc9725cea9c166f73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple function to initialize a sample of chromosomes.  <a href="group__coalescent.html#gaef587d0dd2c9f5fc9725cea9c166f73a">More...</a><br/></td></tr>
<tr class="separator:gaef587d0dd2c9f5fc9725cea9c166f73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e3a9fa77284d9751ba6fb025c4d218f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSequence_1_1marginal.html">marginal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga6e3a9fa77284d9751ba6fb025c4d218f">init_marginal</a> (const int &amp;nsam)</td></tr>
<tr class="memdesc:ga6e3a9fa77284d9751ba6fb025c4d218f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple function to initialize a marginal tree.  <a href="group__coalescent.html#ga6e3a9fa77284d9751ba6fb025c4d218f">More...</a><br/></td></tr>
<tr class="separator:ga6e3a9fa77284d9751ba6fb025c4d218f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ca235b3a31288ab65f98507c312be6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a80ca235b3a31288ab65f98507c312be6">output_gametes</a> (FILE *fp, const unsigned &amp;segsites, const unsigned &amp;nsam, const <a class="el" href="group__coalescent.html#ga48c093934ec4ec1c477415f86a2ffed3">gamete_storage_type</a> &amp;gametes)</td></tr>
<tr class="memdesc:a80ca235b3a31288ab65f98507c312be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an object of type gamete_storage type to a C-style file stream This function is used when you need to output simulated gametes using a method faster than the operator&lt;&lt; for class <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a>.  <a href="#a80ca235b3a31288ab65f98507c312be6">More...</a><br/></td></tr>
<tr class="separator:a80ca235b3a31288ab65f98507c312be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd252657f1fdb3fe7d73fe23c468fd05"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator , typename poisson_generator &gt; </td></tr>
<tr class="memitem:gacd252657f1fdb3fe7d73fe23c468fd05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSequence_1_1SimData.html">Sequence::SimData</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gacd252657f1fdb3fe7d73fe23c468fd05">neutral_sample</a> (uniform_generator &amp;uni, uniform01_generator &amp;uni01, exponential_generator &amp;expo, poisson_generator &amp;poiss, const double &amp;theta, const double &amp;rho, const int &amp;nsites, const int &amp;nsam, std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">chromosome</a> &gt; *sample, <a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a> *sample_history, unsigned *max_chromosomes=NULL, const unsigned &amp;max_chromosomes_inc=0)</td></tr>
<tr class="memdesc:gacd252657f1fdb3fe7d73fe23c468fd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple function to generate samples under a neutral equilibrium model.  <a href="group__coalescent.html#gacd252657f1fdb3fe7d73fe23c468fd05">More...</a><br/></td></tr>
<tr class="separator:gacd252657f1fdb3fe7d73fe23c468fd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe0abcf7a1656a19ad282f44822d7b73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gafe0abcf7a1656a19ad282f44822d7b73">crossover</a> (const int &amp;current_nsam, const int &amp;chromo, const int &amp;pos, std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">chromosome</a> &gt; *sample, <a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a> *sample_history)</td></tr>
<tr class="memdesc:gafe0abcf7a1656a19ad282f44822d7b73"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSequence_1_1Recombination.html" title="Methods dealing with recombination. ">Recombination</a> function.  <a href="group__coalescent.html#gafe0abcf7a1656a19ad282f44822d7b73">More...</a><br/></td></tr>
<tr class="separator:gafe0abcf7a1656a19ad282f44822d7b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3697a3a402b2395fafc6dc2548721a1c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga3697a3a402b2395fafc6dc2548721a1c">pick_uniform_spot</a> (const double &amp;random_01, const int &amp;nlinks, std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">chromosome</a> &gt;::const_iterator sample_begin, const unsigned &amp;current_nsam)</td></tr>
<tr class="memdesc:ga3697a3a402b2395fafc6dc2548721a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pick a crossover point for the model where recombination rates are constant across a recion. Picks a positions uniformly amongst all chromosomes at which a recombination event will occur.  <a href="group__coalescent.html#ga3697a3a402b2395fafc6dc2548721a1c">More...</a><br/></td></tr>
<tr class="separator:ga3697a3a402b2395fafc6dc2548721a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa932d6d77bf4c5a2a99ba2ee1594f772"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa932d6d77bf4c5a2a99ba2ee1594f772"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__operators.html#gaa932d6d77bf4c5a2a99ba2ee1594f772">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="structSequence_1_1chromosome.html">chromosome</a> &amp;c)</td></tr>
<tr class="memdesc:gaa932d6d77bf4c5a2a99ba2ee1594f772"><td class="mdescLeft">&#160;</td><td class="mdescRight">output operator for chromosome types in coalescent simulation Outputs the segments contained by the chromosome <br/></td></tr>
<tr class="separator:gaa932d6d77bf4c5a2a99ba2ee1594f772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab683434d15d717df166f3879b7192a00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab683434d15d717df166f3879b7192a00"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__operators.html#gab683434d15d717df166f3879b7192a00">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="structSequence_1_1marginal.html">marginal</a> &amp;m)</td></tr>
<tr class="memdesc:gab683434d15d717df166f3879b7192a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a marginal tree to an ostream. <br/></td></tr>
<tr class="separator:gab683434d15d717df166f3879b7192a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae052d7ac56d82097049f7d5f84ccd81c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#ae052d7ac56d82097049f7d5f84ccd81c">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classSequence_1_1newick__stream__marginal__tree.html">newick_stream_marginal_tree</a> &amp;n)</td></tr>
<tr class="separator:ae052d7ac56d82097049f7d5f84ccd81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af627cea569749228dfcc80917d20e06e"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#af627cea569749228dfcc80917d20e06e">operator&gt;&gt;</a> (std::istream &amp;i, <a class="el" href="classSequence_1_1newick__stream__marginal__tree.html">newick_stream_marginal_tree</a> &amp;n)</td></tr>
<tr class="separator:af627cea569749228dfcc80917d20e06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9f77f12a1707c21f20badb8b92b1d20"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gae9f77f12a1707c21f20badb8b92b1d20">total_time</a> (const marginal::const_iterator beg, const int &amp;nsam)</td></tr>
<tr class="memdesc:gae9f77f12a1707c21f20badb8b92b1d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate total time on a marginal tree.  <a href="group__coalescent.html#gae9f77f12a1707c21f20badb8b92b1d20">More...</a><br/></td></tr>
<tr class="separator:gae9f77f12a1707c21f20badb8b92b1d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ae894594d083945cf2280d7b47797cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga1ae894594d083945cf2280d7b47797cd">pick_branch</a> (marginal::const_iterator beg, const int &amp;nsam, const double &amp;rtime)</td></tr>
<tr class="memdesc:ga1ae894594d083945cf2280d7b47797cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">pick a random branch of a marginal tree  <a href="group__coalescent.html#ga1ae894594d083945cf2280d7b47797cd">More...</a><br/></td></tr>
<tr class="separator:ga1ae894594d083945cf2280d7b47797cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64568b80b98d2db6f3bbb89620beda36"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga64568b80b98d2db6f3bbb89620beda36">get_all_descendants</a> (marginal::const_iterator beg, const int &amp;nsam, const int &amp;branch)</td></tr>
<tr class="memdesc:ga64568b80b98d2db6f3bbb89620beda36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the descendants of a branch on a marginal tree.  <a href="group__coalescent.html#ga64568b80b98d2db6f3bbb89620beda36">More...</a><br/></td></tr>
<tr class="separator:ga64568b80b98d2db6f3bbb89620beda36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c4e364eaf4124db5bacdb2d9f8f3950"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga4c4e364eaf4124db5bacdb2d9f8f3950">is_descendant</a> (marginal::const_iterator beg, const int &amp;ind, const int &amp;branch)</td></tr>
<tr class="memdesc:ga4c4e364eaf4124db5bacdb2d9f8f3950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask if a tip of a tree is a descendant of a particular branch.  <a href="group__coalescent.html#ga4c4e364eaf4124db5bacdb2d9f8f3950">More...</a><br/></td></tr>
<tr class="separator:ga4c4e364eaf4124db5bacdb2d9f8f3950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00621e276219aca146a665b3699d9cfe"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga00621e276219aca146a665b3699d9cfe">total_time_on_arg</a> (const <a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">Sequence::arg</a> &amp;sample_history, const int &amp;total_number_of_sites)</td></tr>
<tr class="memdesc:ga00621e276219aca146a665b3699d9cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total time on an ancestral recombination graph.  <a href="group__coalescent.html#ga00621e276219aca146a665b3699d9cfe">More...</a><br/></td></tr>
<tr class="separator:ga00621e276219aca146a665b3699d9cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb81bf8beb9ed32b1dd2b3c35cfcebf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#aceb81bf8beb9ed32b1dd2b3c35cfcebf">minimize_arg</a> (<a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">arg</a> *sample_history)</td></tr>
<tr class="separator:aceb81bf8beb9ed32b1dd2b3c35cfcebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bae55ce26ada3c758d5480565da1f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSequence.html#aa11ceda37fe03bcacea2e98c49723f90">CodonUsageTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a58bae55ce26ada3c758d5480565da1f3">makeCodonUsageTable</a> (const <a class="el" href="classSequence_1_1Seq.html">Seq</a> *sequence)</td></tr>
<tr class="separator:a58bae55ce26ada3c758d5480565da1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f3df3ad2810343c544036f6de2f3ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSequence.html#aa11ceda37fe03bcacea2e98c49723f90">CodonUsageTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a50f3df3ad2810343c544036f6de2f3ab">makeCodonUsageTable</a> (const std::string &amp;sequence)</td></tr>
<tr class="separator:a50f3df3ad2810343c544036f6de2f3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ece33a045f69189932dd14f6c77e6b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSequence.html#aa11ceda37fe03bcacea2e98c49723f90">CodonUsageTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a4ece33a045f69189932dd14f6c77e6b3">makeCodonUsageTable</a> (std::string::const_iterator beg, std::string::const_iterator end)</td></tr>
<tr class="separator:a4ece33a045f69189932dd14f6c77e6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b90c6ccf6178eb60649717875611b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSequence.html#a2009c170f0f10cf641e08fb544a0374d">Mutations</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a75b90c6ccf6178eb60649717875611b7">TsTv</a> (const char &amp;i, const char &amp;j)</td></tr>
<tr class="separator:a75b90c6ccf6178eb60649717875611b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00fad2015afe27a90ba999cfaaade053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSequence.html#a2009c170f0f10cf641e08fb544a0374d">Mutations</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a00fad2015afe27a90ba999cfaaade053">TsTv</a> (const int &amp;i, const int &amp;j)</td></tr>
<tr class="separator:a00fad2015afe27a90ba999cfaaade053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45c04f3606f1ff0b7ba495c52339192"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#ac45c04f3606f1ff0b7ba495c52339192">Different</a> (const std::string &amp;seq1, const std::string &amp;seq2, const bool &amp;skip_missing=true, const bool &amp;nucleic_acid=true)</td></tr>
<tr class="separator:ac45c04f3606f1ff0b7ba495c52339192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae39379bc92ab7feed829028035fce9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a0ae39379bc92ab7feed829028035fce9">NumDiffs</a> (const std::string &amp;seq1, const std::string &amp;seq2, const bool &amp;skip_missing=true, const bool &amp;nucleic_acid=true)</td></tr>
<tr class="separator:a0ae39379bc92ab7feed829028035fce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8d03d21bed077f2f95790a2bc55a3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a6b8d03d21bed077f2f95790a2bc55a3a">Gapped</a> (const std::string &amp;s)</td></tr>
<tr class="separator:a6b8d03d21bed077f2f95790a2bc55a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fada3765a298420876704a4ca57623"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a08fada3765a298420876704a4ca57623"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a08fada3765a298420876704a4ca57623">Gapped</a> (Iterator beg, Iterator end, const char &amp;gapchar= '-')</td></tr>
<tr class="separator:a08fada3765a298420876704a4ca57623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a76f7fc1d7afe7494d999300a79f669"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a0a76f7fc1d7afe7494d999300a79f669">NotAGap</a> (const char &amp;c)</td></tr>
<tr class="separator:a0a76f7fc1d7afe7494d999300a79f669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga490ad3c8b4e548d1cf850806b6a5be1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSequence_1_1HKAresults.html">HKAresults</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__popgen.html#ga490ad3c8b4e548d1cf850806b6a5be1d">calcHKA</a> (const std::vector&lt; <a class="el" href="structSequence_1_1HKAdata.html">HKAdata</a> &gt; &amp;data)</td></tr>
<tr class="separator:ga490ad3c8b4e548d1cf850806b6a5be1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d59ad6a9f1444cbc2bc76a9ede4d0e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d59ad6a9f1444cbc2bc76a9ede4d0e1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Intermediates2</b> (std::string *intermediates, const std::string &amp;codon1, const std::string &amp;codon2)</td></tr>
<tr class="separator:a3d59ad6a9f1444cbc2bc76a9ede4d0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3645444ec648ca1ab647dc0ce8e442"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b3645444ec648ca1ab647dc0ce8e442"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Intermediates3</b> (std::string *intermediates, const std::string &amp;codon1, const std::string &amp;codon2)</td></tr>
<tr class="separator:a8b3645444ec648ca1ab647dc0ce8e442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa818e039fd99810a7e093c907a5854ac"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__operators.html#gaa818e039fd99810a7e093c907a5854ac">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="classSequence_1_1PolyTable.html">PolyTable</a> &amp;c)</td></tr>
<tr class="separator:gaa818e039fd99810a7e093c907a5854ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54ebac29703251eb9c07fd95a16531cf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__operators.html#ga54ebac29703251eb9c07fd95a16531cf">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classSequence_1_1PolyTable.html">PolyTable</a> &amp;c)</td></tr>
<tr class="separator:ga54ebac29703251eb9c07fd95a16531cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a3bdc53e14704400f877e6953d0792"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#ad5a3bdc53e14704400f877e6953d0792">containsCharacter</a> (const <a class="el" href="classSequence_1_1PolyTable.html">PolyTable</a> *t, const char &amp;ch)</td></tr>
<tr class="separator:ad5a3bdc53e14704400f877e6953d0792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df882d04ca426b57df54a2b418880aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a6df882d04ca426b57df54a2b418880aa">fillIn</a> (<a class="el" href="classSequence_1_1PolyTable.html">PolyTable</a> *t, const unsigned &amp;refseq=0, const char &amp;identical= '.')</td></tr>
<tr class="separator:a6df882d04ca426b57df54a2b418880aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4409f91640da9f1f093f76dd859649"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a3d4409f91640da9f1f093f76dd859649">addIdentityChar</a> (<a class="el" href="classSequence_1_1PolyTable.html">PolyTable</a> *t, const unsigned &amp;refseq=0, const char &amp;identical= '.')</td></tr>
<tr class="separator:a3d4409f91640da9f1f093f76dd859649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0aa47cde1d6632c9fff3a6be97b509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a1d0aa47cde1d6632c9fff3a6be97b509">RemoveGaps</a> (<a class="el" href="classSequence_1_1PolyTable.html">PolyTable</a> *t, const char &amp;gapchar= '-')</td></tr>
<tr class="separator:a1d0aa47cde1d6632c9fff3a6be97b509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21736523aa0d62767da47627190730a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a21736523aa0d62767da47627190730a4">RemoveInvariantColumns</a> (<a class="el" href="classSequence_1_1PolyTable.html">PolyTable</a> *t, const bool &amp;skipOutgroup=false, const unsigned &amp;outgroup=0)</td></tr>
<tr class="separator:a21736523aa0d62767da47627190730a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bf69ad44829dececa75440a9f4e7cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a59bf69ad44829dececa75440a9f4e7cf">PolyTableValid</a> (const <a class="el" href="classSequence_1_1PolyTable.html">PolyTable</a> *t)</td></tr>
<tr class="separator:a59bf69ad44829dececa75440a9f4e7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64b1a038a111743ffce8c2ab57621596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSequence.html#a32ee74454170cd8bfd22d7515405149c">polySiteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__polytables.html#ga64b1a038a111743ffce8c2ab57621596">rotatePolyTable</a> (const <a class="el" href="classSequence_1_1PolyTable.html">Sequence::PolyTable</a> *data)</td></tr>
<tr class="separator:ga64b1a038a111743ffce8c2ab57621596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8af68243ce020d1e29beb9ab6cd7c97d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__operators.html#ga8af68243ce020d1e29beb9ab6cd7c97d">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classSequence_1_1samflag.html">samflag</a> &amp;s)</td></tr>
<tr class="separator:ga8af68243ce020d1e29beb9ab6cd7c97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7942d9043a2d8e5096efe14ef8dcbc8d"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__operators.html#ga7942d9043a2d8e5096efe14ef8dcbc8d">operator&gt;&gt;</a> (std::istream &amp;i, <a class="el" href="classSequence_1_1samflag.html">samflag</a> &amp;s)</td></tr>
<tr class="separator:ga7942d9043a2d8e5096efe14ef8dcbc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ef00b653826aace505b09f269f6e93"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#af9ef00b653826aace505b09f269f6e93">alignment_length</a> (const <a class="el" href="classSequence_1_1samrecord.html">samrecord</a> &amp;b)</td></tr>
<tr class="separator:af9ef00b653826aace505b09f269f6e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021e757de67d631c5c10d2f8b3d4522d"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a021e757de67d631c5c10d2f8b3d4522d">insertion_distance</a> (const <a class="el" href="classSequence_1_1samrecord.html">samrecord</a> &amp;b)</td></tr>
<tr class="separator:a021e757de67d631c5c10d2f8b3d4522d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7074dc3f332bf29900c43b64442f03"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a1f7074dc3f332bf29900c43b64442f03">deletion_distance</a> (const <a class="el" href="classSequence_1_1samrecord.html">samrecord</a> &amp;b)</td></tr>
<tr class="separator:a1f7074dc3f332bf29900c43b64442f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f20401d611c3a10427a95116f838d93"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a8f20401d611c3a10427a95116f838d93">ngaps</a> (const <a class="el" href="classSequence_1_1samrecord.html">samrecord</a> &amp;b)</td></tr>
<tr class="separator:a8f20401d611c3a10427a95116f838d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0103fc02fbf48c8a8303761b1a7ade7d"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a0103fc02fbf48c8a8303761b1a7ade7d">mismatches</a> (const <a class="el" href="classSequence_1_1samrecord.html">samrecord</a> &amp;b)</td></tr>
<tr class="separator:a0103fc02fbf48c8a8303761b1a7ade7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b5da6e54be22c6a55108576fc10a11"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#ad4b5da6e54be22c6a55108576fc10a11">alignment_length</a> (const <a class="el" href="classSequence_1_1bamrecord.html">bamrecord</a> &amp;b)</td></tr>
<tr class="separator:ad4b5da6e54be22c6a55108576fc10a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848c7366d1b16116ff667f278f01384a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a848c7366d1b16116ff667f278f01384a">insertion_distance</a> (const <a class="el" href="classSequence_1_1bamrecord.html">bamrecord</a> &amp;b)</td></tr>
<tr class="separator:a848c7366d1b16116ff667f278f01384a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0458665ad262a68d20a0d6e2ad6babdb"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a0458665ad262a68d20a0d6e2ad6babdb">deletion_distance</a> (const <a class="el" href="classSequence_1_1bamrecord.html">bamrecord</a> &amp;b)</td></tr>
<tr class="separator:a0458665ad262a68d20a0d6e2ad6babdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad323cf6103d7a003a32c1684ba111404"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#ad323cf6103d7a003a32c1684ba111404">ngaps</a> (const <a class="el" href="classSequence_1_1bamrecord.html">bamrecord</a> &amp;b)</td></tr>
<tr class="separator:ad323cf6103d7a003a32c1684ba111404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9002a46767787604d60712821a5009f8"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a9002a46767787604d60712821a5009f8">mismatches</a> (const <a class="el" href="classSequence_1_1bamrecord.html">bamrecord</a> &amp;b)</td></tr>
<tr class="separator:a9002a46767787604d60712821a5009f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef776db43acd7fad114f653a59de8e1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a3ef776db43acd7fad114f653a59de8e1">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="structSequence_1_1samtag.html">samtag</a> &amp;st)</td></tr>
<tr class="separator:a3ef776db43acd7fad114f653a59de8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga524c5c8e2f95586e2a2f30d8c47c1f90"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__operators.html#ga524c5c8e2f95586e2a2f30d8c47c1f90">operator&gt;&gt;</a> (std::istream &amp;i, <a class="el" href="classSequence_1_1samrecord.html">samrecord</a> &amp;b)</td></tr>
<tr class="separator:ga524c5c8e2f95586e2a2f30d8c47c1f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga081e07a9af5e6776bd8d3108f518fd28"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__operators.html#ga081e07a9af5e6776bd8d3108f518fd28">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classSequence_1_1samrecord.html">samrecord</a> &amp;b)</td></tr>
<tr class="separator:ga081e07a9af5e6776bd8d3108f518fd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf2513fd99e190e6a0e745a6006be0c2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__operators.html#gaaf2513fd99e190e6a0e745a6006be0c2">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classSequence_1_1Seq.html">Seq</a> &amp;c)</td></tr>
<tr class="separator:gaaf2513fd99e190e6a0e745a6006be0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cc956199dddcab86120ab0130eeec21"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__operators.html#ga7cc956199dddcab86120ab0130eeec21">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="classSequence_1_1Seq.html">Seq</a> &amp;c)</td></tr>
<tr class="separator:ga7cc956199dddcab86120ab0130eeec21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab0e36240236b3366ae6e76b5ba9a678"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__operators.html#gaab0e36240236b3366ae6e76b5ba9a678">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classSequence_1_1SeqException.html">SeqException</a> &amp;c)</td></tr>
<tr class="separator:gaab0e36240236b3366ae6e76b5ba9a678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a96d1177eef3a800d6d881a334fc377"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a3a96d1177eef3a800d6d881a334fc377"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a3a96d1177eef3a800d6d881a334fc377">validSeq</a> (Iter beg, Iter end, const char *_pattern=<a class="el" href="namespaceSequence.html#a264064250dc327bf9785e92987ef7517">Sequence::basic_dna_alphabet</a>, const bool icase=true)</td></tr>
<tr class="separator:a3a96d1177eef3a800d6d881a334fc377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdb6d8aaf283e419945540da5d8c1f5"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a0bdb6d8aaf283e419945540da5d8c1f5"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; typename <br class="typebreak"/>
std::iterator_traits&lt; Iterator &gt;<br class="typebreak"/>
::value_type, unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a0bdb6d8aaf283e419945540da5d8c1f5">makeCountList</a> (Iterator beg, Iterator end)</td></tr>
<tr class="separator:a0bdb6d8aaf283e419945540da5d8c1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab034fd4b0b756671f74a26b5828707e1"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ab034fd4b0b756671f74a26b5828707e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#ab034fd4b0b756671f74a26b5828707e1">internalGapCheck</a> (Iterator beg, Iterator end, const char &amp;gapchar= '-', const unsigned &amp;mod=3)</td></tr>
<tr class="separator:ab034fd4b0b756671f74a26b5828707e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6dba1ba44944b4169c80fb8b4bc613e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned, unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CodonPaths.html#gae6dba1ba44944b4169c80fb8b4bc613e">mutsShortestPath</a> (const std::string &amp;codon1, const std::string &amp;codon2, const <a class="el" href="namespaceSequence.html#aff4fe77c175b8c7b68ce94cb9880d82b">Sequence::GeneticCodes</a> &amp;code=Sequence::UNIVERSAL)</td></tr>
<tr class="separator:gae6dba1ba44944b4169c80fb8b4bc613e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022cdbeee8819e81d448eefbe1cc4e2a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned, <br class="typebreak"/>
<a class="el" href="classSequence_1_1shortestPath.html#ae1c4034e9dad83fafb969f5e5400247d">shortestPath::pathType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a022cdbeee8819e81d448eefbe1cc4e2a">diffType</a> (const std::string &amp;codon1, const std::string &amp;codon2, const <a class="el" href="namespaceSequence.html#aff4fe77c175b8c7b68ce94cb9880d82b">Sequence::GeneticCodes</a> &amp;code=Sequence::UNIVERSAL)</td></tr>
<tr class="separator:a022cdbeee8819e81d448eefbe1cc4e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76fd0402decf4d1790a72acc745a0d2"><td class="memItemLeft" align="right" valign="top">std::tuple<br class="typebreak"/>
&lt; <a class="el" href="classSequence_1_1shortestPath.html#ae1c4034e9dad83fafb969f5e5400247d">shortestPath::pathType</a>, <br class="typebreak"/>
<a class="el" href="classSequence_1_1shortestPath.html#ae1c4034e9dad83fafb969f5e5400247d">shortestPath::pathType</a>, <br class="typebreak"/>
<a class="el" href="classSequence_1_1shortestPath.html#ae1c4034e9dad83fafb969f5e5400247d">shortestPath::pathType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#ae76fd0402decf4d1790a72acc745a0d2">diffTypeMulti</a> (const std::string &amp;codon1, const std::string &amp;codon2, const <a class="el" href="namespaceSequence.html#aff4fe77c175b8c7b68ce94cb9880d82b">Sequence::GeneticCodes</a> &amp;code=Sequence::UNIVERSAL)</td></tr>
<tr class="separator:ae76fd0402decf4d1790a72acc745a0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae687725adae15b549c4d005b9683f9"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#aeae687725adae15b549c4d005b9683f9">write_SimData_gz</a> (gzFile &amp;file, const <a class="el" href="classSequence_1_1SimData.html">SimData</a> &amp;d, const bool &amp;binary=false)</td></tr>
<tr class="separator:aeae687725adae15b549c4d005b9683f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48aba7d7a76e64c00e49a958695321e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSequence_1_1SimData.html">SimData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a48aba7d7a76e64c00e49a958695321e9">read_SimData_gz</a> (gzFile &amp;file, const bool &amp;binary=false)</td></tr>
<tr class="separator:a48aba7d7a76e64c00e49a958695321e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05af9443e408030a602af7f3e359a42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#ae05af9443e408030a602af7f3e359a42">write_SimData_binary</a> (std::ostream &amp;o, const <a class="el" href="classSequence_1_1SimData.html">SimData</a> &amp;d)</td></tr>
<tr class="separator:ae05af9443e408030a602af7f3e359a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffd3b2fa5f10fb331e7b75366442d71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSequence_1_1SimData.html">SimData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#aaffd3b2fa5f10fb331e7b75366442d71">read_SimData_binary</a> (std::istream &amp;i)</td></tr>
<tr class="separator:aaffd3b2fa5f10fb331e7b75366442d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0032530490a32b1932a2a8895f7ffcd"><td class="memItemLeft" align="right" valign="top">long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#af0032530490a32b1932a2a8895f7ffcd">write_SimData_binary</a> (int fd, const <a class="el" href="classSequence_1_1SimData.html">SimData</a> &amp;d)</td></tr>
<tr class="separator:af0032530490a32b1932a2a8895f7ffcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fa5decc918fee6b486766ee8f3f646"><td class="memItemLeft" align="right" valign="top">long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#aa6fa5decc918fee6b486766ee8f3f646">write_SimData_binary</a> (FILE *fp, const <a class="el" href="classSequence_1_1SimData.html">SimData</a> &amp;d)</td></tr>
<tr class="separator:aa6fa5decc918fee6b486766ee8f3f646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3c525be2122bfe89a94df82d1d6f333"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__operators.html#gaa3c525be2122bfe89a94df82d1d6f333">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="classSequence_1_1SimParams.html">SimParams</a> &amp;c)</td></tr>
<tr class="separator:gaa3c525be2122bfe89a94df82d1d6f333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31192429d68096ff856f896cb65a30e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31192429d68096ff856f896cb65a30e4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Snn_statistic</b> (const unsigned individuals[], const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;dkj, const unsigned config[], const size_t &amp;npop, const unsigned &amp;nsam)</td></tr>
<tr class="separator:a31192429d68096ff856f896cb65a30e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84aefdd93a98187d63c4158c6ecdc8a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84aefdd93a98187d63c4158c6ecdc8a0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>nSL</b> (const unsigned &amp;core, const <a class="el" href="classSequence_1_1SimData.html">SimData</a> &amp;d)</td></tr>
<tr class="separator:a84aefdd93a98187d63c4158c6ecdc8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa68a90c6a1a5466ea314c55a8dda3cba"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html#gaa68a90c6a1a5466ea314c55a8dda3cba">Translate</a> (std::string::const_iterator beg, std::string::const_iterator end, <a class="el" href="namespaceSequence.html#aff4fe77c175b8c7b68ce94cb9880d82b">Sequence::GeneticCodes</a> genetic_code=Sequence::UNIVERSAL, const char &amp;gapchar= '-')</td></tr>
<tr class="separator:gaa68a90c6a1a5466ea314c55a8dda3cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3640124ef623404694e650ba8a757e78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CodonPaths.html#ga3640124ef623404694e650ba8a757e78">Intermediates2</a> (string *intermediates, const std::string &amp;codon1, const std::string &amp;codon2)</td></tr>
<tr class="memdesc:ga3640124ef623404694e650ba8a757e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the intermediate codons between a pair of codons diverged at 2 positions.  <a href="group__CodonPaths.html#ga3640124ef623404694e650ba8a757e78">More...</a><br/></td></tr>
<tr class="separator:ga3640124ef623404694e650ba8a757e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab933905f221fb3d14014dbf130e7e17f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CodonPaths.html#gab933905f221fb3d14014dbf130e7e17f">Intermediates3</a> (string *intermediates, const std::string &amp;codon1, const std::string &amp;codon2)</td></tr>
<tr class="memdesc:gab933905f221fb3d14014dbf130e7e17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the intermediate codons between a pair of codons diverged at 3 positions.  <a href="group__CodonPaths.html#gab933905f221fb3d14014dbf130e7e17f">More...</a><br/></td></tr>
<tr class="separator:gab933905f221fb3d14014dbf130e7e17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18491cc65f7e1239ec54a64e3820fb46"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__operators.html#ga18491cc65f7e1239ec54a64e3820fb46">operator&lt;&lt;</a> (std::ostream &amp;stream, class <a class="el" href="classSequence_1_1SimParams.html">SimParams</a> &amp;object)</td></tr>
<tr class="separator:ga18491cc65f7e1239ec54a64e3820fb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816e2f35b711d10e3f984b2cd94be83d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a816e2f35b711d10e3f984b2cd94be83d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Dij</b> (const <a class="el" href="namespaceSequence.html#afaaf89009878664a009249c537dc802a">polymorphicSite</a> &amp;p, const std::vector&lt; unsigned &gt; &amp;config, const unsigned &amp;i, const unsigned &amp;j)</td></tr>
<tr class="separator:a816e2f35b711d10e3f984b2cd94be83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec37118fb3e9d6eb08a76feb7894ee68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec37118fb3e9d6eb08a76feb7894ee68"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Gmin</b> (const <a class="el" href="classSequence_1_1Ptable.html">Ptable</a> &amp;pt, const std::vector&lt; unsigned &gt; &amp;config)</td></tr>
<tr class="separator:aec37118fb3e9d6eb08a76feb7894ee68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaaa678e49901c1ef90b470ec226ac8f71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa678e49901c1ef90b470ec226ac8f71"></a>
MAX_SEG_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gaaa678e49901c1ef90b470ec226ac8f71">MAX_SEGSITES</a> =200</td></tr>
<tr class="memdesc:gaaa678e49901c1ef90b470ec226ac8f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">controls allocation of simulated gametes You must define this in namespace <a class="el" href="namespaceSequence.html" title="The namespace in which this library resides. ">Sequence</a> in your program. A value of 200 works well. <br/></td></tr>
<tr class="separator:gaaa678e49901c1ef90b470ec226ac8f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa539fc37aaebc51fee7190755f49abb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa539fc37aaebc51fee7190755f49abb5"></a>
MAX_SEG_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gaa539fc37aaebc51fee7190755f49abb5">MAX_SEGS_INC</a> =200</td></tr>
<tr class="memdesc:gaa539fc37aaebc51fee7190755f49abb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">controls (re)allocation of simulated gametes You must define this in namespace <a class="el" href="namespaceSequence.html" title="The namespace in which this library resides. ">Sequence</a> in your program. A value of 100 works well <br/></td></tr>
<tr class="separator:gaa539fc37aaebc51fee7190755f49abb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd409ce3106271ea202b6ed998268040"><td class="memItemLeft" align="right" valign="top">const std::array&lt; const char, 17 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#afd409ce3106271ea202b6ed998268040">dna_alphabet</a></td></tr>
<tr class="separator:afd409ce3106271ea202b6ed998268040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac427687431515f70256efb59893388ce"><td class="memItemLeft" align="right" valign="top">const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#ac427687431515f70256efb59893388ce">SEQMAXUNSIGNED</a> = std::numeric_limits&lt;unsigned&gt;::max()</td></tr>
<tr class="separator:ac427687431515f70256efb59893388ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4311dadc006f2bfcdbd3b3f9b7b324f"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#ac4311dadc006f2bfcdbd3b3f9b7b324f">SEQMAXDOUBLE</a> = std::numeric_limits&lt;double&gt;::max()</td></tr>
<tr class="separator:ac4311dadc006f2bfcdbd3b3f9b7b324f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264064250dc327bf9785e92987ef7517"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a264064250dc327bf9785e92987ef7517">basic_dna_alphabet</a> = &quot;[^AGTCN\\-]&quot;</td></tr>
<tr class="separator:a264064250dc327bf9785e92987ef7517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840142238ae796f1ce8588aa31ca4c75"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#a840142238ae796f1ce8588aa31ca4c75">full_dna_alphabet</a> = &quot;[^AGCTNXMRWSKVHDB\\-]&quot;</td></tr>
<tr class="separator:a840142238ae796f1ce8588aa31ca4c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd435c5120259af4a63b40d14187c1f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSequence.html#aacd435c5120259af4a63b40d14187c1f">pep_alphabet</a> = &quot;[^ARNDBCQEZGHILKMFPSTWYV\\-]&quot;</td></tr>
<tr class="separator:aacd435c5120259af4a63b40d14187c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The namespace in which this library resides. </p>
<div class="fragment"></div><!-- fragment --><p>;.cc</p>
<p>The entirety of this library is defined in namespace <a class="el" href="namespaceSequence.html" title="The namespace in which this library resides. ">Sequence</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="aa11ceda37fe03bcacea2e98c49723f90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; std::pair&lt;std::string,int&gt; &gt; <a class="el" href="namespaceSequence.html#aa11ceda37fe03bcacea2e98c49723f90">Sequence::CodonUsageTable</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A CodonUsageTable is a vector of pairs. In each pair, the first element is the codon, and the second element is an integer counting the number of occurrences of the codon </p>

<p>Definition at line <a class="el" href="typedefs_8hpp_source.html#l00043">43</a> of file <a class="el" href="typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afaaf89009878664a009249c537dc802a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt; double, std::string &gt; <a class="el" href="namespaceSequence.html#afaaf89009878664a009249c537dc802a">Sequence::polymorphicSite</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For polymorphism data, a Site can be represented as a position (a double) and the characters at that positions (a std::string) </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="Ptable_test_8cc-example.html#a7">Ptable_test.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="typedefs_8hpp_source.html#l00050">50</a> of file <a class="el" href="typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32ee74454170cd8bfd22d7515405149c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="namespaceSequence.html#afaaf89009878664a009249c537dc802a">polymorphicSite</a> &gt; <a class="el" href="namespaceSequence.html#a32ee74454170cd8bfd22d7515405149c">Sequence::polySiteVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A polymorphism data set can be represented as a vector containing a sequence of polymorphicSite </p>

<p>Definition at line <a class="el" href="typedefs_8hpp_source.html#l00056">56</a> of file <a class="el" href="typedefs_8hpp_source.html">typedefs.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="aff4fe77c175b8c7b68ce94cb9880d82b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceSequence.html#aff4fe77c175b8c7b68ce94cb9880d82b">Sequence::GeneticCodes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Only UNIVERSAL (=0) is currently supported. The order of the genetic codes is that of NCBI's code tables, available at <a href="http://www.ncbi.nlm.nih.gov/htbin-post/Taxonomy/wprintgc?mode=c#SG2">http://www.ncbi.nlm.nih.gov/htbin-post/Taxonomy/wprintgc?mode=c#SG2</a><br/>
</p>

<p>Definition at line <a class="el" href="SeqEnums_8hpp_source.html#l00046">46</a> of file <a class="el" href="SeqEnums_8hpp_source.html">SeqEnums.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2009c170f0f10cf641e08fb544a0374d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceSequence.html#a2009c170f0f10cf641e08fb544a0374d">Sequence::Mutations</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values: Unknown=0,Ts, and Tv.<br/>
Unknown means unknown, Ts means transition, Tv means transversion </p>

<p>Definition at line <a class="el" href="SeqEnums_8hpp_source.html#l00051">51</a> of file <a class="el" href="SeqEnums_8hpp_source.html">SeqEnums.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27b0d28a22fbebd8b2407eda21caaacc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceSequence.html#a27b0d28a22fbebd8b2407eda21caaacc">Sequence::Nucleotides</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enum type for nucleotide data. Comes in handy when you need to iterate over all possible bases, etc. enum values are:A=0,T,G,C,N,GAP </p>

<p>Definition at line <a class="el" href="SeqEnums_8hpp_source.html#l00040">40</a> of file <a class="el" href="SeqEnums_8hpp_source.html">SeqEnums.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a3d4409f91640da9f1f093f76dd859649"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::addIdentityChar </td>
          <td>(</td>
          <td class="paramtype">PolyTable *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>refseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>identical</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill in a <a class="el" href="classSequence_1_1PolyTable.html" title="The base class for polymorphism tables. ">PolyTable</a> with characters representing identity to some reference sequence ("refseq") in the data. </p>

<p>Definition at line <a class="el" href="PolyTableFunctions_8cc_source.html#l00079">79</a> of file <a class="el" href="PolyTableFunctions_8cc_source.html">PolyTableFunctions.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af9ef00b653826aace505b09f269f6e93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Sequence::alignment_length </td>
          <td>(</td>
          <td class="paramtype">const samrecord &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>A <a class="el" href="classSequence_1_1samrecord.html" title="A single alignment record from a SAM file. ">Sequence::samrecord</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of all M,I,D, and N elements of a cigar string </dd></dl>

<p>Definition at line <a class="el" href="samfunctions_8cc_source.html#l00029">29</a> of file <a class="el" href="samfunctions_8cc_source.html">samfunctions.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad4b5da6e54be22c6a55108576fc10a11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Sequence::alignment_length </td>
          <td>(</td>
          <td class="paramtype">const bamrecord &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>A <a class="el" href="classSequence_1_1bamrecord.html" title="A single alignment record from a BAM file. ">Sequence::bamrecord</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of all M,I,D, and N elements of a cigar string </dd></dl>

<p>Definition at line <a class="el" href="samfunctions_8cc_source.html#l00059">59</a> of file <a class="el" href="samfunctions_8cc_source.html">samfunctions.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a1023b5e091da3de628947bf1da0644c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uni01_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::ConditionalTraj </td>
          <td>(</td>
          <td class="paramtype">uni01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>initial_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>final_frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stochastic trajectory of beneficial mutations, following Coop and Griffiths (2004). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni01</td><td>a random number generator returning a U(0,1]. </td></tr>
    <tr><td class="paramname">traj</td><td>For a diploid population of size N, this function will return trajectories equivalent to what one would get from a Wright-Fisher simulation of a haploid population of size 2N </td></tr>
    <tr><td class="paramname">dt</td><td>amount by which to change increment time during simulation. </td></tr>
    <tr><td class="paramname">initial_frequency</td><td>Initial frequency of beneficial allele (i.e. 1/2N) </td></tr>
    <tr><td class="paramname">final_frequency</td><td>Final frequency of beneficial allele (1 means fixation). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length L, such that,for dt = 1/(k*2N), L/(k*2N) is the length of the sweep, in units of 2N generations </dd></dl>

<p>Definition at line <a class="el" href="Trajectories_8tcc_source.html#l00077">77</a> of file <a class="el" href="Trajectories_8tcc_source.html">Trajectories.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="af6d6ccdace4b1873351b1813346819c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uni01_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::ConditionalTraj </td>
          <td>(</td>
          <td class="paramtype">const uni01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>initial_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>final_frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stochastic trajectory of beneficial mutations, following Coop and Griffiths (2004). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni01</td><td>a random number generator returning a U(0,1]. </td></tr>
    <tr><td class="paramname">traj</td><td>A vector of length L, such that,for dt = 1/(k*2N), L/(k*2N) is the length of the sweep, in units of 2N generations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For a diploid population of size N, this function will return trajectories equivalent to what one would get from a Wright-Fisher simulation of a haploid population of size 2N </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>amount by which to change increment time during simulation. </td></tr>
    <tr><td class="paramname">initial_frequency</td><td>Initial frequency of beneficial allele (i.e. 1/2N) </td></tr>
    <tr><td class="paramname">final_frequency</td><td>Final frequency of beneficial allele (1 means fixation). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Trajectories_8tcc_source.html#l00102">102</a> of file <a class="el" href="Trajectories_8tcc_source.html">Trajectories.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="a4ea4808f30d4863cf14362371c05e040"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uni01_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::ConditionalTraj_details </td>
          <td>(</td>
          <td class="paramtype">uni01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>initial_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>final_frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation details </p>

<p>Definition at line <a class="el" href="Trajectories_8tcc_source.html#l00011">11</a> of file <a class="el" href="Trajectories_8tcc_source.html">Trajectories.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="a2f47432317cde97fc60fdc8dd23c63c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uni01_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::ConditionalTrajNeutral </td>
          <td>(</td>
          <td class="paramtype">uni01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>initial_freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>final_freq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stochastic trajectory of a neutral allele, following Coop &amp; Griffiths (2004) TPB, and Przeworski et al. (2005) Evolution. The simulation is backwards in time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni01</td><td>a random number generator returning a U(0,1]. </td></tr>
    <tr><td class="paramname">traj</td><td>A vector of length L, and for dt=1/(k*2N), the length of time, in units of 2N generations, is given by L/(k*2N). The vector describes the change in allele frequency from <em>initial_freq</em> to <em>final_freq</em>, in jumps in time of <em>dt</em>. </td></tr>
    <tr><td class="paramname">dt</td><td>amount by which to change increment time during simulation. </td></tr>
    <tr><td class="paramname">initial_freq</td><td>Initial frequency of the neutral allele. </td></tr>
    <tr><td class="paramname">final_freq</td><td>final frequency of the neutral allele. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Trajectories_8tcc_source.html#l00127">127</a> of file <a class="el" href="Trajectories_8tcc_source.html">Trajectories.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="a47e59fa7e04b60104f6e1436eb7ae1ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uni01_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::ConditionalTrajNeutral </td>
          <td>(</td>
          <td class="paramtype">const uni01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>initial_freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>final_freq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stochastic trajectory of a neutral allele, following Coop &amp; Griffiths (2004) TPB, and Przeworski et al. (2005) Evolution. The simulation is backwards in time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni01</td><td>a random number generator returning a U(0,1]. </td></tr>
    <tr><td class="paramname">traj</td><td>A vector of length L, and for dt=1/(k*2N), the length of time, in units of 2N generations, is given by L/(k*2N). The vector describes the change in allele frequency from <em>initial_freq</em> to <em>final_freq</em>, in jumps in time of <em>dt</em>. </td></tr>
    <tr><td class="paramname">dt</td><td>amount by which to change increment time during simulation. </td></tr>
    <tr><td class="paramname">initial_freq</td><td>Initial frequency of the neutral allele. </td></tr>
    <tr><td class="paramname">final_freq</td><td>final frequency of the neutral allele. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Trajectories_8tcc_source.html#l00150">150</a> of file <a class="el" href="Trajectories_8tcc_source.html">Trajectories.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="a065e92d81c4f66e39cd10eea8101013a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uni01_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::ConditionalTrajNeutral_details </td>
          <td>(</td>
          <td class="paramtype">uni01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>initial_freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>final_freq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implementation details </p>

<p>Definition at line <a class="el" href="Trajectories_8tcc_source.html#l00048">48</a> of file <a class="el" href="Trajectories_8tcc_source.html">Trajectories.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ad5a3bdc53e14704400f877e6953d0792"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sequence::containsCharacter </td>
          <td>(</td>
          <td class="paramtype">const PolyTable *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <em>t</em> contains <em>ch</em>, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="PolyTableFunctions_8cc_source.html#l00033">33</a> of file <a class="el" href="PolyTableFunctions_8cc_source.html">PolyTableFunctions.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a1f7074dc3f332bf29900c43b64442f03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Sequence::deletion_distance </td>
          <td>(</td>
          <td class="paramtype">const samrecord &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>A <a class="el" href="classSequence_1_1samrecord.html" title="A single alignment record from a SAM file. ">Sequence::samrecord</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of all D elements of a cigar string </dd></dl>

<p>Definition at line <a class="el" href="samfunctions_8cc_source.html#l00126">126</a> of file <a class="el" href="samfunctions_8cc_source.html">samfunctions.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0458665ad262a68d20a0d6e2ad6babdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Sequence::deletion_distance </td>
          <td>(</td>
          <td class="paramtype">const bamrecord &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>A <a class="el" href="classSequence_1_1bamrecord.html" title="A single alignment record from a BAM file. ">Sequence::bamrecord</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of all D elements of a cigar string </dd></dl>

<p>Definition at line <a class="el" href="samfunctions_8cc_source.html#l00145">145</a> of file <a class="el" href="samfunctions_8cc_source.html">samfunctions.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac45c04f3606f1ff0b7ba495c52339192"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sequence::Different </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seq1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seq2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>skip_missing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>nucleic_acid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ask if two strings are different. While this can normally be done by asking if (seq1 != seq2) {}, missing data poses a problem here. If skip-missing == 1, missing data (the 'N' character for nucleotide data, 'X' for amino acid) are not used to determine if the sequences are different. If nucleic_acid ==1, nucleotide data are assumed, if nucleic_acid==0, protein data are assumed. </p>
<dl class="section note"><dt>Note</dt><dd>case-insensitive </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the seqs are different, false otherwise. If the two sequences are of different length, true is returned. </dd></dl>

<p>Definition at line <a class="el" href="Comparisons_8cc_source.html#l00095">95</a> of file <a class="el" href="Comparisons_8cc_source.html">Comparisons.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a022cdbeee8819e81d448eefbe1cc4e2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned, <a class="el" href="classSequence_1_1shortestPath.html#ae1c4034e9dad83fafb969f5e5400247d">shortestPath::pathType</a> &gt; Sequence::diffType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>codon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>codon2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSequence.html#aff4fe77c175b8c7b68ce94cb9880d82b">Sequence::GeneticCodes</a> &amp;&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codon1</td><td>a std::string of length 3 representing a codon </td></tr>
    <tr><td class="paramname">codon2</td><td>a std::string of length 3 representing a codon </td></tr>
    <tr><td class="paramname">code</td><td>the genetic code to use in translating the codons </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::pair&lt;unsigned,shortestPath::pathType&gt;. The first member of the pair takes a value of either 0,1, or 2, depending on the site at which the two codons differ (1st, 2nd, or 3rd position, respectively). If the codons differ at more than 1 site, or contain characters other that {A,G,C,T}, the first member will be set to <a class="el" href="namespaceSequence.html#ac427687431515f70256efb59893388ce">Sequence::SEQMAXUNSIGNED</a>. The second member will have the value Sequence::shortestPath::pathType::N if the change is nonsynonymous, Sequence::shortestPath::pathType::S if synonymous, Sequence::shortestPath::pathType::NONE if the codons don't differ, and Sequence::shortestPath::pathType::AMBIG if any of the codons contain characters other than {A,G,C,T}. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(codon1.length()==3 &amp;&amp; codon2.length() == 3) </dd></dl>

<p>Definition at line <a class="el" href="shortestPath_8cc_source.html#l00428">428</a> of file <a class="el" href="shortestPath_8cc_source.html">shortestPath.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ae76fd0402decf4d1790a72acc745a0d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classSequence_1_1shortestPath.html#ae1c4034e9dad83fafb969f5e5400247d">shortestPath::pathType</a>, <a class="el" href="classSequence_1_1shortestPath.html#ae1c4034e9dad83fafb969f5e5400247d">shortestPath::pathType</a>, <a class="el" href="classSequence_1_1shortestPath.html#ae1c4034e9dad83fafb969f5e5400247d">shortestPath::pathType</a> &gt; Sequence::diffTypeMulti </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>codon1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>codon2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSequence.html#aff4fe77c175b8c7b68ce94cb9880d82b">Sequence::GeneticCodes</a> &amp;&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a tuple representing the type of single position changes between codon1 and codon2. There is one value in the tuple for each codon position. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The values are assigned as follows: For each position in codon1, and 2, swap the i-th state between the two codons. If this results in a replacement change in both cases, record shortestPath::N. If it's synonymous in both cases, record shortestPath::S. If the swap results in no change at all (i.e. the two bases are identical), record shortestPath::NONE. For all other cases, record shortestPath::AMBIG. This function is most useful at identifying mutations that can be unambiguously classifies as silent or replacement. Note that, if one considers the pathways possible between codons, all sites can be assigned as N or S. For such applications, use <a class="el" href="classSequence_1_1shortestPath.html" title="Calculate shortest path between 2 codons. ">Sequence::shortestPath</a>. </dd></dl>

<p>Definition at line <a class="el" href="shortestPath_8cc_source.html#l00481">481</a> of file <a class="el" href="shortestPath_8cc_source.html">shortestPath.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a6df882d04ca426b57df54a2b418880aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::fillIn </td>
          <td>(</td>
          <td class="paramtype">PolyTable *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>refseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>identical</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sometimes polymorphism data contain a special character that means that a particular state is identical to a reference sequence in the data. This function replaces that character with the state of the reference sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>a <a class="el" href="classSequence_1_1PolyTable.html" title="The base class for polymorphism tables. ">PolyTable</a> </td></tr>
    <tr><td class="paramname">refseq</td><td>the index of the reference sequence </td></tr>
    <tr><td class="paramname">identical</td><td>the character used to represent identity to the refseq </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="PolyTableFunctions_8cc_source.html#l00051">51</a> of file <a class="el" href="PolyTableFunctions_8cc_source.html">PolyTableFunctions.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a6b8d03d21bed077f2f95790a2bc55a3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sequence::Gapped </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ask if the std::string contains a gap character. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the string contains gaps, false otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The only gap character checked so far is '-'. Use template version for other gap characters </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="Comparisons_8cc_source.html#l00181">181</a> of file <a class="el" href="Comparisons_8cc_source.html">Comparisons.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a08fada3765a298420876704a4ca57623"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sequence::Gapped </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>gapchar</em> = <code>'-'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>an iterator </td></tr>
    <tr><td class="paramname">end</td><td>an iterator </td></tr>
    <tr><td class="paramname">gapchar</td><td>a character representing an aligment gap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>gapchar</em> is present in the range [beg,end), false otherwise </dd></dl>

<p>Definition at line <a class="el" href="Comparisons_8hpp_source.html#l00059">59</a> of file <a class="el" href="Comparisons_8hpp_source.html">Comparisons.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a021e757de67d631c5c10d2f8b3d4522d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Sequence::insertion_distance </td>
          <td>(</td>
          <td class="paramtype">const samrecord &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>A <a class="el" href="classSequence_1_1samrecord.html" title="A single alignment record from a SAM file. ">Sequence::samrecord</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of all I elements of a cigar string </dd></dl>

<p>Definition at line <a class="el" href="samfunctions_8cc_source.html#l00090">90</a> of file <a class="el" href="samfunctions_8cc_source.html">samfunctions.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a848c7366d1b16116ff667f278f01384a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Sequence::insertion_distance </td>
          <td>(</td>
          <td class="paramtype">const bamrecord &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>A <a class="el" href="classSequence_1_1bamrecord.html" title="A single alignment record from a BAM file. ">Sequence::bamrecord</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of all I elements of a cigar string </dd></dl>

<p>Definition at line <a class="el" href="samfunctions_8cc_source.html#l00109">109</a> of file <a class="el" href="samfunctions_8cc_source.html">samfunctions.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ab034fd4b0b756671f74a26b5828707e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sequence::internalGapCheck </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>gapchar</em> = <code>'-'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>mod</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function checks a range for internal gaps that meet a certain length requirement. The requirement is that lengthmod == 0. The value true is returned if this is not the case, false otherwise. One use of this function may be to check that the internal gaps in an aligned cds sequence are all multiples of 3 in length. </p>

<p>Definition at line <a class="el" href="SeqUtilities_8hpp_source.html#l00086">86</a> of file <a class="el" href="SeqUtilities_8hpp_source.html">SeqUtilities.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58bae55ce26ada3c758d5480565da1f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSequence.html#aa11ceda37fe03bcacea2e98c49723f90">CodonUsageTable</a> Sequence::makeCodonUsageTable </td>
          <td>(</td>
          <td class="paramtype">const Seq *&#160;</td>
          <td class="paramname"><em>sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>and object of type Sequence::Seq1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>and object of type <a class="el" href="namespaceSequence.html#aa11ceda37fe03bcacea2e98c49723f90">Sequence::CodonUsageTable</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assumes first character of sequence is a first codon position. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="codons_8cc-example.html#a3">codons.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CodonTable_8cc_source.html#l00081">81</a> of file <a class="el" href="CodonTable_8cc_source.html">CodonTable.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a50f3df3ad2810343c544036f6de2f3ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSequence.html#aa11ceda37fe03bcacea2e98c49723f90">CodonUsageTable</a> Sequence::makeCodonUsageTable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>and object of type std::string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>and object of type <a class="el" href="namespaceSequence.html#aa11ceda37fe03bcacea2e98c49723f90">Sequence::CodonUsageTable</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assumes first character of sequence is a first codon position </dd></dl>

<p>Definition at line <a class="el" href="CodonTable_8cc_source.html#l00091">91</a> of file <a class="el" href="CodonTable_8cc_source.html">CodonTable.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a4ece33a045f69189932dd14f6c77e6b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSequence.html#aa11ceda37fe03bcacea2e98c49723f90">CodonUsageTable</a> Sequence::makeCodonUsageTable </td>
          <td>(</td>
          <td class="paramtype">std::string::const_iterator&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::const_iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>a const_iterator to the beginning of a std::string or <a class="el" href="classSequence_1_1Seq.html" title="Abstract interface to sequence objects. ">Sequence::Seq</a> </td></tr>
    <tr><td class="paramname">end</td><td>a const_iterator to the end of a std::string or <a class="el" href="classSequence_1_1Seq.html" title="Abstract interface to sequence objects. ">Sequence::Seq</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>and object of type <a class="el" href="namespaceSequence.html#aa11ceda37fe03bcacea2e98c49723f90">Sequence::CodonUsageTable</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>beg and end can be adjusted to point to the first at last positions in a CDS </dd></dl>

<p>Definition at line <a class="el" href="CodonTable_8cc_source.html#l00101">101</a> of file <a class="el" href="CodonTable_8cc_source.html">CodonTable.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0bdb6d8aaf283e419945540da5d8c1f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; typename std::iterator_traits&lt; Iterator &gt;::value_type, unsigned &gt; Sequence::makeCountList </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>an iterator </td></tr>
    <tr><td class="paramname">end</td><td>an iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::map&lt; type, unsigned &gt;, where type is the iterator_traits&lt;Iterator&gt;::value_type of Iterator. The keys are the (unique) elements present in the range, and the unsinged values the numbers of times each element occurs occur </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function can be used as an alternative to <a class="el" href="classSequence_1_1stateCounter.html" title="keep track of state counts at a site in an alignment or along a sequence ">Sequence::stateCounter</a> if you want to count more than just strict DNA characters. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="baseComp_8cc-example.html#a11">baseComp.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="SeqUtilities_8hpp_source.html#l00061">61</a> of file <a class="el" href="SeqUtilities_8hpp_source.html">SeqUtilities.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a11af83da11f8a27390d4c65758a04aff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; Sequence::meanAndVar </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function to calculate the mean and variance of the values stored in a container. The rationale is that when both the mean and the variance (an sum of squares) are needed, it is more efficient to calculate them together, because you only go over the data once. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="critical_values_8cc-example.html#a2">critical_values.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="descriptiveStats_8tcc_source.html#l00066">66</a> of file <a class="el" href="descriptiveStats_8tcc_source.html">descriptiveStats.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="aceb81bf8beb9ed32b1dd2b3c35cfcebf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::minimize_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">Sequence::arg</a> *&#160;</td>
          <td class="paramname"><em>sample_history</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes an arg (Ancestral <a class="el" href="namespaceSequence_1_1Recombination.html" title="Methods dealing with recombination. ">Recombination</a> Graph) and removes redundant marginal trees. Specifically, for two adjacent trees i and j (j-&gt;beg &gt; i-&gt;beg), j is removed from the arg if the topology and branch lengths of i and j are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample_history</td><td>the arg to minimize </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a12">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentTreeOperations_8cc_source.html#l00169">169</a> of file <a class="el" href="CoalescentTreeOperations_8cc_source.html">CoalescentTreeOperations.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0103fc02fbf48c8a8303761b1a7ade7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Sequence::mismatches </td>
          <td>(</td>
          <td class="paramtype">const samrecord &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>A <a class="el" href="classSequence_1_1samrecord.html" title="A single alignment record from a SAM file. ">Sequence::samrecord</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the NM tag of b - <a class="el" href="namespaceSequence.html#a8f20401d611c3a10427a95116f838d93">Sequence::ngaps</a>. If the NM tag does not exist, std::numeric_limits&lt;unsigned&gt;::max() is returned. Likewise, is Sequence::ngams &gt; the value of the NM tag, std::numeric_limits&lt;unsigned&gt;::max() is returned, as the NM tag contains a value that doesn't correspond to the documented definition of that tag.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A limitation of the SAM file format is that the number of mismatches are not recorded in any of the required data fields. The NM tag is an optional field, and is defined as the edit distance of the read from the reference (e.g., the sum of mismatches + indels). This definition suggests the return values described above, but one must trust that the alignment software authors have correctly assigned a value to the NM field. </dd></dl>

<p>Definition at line <a class="el" href="samfunctions_8cc_source.html#l00183">183</a> of file <a class="el" href="samfunctions_8cc_source.html">samfunctions.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a9002a46767787604d60712821a5009f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Sequence::mismatches </td>
          <td>(</td>
          <td class="paramtype">const bamrecord &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>A <a class="el" href="classSequence_1_1bamrecord.html" title="A single alignment record from a BAM file. ">Sequence::bamrecord</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the NM tag of b - <a class="el" href="namespaceSequence.html#a8f20401d611c3a10427a95116f838d93">Sequence::ngaps</a>. If the NM tag does not exist, std::numeric_limits&lt;unsigned&gt;::max() is returned. Likewise, is Sequence::ngams &gt; the value of the NM tag, std::numeric_limits&lt;unsigned&gt;::max() is returned, as the NM tag contains a value that doesn't correspond to the documented definition of that tag.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A limitation of the SAM/BAM file format is that the number of mismatches are not recorded in any of the required data fields. The NM tag is an optional field, and is defined as the edit distance of the read from the reference (e.g., the sum of mismatches + indels). This definition suggests the return values described above, but one must trust that the alignment software authors have correctly assigned a value to the NM field. </dd></dl>

<p>Definition at line <a class="el" href="samfunctions_8cc_source.html#l00218">218</a> of file <a class="el" href="samfunctions_8cc_source.html">samfunctions.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a8f20401d611c3a10427a95116f838d93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Sequence::ngaps </td>
          <td>(</td>
          <td class="paramtype">const samrecord &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>A <a class="el" href="classSequence_1_1samrecord.html" title="A single alignment record from a SAM file. ">Sequence::samrecord</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespaceSequence.html#a021e757de67d631c5c10d2f8b3d4522d">Sequence::insertion_distance</a> + <a class="el" href="namespaceSequence.html#a1f7074dc3f332bf29900c43b64442f03">Sequence::deletion_distance</a> </dd></dl>

<p>Definition at line <a class="el" href="samfunctions_8cc_source.html#l00163">163</a> of file <a class="el" href="samfunctions_8cc_source.html">samfunctions.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad323cf6103d7a003a32c1684ba111404"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Sequence::ngaps </td>
          <td>(</td>
          <td class="paramtype">const bamrecord &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>A <a class="el" href="classSequence_1_1bamrecord.html" title="A single alignment record from a BAM file. ">Sequence::bamrecord</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespaceSequence.html#a021e757de67d631c5c10d2f8b3d4522d">Sequence::insertion_distance</a> + <a class="el" href="namespaceSequence.html#a1f7074dc3f332bf29900c43b64442f03">Sequence::deletion_distance</a> </dd></dl>

<p>Definition at line <a class="el" href="samfunctions_8cc_source.html#l00173">173</a> of file <a class="el" href="samfunctions_8cc_source.html">samfunctions.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0a76f7fc1d7afe7494d999300a79f669"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sequence::NotAGap </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if a c is not a gap character, false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Currently, only '-' is considered to be a gap character </dd></dl>

<p>Definition at line <a class="el" href="Comparisons_8cc_source.html#l00193">193</a> of file <a class="el" href="Comparisons_8cc_source.html">Comparisons.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0ae39379bc92ab7feed829028035fce9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::NumDiffs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seq1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seq2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>skip_missing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>nucleic_acid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq1</td><td>A string representing a sequence </td></tr>
    <tr><td class="paramname">seq2</td><td>A string representing a sequence </td></tr>
    <tr><td class="paramname">skip_missing</td><td>If true, missing data characters will not be counted as differences </td></tr>
    <tr><td class="paramname">nucleic_acid.</td><td>If true, n/N are the missing data symbol. If false, x/X. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of differences between two std::strings. Can skip missing data in the same fashion as Comparisons::Different. If one sequence is shorter than the other, -1 is returned </dd></dl>

<p>Definition at line <a class="el" href="Comparisons_8cc_source.html#l00138">138</a> of file <a class="el" href="Comparisons_8cc_source.html">Comparisons.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a3ef776db43acd7fad114f653a59de8e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Sequence::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const samtag &amp;&#160;</td>
          <td class="paramname"><em>st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes tag as a string </p>

<p>Definition at line <a class="el" href="samrecord_8cc_source.html#l00074">74</a> of file <a class="el" href="samrecord_8cc_source.html">samrecord.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ae052d7ac56d82097049f7d5f84ccd81c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Sequence::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const newick_stream_marginal_tree &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>n.print(o); </dd></dl>

<p>Definition at line <a class="el" href="CoalescentSimTypes_8cc_source.html#l00460">460</a> of file <a class="el" href="CoalescentSimTypes_8cc_source.html">CoalescentSimTypes.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af627cea569749228dfcc80917d20e06e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; Sequence::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">newick_stream_marginal_tree &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>n.read(o); </dd></dl>

<p>Definition at line <a class="el" href="CoalescentSimTypes_8cc_source.html#l00468">468</a> of file <a class="el" href="CoalescentSimTypes_8cc_source.html">CoalescentSimTypes.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a80ca235b3a31288ab65f98507c312be6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::output_gametes </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>segsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gamete_storage_type &amp;&#160;</td>
          <td class="paramname"><em>gametes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an object of type gamete_storage type to a C-style file stream This function is used when you need to output simulated gametes using a method faster than the operator&lt;&lt; for class <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>pointer to an open C-style output stream </td></tr>
    <tr><td class="paramname">segsites</td><td>the number of segregating sites in <em>gametes</em> </td></tr>
    <tr><td class="paramname">nsam</td><td>the number of individuals in <em>gametes</em> </td></tr>
    <tr><td class="paramname">gametes</td><td>the simulated sample. Must be allocated to hold at least <em>segsites</em> positions, and <em>nsam</em> strings of length <em>segsites</em> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="freerec_8cc-example.html#a10">freerec.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentMutation_8cc_source.html#l00028">28</a> of file <a class="el" href="CoalescentMutation_8cc_source.html">CoalescentMutation.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a8ad6da6579788349c3f9f442c31c3805"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iter1 , typename iter2 , typename correlation_type , typename comparison_function , typename shuffler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double Sequence::PermuteCorrelation </td>
          <td>(</td>
          <td class="paramtype">iter1&#160;</td>
          <td class="paramname"><em>beg_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iter1&#160;</td>
          <td class="paramname"><em>end_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iter2&#160;</td>
          <td class="paramname"><em>beg_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const correlation_type &amp;&#160;</td>
          <td class="paramname"><em>corr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const comparison_function &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shuffler &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>NPERM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtain the p-value of a correlation coefficient by permutation. This function can be used to get 1- or 2- tailed p-values by using different comparison_function objects. For example, using std::greater_equal&lt;double&gt; will returned the 1-tailed probability of observing a correlation &gt;= the observed value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg_x</td><td>pointer to the beginning of the range of the 1st vector </td></tr>
    <tr><td class="paramname">end_x</td><td>pointer to the end of the range of the 1st vector </td></tr>
    <tr><td class="paramname">beg_y</td><td>pointer to the beginning of the range of the 2nd vector </td></tr>
    <tr><td class="paramname">corr</td><td>a function object to calculate the correlation statistic (i.e. <a class="el" href="structSequence_1_1ProductMoment.html" title="Pearson&#39;s product-moment correlation. ">ProductMoment</a>) </td></tr>
    <tr><td class="paramname">comp</td><td>a comparison function </td></tr>
    <tr><td class="paramname">NPERM</td><td>number of permutations to do </td></tr>
    <tr><td class="paramname">rand</td><td>a function returning a random integer (must be compatible with std::random_shuffle) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function keeps the order of the 2 containers intact. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="correlations_8cc-example.html#a2">correlations.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="Correlations_8tcc_source.html#l00196">196</a> of file <a class="el" href="Correlations_8tcc_source.html">Correlations.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ac24509f39ce9d1735556d677555fabfb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iter1 , typename iter2 , typename correlation_type , typename comparison_function , typename shuffler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double Sequence::PermuteCorrelation </td>
          <td>(</td>
          <td class="paramtype">iter1&#160;</td>
          <td class="paramname"><em>beg_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iter1&#160;</td>
          <td class="paramname"><em>end_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iter2&#160;</td>
          <td class="paramname"><em>beg_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const correlation_type &amp;&#160;</td>
          <td class="paramname"><em>corr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const comparison_function &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shuffler &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>NPERM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtain the p-value of a correlation coefficient by permutation. This function can be used to get 1- or 2- tailed p-values by using different comparison_function objects. For example, using std::greater_equal&lt;double&gt; will returned the 1-tailed probability of observing a correlation &gt;= the observed value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg_x</td><td>pointer to the beginning of the range of the 1st vector </td></tr>
    <tr><td class="paramname">end_x</td><td>pointer to the end of the range of the 1st vector </td></tr>
    <tr><td class="paramname">beg_y</td><td>pointer to the beginning of the range of the 2nd vector </td></tr>
    <tr><td class="paramname">corr</td><td>a function object to calculate the correlation statistic (i.e. <a class="el" href="structSequence_1_1ProductMoment.html" title="Pearson&#39;s product-moment correlation. ">ProductMoment</a>) </td></tr>
    <tr><td class="paramname">comp</td><td>a comparison function </td></tr>
    <tr><td class="paramname">NPERM</td><td>number of permutations to do </td></tr>
    <tr><td class="paramname">rand</td><td>a function returning a random integer (must be compatible with std::random_shuffle) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function keeps the order of the 2 containers intact. </dd></dl>

<p>Definition at line <a class="el" href="Correlations_8tcc_source.html#l00223">223</a> of file <a class="el" href="Correlations_8tcc_source.html">Correlations.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="a59bf69ad44829dececa75440a9f4e7cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sequence::PolyTableValid </td>
          <td>(</td>
          <td class="paramtype">const PolyTable *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the following conditions are met : First, the length of every row in the table is equal to the length of the vector of positions. Second, all of the characters in the data are members of the set {A,G,C,T,N,-} (case-insensitive).</dd></dl>
<p>This function is useful if you play around with <a class="el" href="classSequence_1_1PolyTable.html" title="The base class for polymorphism tables. ">PolyTable</a> objects in non-const contexts, or read them in from files and need to check that the data are compatible with other routines in this library. This routine can be thought of as a <a class="el" href="classSequence_1_1PolyTable.html" title="The base class for polymorphism tables. ">PolyTable</a> equivalent to <a class="el" href="namespaceSequence_1_1Alignment.html#ae60cbc30ba0c28af28b3eda2a162e823">Alignment::validForPolyAnalysis</a>, which works on ranges of <a class="el" href="classSequence_1_1Seq.html" title="Abstract interface to sequence objects. ">Sequence::Seq</a> objects. </p>

<p>Definition at line <a class="el" href="PolyTableFunctions_8cc_source.html#l00189">189</a> of file <a class="el" href="PolyTableFunctions_8cc_source.html">PolyTableFunctions.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aaffd3b2fa5f10fb331e7b75366442d71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSequence_1_1SimData.html">SimData</a> Sequence::read_SimData_binary </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> object in binary format from an istream</p>
<p>The format of the binary data is: nsam (unsigned) nsites (unsigned) nsites doubles representing the mutation positions Then, there are nsam records containing: nsites_i (unsigned) = # mutations on haplotype i, followed by nsites_i unsigned values representing the indexes (from 0 to nsites-1) where the derived mutations are on haplotype i </p>

<p>Definition at line <a class="el" href="SimDataIO_8cc_source.html#l00133">133</a> of file <a class="el" href="SimDataIO_8cc_source.html">SimDataIO.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a48aba7d7a76e64c00e49a958695321e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSequence_1_1SimData.html">SimData</a> Sequence::read_SimData_gz </td>
          <td>(</td>
          <td class="paramtype">gzFile &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>binary</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> object from a gzFile object (from the C-language zlib library)</p>
<dl class="section note"><dt>Note</dt><dd>Only guaranteed compatible with compressed data written using write_SimData_gz. In other words, if you say ms [params] | gzip &gt; file.gz, then you cannot expect to use this function to read in the data, and you should use a boost filtering_istream instead. </dd></dl>

<p>Definition at line <a class="el" href="SimDataIO_8cc_source.html#l00035">35</a> of file <a class="el" href="SimDataIO_8cc_source.html">SimDataIO.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a1d0aa47cde1d6632c9fff3a6be97b509"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::RemoveGaps </td>
          <td>(</td>
          <td class="paramtype">PolyTable *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>gapchar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all positions containing <em>gapchar</em> from <em>table</em> </p>

<p>Definition at line <a class="el" href="PolyTableFunctions_8cc_source.html#l00108">108</a> of file <a class="el" href="PolyTableFunctions_8cc_source.html">PolyTableFunctions.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a21736523aa0d62767da47627190730a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::RemoveInvariantColumns </td>
          <td>(</td>
          <td class="paramtype">PolyTable *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>skipOutgroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>outgroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Goes through the data and removes any columns that contain only 1 state. There is an option to ignore the state of the outgroup in this calculation. \ </p>

<p>Definition at line <a class="el" href="PolyTableFunctions_8cc_source.html#l00145">145</a> of file <a class="el" href="PolyTableFunctions_8cc_source.html">PolyTableFunctions.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a75b90c6ccf6178eb60649717875611b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSequence.html#a2009c170f0f10cf641e08fb544a0374d">Mutations</a> Sequence::TsTv </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes two chars, assumed to be nucleotides. The integer returned by this function is a member of the enumeration type <a class="el" href="namespaceSequence.html#a2009c170f0f10cf641e08fb544a0374d">Sequence::Mutations</a>. </p>

<p>Definition at line <a class="el" href="Comparisons_8cc_source.html#l00035">35</a> of file <a class="el" href="Comparisons_8cc_source.html">Comparisons.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a00fad2015afe27a90ba999cfaaade053"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSequence.html#a2009c170f0f10cf641e08fb544a0374d">Mutations</a> Sequence::TsTv </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes two ints, assumed to be integer representations of nucleotides. The way to ensure that the int represents a nucleotide in a valid way is to use <a class="el" href="namespaceSequence.html#a27b0d28a22fbebd8b2407eda21caaacc">Sequence::Nucleotides</a>. The return value is determined by a call to Comparisons::TsTv(int i, int j), where the ints are defined in turn by <a class="el" href="namespaceSequence.html#a27b0d28a22fbebd8b2407eda21caaacc">Sequence::Nucleotides</a> </p>

<p>Definition at line <a class="el" href="Comparisons_8cc_source.html#l00071">71</a> of file <a class="el" href="Comparisons_8cc_source.html">Comparisons.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a3a96d1177eef3a800d6d881a334fc377"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Sequence::validSeq </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>_pattern</em> = <code><a class="el" href="namespaceSequence.html#a264064250dc327bf9785e92987ef7517">Sequence::basic_dna_alphabet</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>icase</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>an iterator to the beginning of a range </td></tr>
    <tr><td class="paramname">end</td><td>an iterator to the end of a range </td></tr>
    <tr><td class="paramname">_pattern</td><td>the (complement of the) alphabet as a regular expression. </td></tr>
    <tr><td class="paramname">icase</td><td>defaults to case insensitive matching. Pass "false" to make matching case sensitive The character set is complemented because we test for not in the alphabet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>beg</em> and <em>end</em> define a range of valid characters. The range is valid if and only if all characters in the range are present in the pattern (i.e. are not part of the set of characters that complement the pattern) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="valid_dna_8cc-example.html#a1">valid_dna.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="SeqRegexes_8hpp_source.html#l00055">55</a> of file <a class="el" href="SeqRegexes_8hpp_source.html">SeqRegexes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae05af9443e408030a602af7f3e359a42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::write_SimData_binary </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimData &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> object in binary format to an ostream.</p>
<p>The format of the binary data is: nsam (uint32_t) nsites (uint32_t) nsites doubles representing the mutation positions Then, there are nsam records containing: nsites_i (uint32_t) = # mutations on haplotype i, followed by nsites_i values (uint32_t) representing the indexes (from 0 to nsites-1) where the derived mutations are on haplotype i </p>

<p>Definition at line <a class="el" href="SimDataIO_8cc_source.html#l00109">109</a> of file <a class="el" href="SimDataIO_8cc_source.html">SimDataIO.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af0032530490a32b1932a2a8895f7ffcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long int Sequence::write_SimData_binary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimData &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> object in binary format to a C-style file descriptor</p>
<p>The format of the binary data is: nsam (uint32_t) nsites (uint32_t) nsites doubles representing the mutation positions Then, there are nsam records containing: nsites_i (uint32_t) = # mutations on haplotype i, followed by nsites_i values (uint32_t) representing the indexes (from 0 to nsites-1) where the derived mutations are on haplotype i </p>

<p>Definition at line <a class="el" href="SimDataIO_8cc_source.html#l00165">165</a> of file <a class="el" href="SimDataIO_8cc_source.html">SimDataIO.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aa6fa5decc918fee6b486766ee8f3f646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long int Sequence::write_SimData_binary </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimData &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> object in binary format to a C-style file pointer</p>
<p>The format of the binary data is: nsam (uint32_t) nsites (uint32_t) nsites doubles representing the mutation positions Then, there are nsam records containing: nsites_i (uint32_t) = # mutations on haplotype i, followed by nsites_i values (uint32_t) representing the indexes (from 0 to nsites-1) where the derived mutations are on haplotype i </p>

<p>Definition at line <a class="el" href="SimDataIO_8cc_source.html#l00172">172</a> of file <a class="el" href="SimDataIO_8cc_source.html">SimDataIO.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aeae687725adae15b549c4d005b9683f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long Sequence::write_SimData_gz </td>
          <td>(</td>
          <td class="paramtype">gzFile &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimData &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>binary</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> object to a gzFile object (from the C-language zlib library) Returns the amount of data written, or -1 on error. </p>

<p>Definition at line <a class="el" href="SimDataIO_8cc_source.html#l00014">14</a> of file <a class="el" href="SimDataIO_8cc_source.html">SimDataIO.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a264064250dc327bf9785e92987ef7517"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Sequence::basic_dna_alphabet = &quot;[^AGTCN\\-]&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A regex for the complement of the minimal DNA alphabet </p>

<p>Definition at line <a class="el" href="SeqRegexes_8hpp_source.html#l00040">40</a> of file <a class="el" href="SeqRegexes_8hpp_source.html">SeqRegexes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afd409ce3106271ea202b6ed998268040"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt; const char, 17 &gt; Sequence::dna_alphabet</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{ {<span class="charliteral">&#39;A&#39;</span>,<span class="charliteral">&#39;C&#39;</span>,<span class="charliteral">&#39;G&#39;</span>,<span class="charliteral">&#39;T&#39;</span>,</div>
<div class="line">        <span class="charliteral">&#39;R&#39;</span>,<span class="charliteral">&#39;Y&#39;</span>,<span class="charliteral">&#39;S&#39;</span>,<span class="charliteral">&#39;W&#39;</span>,</div>
<div class="line">        <span class="charliteral">&#39;K&#39;</span>,<span class="charliteral">&#39;M&#39;</span>,<span class="charliteral">&#39;B&#39;</span>,<span class="charliteral">&#39;D&#39;</span>,</div>
<div class="line">        <span class="charliteral">&#39;H&#39;</span>,<span class="charliteral">&#39;V&#39;</span>,<span class="charliteral">&#39;N&#39;</span>,<span class="charliteral">&#39;-&#39;</span>,<span class="charliteral">&#39;.&#39;</span>} }</div>
</div><!-- fragment --><p>Valid DNA characters. Upper-case only. Both . and - are accepted as gap characters </p>
<dl class="section note"><dt>Note</dt><dd><a href="http://www.bioinformatics.org/sms/iupac.html,">http://www.bioinformatics.org/sms/iupac.html,</a> excluding U </dd></dl>

<p>Definition at line <a class="el" href="SeqAlphabets_8cc_source.html#l00006">6</a> of file <a class="el" href="SeqAlphabets_8cc_source.html">SeqAlphabets.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a840142238ae796f1ce8588aa31ca4c75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Sequence::full_dna_alphabet = &quot;[^AGCTNXMRWSKVHDB\\-]&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A regex for the complement of a complete DNA alphabet </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="valid_dna_8cc-example.html#a4">valid_dna.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="SeqRegexes_8hpp_source.html#l00045">45</a> of file <a class="el" href="SeqRegexes_8hpp_source.html">SeqRegexes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aacd435c5120259af4a63b40d14187c1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Sequence::pep_alphabet = &quot;[^ARNDBCQEZGHILKMFPSTWYV\\-]&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A regex for the complement of an amino acid alphabet </p>

<p>Definition at line <a class="el" href="SeqRegexes_8hpp_source.html#l00050">50</a> of file <a class="el" href="SeqRegexes_8hpp_source.html">SeqRegexes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4311dadc006f2bfcdbd3b3f9b7b324f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double Sequence::SEQMAXDOUBLE = std::numeric_limits&lt;double&gt;::max()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum value of an double </p>

<p>Definition at line <a class="el" href="SeqConstants_8cc_source.html#l00036">36</a> of file <a class="el" href="SeqConstants_8cc_source.html">SeqConstants.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac427687431515f70256efb59893388ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned Sequence::SEQMAXUNSIGNED = std::numeric_limits&lt;unsigned&gt;::max()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum value of an unsinged integer. </p>

<p>Definition at line <a class="el" href="SeqConstants_8cc_source.html#l00032">32</a> of file <a class="el" href="SeqConstants_8cc_source.html">SeqConstants.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceSequence.html">Sequence</a></li>
    <li class="footer">Generated on Sun Dec 14 2014 06:28:14 for libsequence by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
