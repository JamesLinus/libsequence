<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libsequence: Classes and functions related to simulating data under coalescent models</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsequence
   &#160;<span id="projectnumber">1.8.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__coalescent.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Classes and functions related to simulating data under coalescent models<div class="ingroups"><a class="el" href="group__popgen.html">Molecular Population Genetics</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1SimData.html">Sequence::SimData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data from coalescent simulations.  <a href="classSequence_1_1SimData.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1SimParams.html">Sequence::SimParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for Hudson's simulation program.  <a href="classSequence_1_1SimParams.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1segment.html">Sequence::segment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A portion of a recombining chromosome.  <a href="structSequence_1_1segment.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1chromosome.html">Sequence::chromosome</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A chromosome is a container of segments.  <a href="structSequence_1_1chromosome.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1node.html">Sequence::node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point on a marginal tree at which a coalescent event occurs.  <a href="structSequence_1_1node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1marginal.html">Sequence::marginal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The genealogy of a portion of a chromosome on which no recombination has occurred.  <a href="structSequence_1_1marginal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1newick__stream__marginal__tree.html">Sequence::newick_stream_marginal_tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides a typecast-on-output of a marginal tree to a newick tree Example use:  <a href="classSequence_1_1newick__stream__marginal__tree.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga48c093934ec4ec1c477415f86a2ffed3"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; std::vector<br class="typebreak"/>
&lt; double &gt;, std::vector<br class="typebreak"/>
&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga48c093934ec4ec1c477415f86a2ffed3">Sequence::gamete_storage_type</a></td></tr>
<tr class="memdesc:ga48c093934ec4ec1c477415f86a2ffed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">an object to store simulated gametes An object of this type will tend to exist in the calling environment of your program. If you are simulating a sample of n chromosomes, you would initialize the object as follows:  <a href="#ga48c093934ec4ec1c477415f86a2ffed3">More...</a><br/></td></tr>
<tr class="separator:ga48c093934ec4ec1c477415f86a2ffed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1116020585e7246433b28c69b0623a20"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; marginal &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">Sequence::arg</a></td></tr>
<tr class="memdesc:ga1116020585e7246433b28c69b0623a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ancestral <a class="el" href="namespaceSequence_1_1Recombination.html" title="Methods dealing with recombination. ">Recombination</a> Graph.  <a href="#ga1116020585e7246433b28c69b0623a20">More...</a><br/></td></tr>
<tr class="separator:ga1116020585e7246433b28c69b0623a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacd252657f1fdb3fe7d73fe23c468fd05"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator , typename poisson_generator &gt; </td></tr>
<tr class="memitem:gacd252657f1fdb3fe7d73fe23c468fd05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSequence_1_1SimData.html">Sequence::SimData</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gacd252657f1fdb3fe7d73fe23c468fd05">Sequence::neutral_sample</a> (uniform_generator &amp;uni, uniform01_generator &amp;uni01, exponential_generator &amp;expo, poisson_generator &amp;poiss, const double &amp;theta, const double &amp;rho, const int &amp;nsites, const int &amp;nsam, std::vector&lt; chromosome &gt; *sample, arg *sample_history, unsigned *max_chromosomes=NULL, const unsigned &amp;max_chromosomes_inc=0)</td></tr>
<tr class="memdesc:gacd252657f1fdb3fe7d73fe23c468fd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple function to generate samples under a neutral equilibrium model.  <a href="#gacd252657f1fdb3fe7d73fe23c468fd05">More...</a><br/></td></tr>
<tr class="separator:gacd252657f1fdb3fe7d73fe23c468fd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aaea2e8c8e79530e7b537d3ab26a510"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga7aaea2e8c8e79530e7b537d3ab26a510"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga7aaea2e8c8e79530e7b537d3ab26a510">Sequence::pick2_in_deme</a> (const uniform_generator &amp;uni, const std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">Sequence::chromosome</a> &gt; &amp;sample, const int &amp;current_nsam, const int &amp;deme_nsam, const int &amp;deme)</td></tr>
<tr class="memdesc:ga7aaea2e8c8e79530e7b537d3ab26a510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose two random chromosomes from the same deme.  <a href="#ga7aaea2e8c8e79530e7b537d3ab26a510">More...</a><br/></td></tr>
<tr class="separator:ga7aaea2e8c8e79530e7b537d3ab26a510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1da6ee3005af95c7da8538bbf31c3298"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga1da6ee3005af95c7da8538bbf31c3298"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga1da6ee3005af95c7da8538bbf31c3298">Sequence::pick2</a> (uniform_generator &amp;uni, const int &amp;nsam)</td></tr>
<tr class="separator:ga1da6ee3005af95c7da8538bbf31c3298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade136a93206ae5aa4adb3399a541d07e"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:gade136a93206ae5aa4adb3399a541d07e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gade136a93206ae5aa4adb3399a541d07e">Sequence::pick2</a> (const uniform_generator &amp;uni, const int &amp;nsam)</td></tr>
<tr class="separator:gade136a93206ae5aa4adb3399a541d07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3912c6722638e2f67d61caa4be52bcec"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </td></tr>
<tr class="memitem:ga3912c6722638e2f67d61caa4be52bcec"><td class="memTemplItemLeft" align="right" valign="top">arg&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga3912c6722638e2f67d61caa4be52bcec">Sequence::bottleneck</a> (uniform_generator &amp;uni, uniform01_generator &amp;uni01, exponential_generator &amp;expo, const std::vector&lt; chromosome &gt; &amp;initialized_sample, const marginal &amp;initialized_marginal, const double &amp;tr, const double &amp;d, const double &amp;f, const double &amp;rho, const bool &amp;exponential_recovery, const double &amp;recovered_size)</td></tr>
<tr class="memdesc:ga3912c6722638e2f67d61caa4be52bcec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coalescent simulation of a population bottleneck Simulate a single, bottlenecked, population according to the Wright-Fisher model without selection. The population can recover from the bottleneck either instantaneously ("stepwise bottleneck"), or according to an exponential growth model. For the case of a stepwise bottleneck, this function is equivalent to the following options in Dick Hudson's program "ms": -eN 0 recovered_size -eN tr f -eN (tr+d) 1. For the case where recovery from the bottleneck is by exponential growth, the equivalent "ms" options are: -eN 0 recovered_size -eG tr (log(recovered_size)-log(f))/d -eG (tr+d) 0 -eN (tr+d) 1.  <a href="#ga3912c6722638e2f67d61caa4be52bcec">More...</a><br/></td></tr>
<tr class="separator:ga3912c6722638e2f67d61caa4be52bcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f25f44e663e7af13a8981adb8d4898f"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </td></tr>
<tr class="memitem:ga1f25f44e663e7af13a8981adb8d4898f"><td class="memTemplItemLeft" align="right" valign="top">arg&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga1f25f44e663e7af13a8981adb8d4898f">Sequence::bottleneck</a> (const uniform_generator &amp;uni, const uniform01_generator &amp;uni01, const exponential_generator &amp;expo, const std::vector&lt; chromosome &gt; &amp;initialized_sample, const marginal &amp;initialized_marginal, const double &amp;tr, const double &amp;d, const double &amp;f, const double &amp;rho, const bool &amp;exponential_recovery, const double &amp;recovered_size)</td></tr>
<tr class="memdesc:ga1f25f44e663e7af13a8981adb8d4898f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coalescent simulation of a population bottleneck Simulate a single, bottlenecked, population according to the Wright-Fisher model without selection. The population can recover from the bottleneck either instantaneously ("stepwise bottleneck"), or according to an exponential growth model. For the case of a stepwise bottleneck, this function is equivalent to the following options in Dick Hudson's program "ms": -eN 0 recovered_size -eN tr f -eN (tr+d) 1. For the case where recovery from the bottleneck is by exponential growth, the equivalent "ms" options are: -eN 0 recovered_size -eG tr (log(recovered_size)-log(f))/d -eG (tr+d) 0 -eN (tr+d) 1.  <a href="#ga1f25f44e663e7af13a8981adb8d4898f">More...</a><br/></td></tr>
<tr class="separator:ga1f25f44e663e7af13a8981adb8d4898f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50a0f43f10ace15dc54a42f38ce598d8"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </td></tr>
<tr class="memitem:ga50a0f43f10ace15dc54a42f38ce598d8"><td class="memTemplItemLeft" align="right" valign="top">arg&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga50a0f43f10ace15dc54a42f38ce598d8">Sequence::exponential_change</a> (uniform_generator &amp;uni, uniform01_generator &amp;uni01, exponential_generator &amp;expo, const std::vector&lt; chromosome &gt; &amp;initialized_sample, const marginal &amp;initialized_marginal, const double &amp;G, const double &amp;t_begin, const double &amp;t_end, const double &amp;rho, const double &amp;size_at_end)</td></tr>
<tr class="memdesc:ga50a0f43f10ace15dc54a42f38ce598d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coalescent simulation of exponential change in population size Simulate a single population whose size changes exponentially during some period of time. The relevant command line options for Hudson's program "ms" would be: -eG t_begin G -eG t_end 0. -eN t_end size_at_end.  <a href="#ga50a0f43f10ace15dc54a42f38ce598d8">More...</a><br/></td></tr>
<tr class="separator:ga50a0f43f10ace15dc54a42f38ce598d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b46c1a1721fec3910aa1dda10a73ccd"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </td></tr>
<tr class="memitem:ga3b46c1a1721fec3910aa1dda10a73ccd"><td class="memTemplItemLeft" align="right" valign="top">arg&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga3b46c1a1721fec3910aa1dda10a73ccd">Sequence::exponential_change</a> (const uniform_generator &amp;uni, const uniform01_generator &amp;uni01, const exponential_generator &amp;expo, const std::vector&lt; chromosome &gt; &amp;initialized_sample, const marginal &amp;initialized_marginal, const double &amp;G, const double &amp;t_begin, const double &amp;t_end, const double &amp;rho, const double &amp;size_at_end)</td></tr>
<tr class="memdesc:ga3b46c1a1721fec3910aa1dda10a73ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coalescent simulation of exponential change in population size Simulate a single population whose size changes exponentially during some period of time. The relevant command line options for Hudson's program "ms" would be: -eG t_begin -eG t_end 0. -eN t_end size_at_end.  <a href="#ga3b46c1a1721fec3910aa1dda10a73ccd">More...</a><br/></td></tr>
<tr class="separator:ga3b46c1a1721fec3910aa1dda10a73ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0ebc12a347570625f4a5744b468fce"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga5a0ebc12a347570625f4a5744b468fce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga5a0ebc12a347570625f4a5744b468fce">Sequence::add_S_inf_sites</a> (uniform_generator &amp;uni, marginal::const_iterator history, const double &amp;tt, const int &amp;beg, const int &amp;end, const int &amp;nsam, const int &amp;nsites, const int &amp;S, const int &amp;first_snp_index, gamete_storage_type *gametes)</td></tr>
<tr class="memdesc:ga5a0ebc12a347570625f4a5744b468fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add S segregating sites to sample with a particular marginal history, according to the infinitely-many sites model.  <a href="#ga5a0ebc12a347570625f4a5744b468fce">More...</a><br/></td></tr>
<tr class="separator:ga5a0ebc12a347570625f4a5744b468fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa308491171a00098f4fd4ef0b289e864"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:gaa308491171a00098f4fd4ef0b289e864"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gaa308491171a00098f4fd4ef0b289e864">Sequence::add_S_inf_sites</a> (const uniform_generator &amp;uni, marginal::const_iterator history, const double &amp;tt, const int &amp;beg, const int &amp;end, const int &amp;nsam, const int &amp;nsites, const int &amp;S, const int &amp;first_snp_index, gamete_storage_type *gametes)</td></tr>
<tr class="memdesc:gaa308491171a00098f4fd4ef0b289e864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add S segregating sites to sample with a particular marginal history, according to the infinitely-many sites model.  <a href="#gaa308491171a00098f4fd4ef0b289e864">More...</a><br/></td></tr>
<tr class="separator:gaa308491171a00098f4fd4ef0b289e864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6380ab82353237eab66ee075d605356"><td class="memTemplParams" colspan="2">template&lt;typename poisson_generator , typename uniform_generator &gt; </td></tr>
<tr class="memitem:gac6380ab82353237eab66ee075d605356"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gac6380ab82353237eab66ee075d605356">Sequence::infinite_sites</a> (poisson_generator &amp;poiss, uniform_generator &amp;uni, gamete_storage_type *gametes, const int &amp;nsites, const arg &amp;history, const double &amp;theta)</td></tr>
<tr class="memdesc:gac6380ab82353237eab66ee075d605356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph.  <a href="#gac6380ab82353237eab66ee075d605356">More...</a><br/></td></tr>
<tr class="separator:gac6380ab82353237eab66ee075d605356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e16e642151c413353bae43c819524d4"><td class="memTemplParams" colspan="2">template&lt;typename poisson_generator , typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga7e16e642151c413353bae43c819524d4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga7e16e642151c413353bae43c819524d4">Sequence::infinite_sites</a> (const poisson_generator &amp;poiss, const uniform_generator &amp;uni, gamete_storage_type *gametes, const int &amp;nsites, const arg &amp;history, const double &amp;theta)</td></tr>
<tr class="memdesc:ga7e16e642151c413353bae43c819524d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph.  <a href="#ga7e16e642151c413353bae43c819524d4">More...</a><br/></td></tr>
<tr class="separator:ga7e16e642151c413353bae43c819524d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb4cc5187dfd09cfe2fe498a2a76c048"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:gadb4cc5187dfd09cfe2fe498a2a76c048"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gadb4cc5187dfd09cfe2fe498a2a76c048">Sequence::infinite_sites</a> (uniform_generator &amp;uni, gamete_storage_type *gametes, const int &amp;nsites, const arg &amp;history, const double *total_times, const unsigned *segsites)</td></tr>
<tr class="memdesc:gadb4cc5187dfd09cfe2fe498a2a76c048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites.  <a href="#gadb4cc5187dfd09cfe2fe498a2a76c048">More...</a><br/></td></tr>
<tr class="separator:gadb4cc5187dfd09cfe2fe498a2a76c048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3cda726603c5a1b2dc2af80eb170482"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:gac3cda726603c5a1b2dc2af80eb170482"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gac3cda726603c5a1b2dc2af80eb170482">Sequence::infinite_sites</a> (const uniform_generator &amp;uni, gamete_storage_type *gametes, const int &amp;nsites, const arg &amp;history, const double *total_times, const unsigned *segsites)</td></tr>
<tr class="memdesc:gac3cda726603c5a1b2dc2af80eb170482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites.  <a href="#gac3cda726603c5a1b2dc2af80eb170482">More...</a><br/></td></tr>
<tr class="separator:gac3cda726603c5a1b2dc2af80eb170482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65bfd963d90840b88f3b9c81e0598a59"><td class="memTemplParams" colspan="2">template&lt;typename poisson_generator , typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga65bfd963d90840b88f3b9c81e0598a59"><td class="memTemplItemLeft" align="right" valign="top">SimData&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga65bfd963d90840b88f3b9c81e0598a59">Sequence::infinite_sites_sim_data</a> (poisson_generator &amp;poiss, uniform_generator &amp;uni, const int &amp;nsites, const arg &amp;history, const double &amp;theta)</td></tr>
<tr class="memdesc:ga65bfd963d90840b88f3b9c81e0598a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph.  <a href="#ga65bfd963d90840b88f3b9c81e0598a59">More...</a><br/></td></tr>
<tr class="separator:ga65bfd963d90840b88f3b9c81e0598a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga924b35d3b4f42a1c29b6eda772bbe721"><td class="memTemplParams" colspan="2">template&lt;typename poisson_generator , typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga924b35d3b4f42a1c29b6eda772bbe721"><td class="memTemplItemLeft" align="right" valign="top">SimData&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga924b35d3b4f42a1c29b6eda772bbe721">Sequence::infinite_sites_sim_data</a> (const poisson_generator &amp;poiss, const uniform_generator &amp;uni, const int &amp;nsites, const arg &amp;history, const double &amp;theta)</td></tr>
<tr class="memdesc:ga924b35d3b4f42a1c29b6eda772bbe721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph.  <a href="#ga924b35d3b4f42a1c29b6eda772bbe721">More...</a><br/></td></tr>
<tr class="separator:ga924b35d3b4f42a1c29b6eda772bbe721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f9a208ce162baf2202a13529692affa"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga3f9a208ce162baf2202a13529692affa"><td class="memTemplItemLeft" align="right" valign="top">SimData&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga3f9a208ce162baf2202a13529692affa">Sequence::infinite_sites_sim_data</a> (uniform_generator &amp;uni, const int &amp;nsites, const arg &amp;history, const double *total_times, const unsigned *segsites)</td></tr>
<tr class="memdesc:ga3f9a208ce162baf2202a13529692affa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites.  <a href="#ga3f9a208ce162baf2202a13529692affa">More...</a><br/></td></tr>
<tr class="separator:ga3f9a208ce162baf2202a13529692affa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e8d72f6eccc423582cb403fef97dcab"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga2e8d72f6eccc423582cb403fef97dcab"><td class="memTemplItemLeft" align="right" valign="top">SimData&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga2e8d72f6eccc423582cb403fef97dcab">Sequence::infinite_sites_sim_data</a> (const uniform_generator &amp;uni, const int &amp;nsites, const arg &amp;history, const double *total_times, const unsigned *segsites)</td></tr>
<tr class="memdesc:ga2e8d72f6eccc423582cb403fef97dcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites.  <a href="#ga2e8d72f6eccc423582cb403fef97dcab">More...</a><br/></td></tr>
<tr class="separator:ga2e8d72f6eccc423582cb403fef97dcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadba4c228558e6c0c4b0b89cea7315c4d"><td class="memTemplParams" colspan="2">template&lt;typename uniform01_generator &gt; </td></tr>
<tr class="memitem:gadba4c228558e6c0c4b0b89cea7315c4d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gadba4c228558e6c0c4b0b89cea7315c4d">Sequence::pick_spot</a> (uniform01_generator &amp;uni01, const double &amp;total_reclen, const std::vector&lt; double &gt; &amp;reclens, std::vector&lt; chromosome &gt;::const_iterator sample_begin, const unsigned &amp;current_nsam, const double *rec_map)</td></tr>
<tr class="separator:gadba4c228558e6c0c4b0b89cea7315c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f690d4ac297fc6bd9583b735254547"><td class="memTemplParams" colspan="2">template&lt;typename uniform01_generator &gt; </td></tr>
<tr class="memitem:gab0f690d4ac297fc6bd9583b735254547"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gab0f690d4ac297fc6bd9583b735254547">Sequence::pick_spot</a> (const uniform01_generator &amp;uni01, const double &amp;total_reclen, const std::vector&lt; double &gt; &amp;reclens, std::vector&lt; chromosome &gt;::const_iterator sample_begin, const unsigned &amp;current_nsam, const double *rec_map)</td></tr>
<tr class="separator:gab0f690d4ac297fc6bd9583b735254547"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaaa678e49901c1ef90b470ec226ac8f71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa678e49901c1ef90b470ec226ac8f71"></a>
MAX_SEG_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gaaa678e49901c1ef90b470ec226ac8f71">Sequence::MAX_SEGSITES</a></td></tr>
<tr class="memdesc:gaaa678e49901c1ef90b470ec226ac8f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">controls allocation of simulated gametes You must define this in namespace Sequence in your program. A value of 200 works well. <br/></td></tr>
<tr class="separator:gaaa678e49901c1ef90b470ec226ac8f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa539fc37aaebc51fee7190755f49abb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa539fc37aaebc51fee7190755f49abb5"></a>
MAX_SEG_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gaa539fc37aaebc51fee7190755f49abb5">Sequence::MAX_SEGS_INC</a></td></tr>
<tr class="memdesc:gaa539fc37aaebc51fee7190755f49abb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">controls (re)allocation of simulated gametes You must define this in namespace Sequence in your program. A value of 100 works well <br/></td></tr>
<tr class="separator:gaa539fc37aaebc51fee7190755f49abb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga1116020585e7246433b28c69b0623a20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;marginal&gt; <a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">Sequence::arg</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ancestral <a class="el" href="namespaceSequence_1_1Recombination.html" title="Methods dealing with recombination. ">Recombination</a> Graph. </p>
<p>An arg is an "ancestral recombination graph", which is a linked list of marginal histories.</p>
<dl class="section note"><dt>Note</dt><dd>The implementation of the crossover function ensures that the marginal trees are sorted in ascending order determined by <a class="el" href="structSequence_1_1marginal.html#a30c13f35cdf216e4930c25669cf4a0b3">marginal::beg</a> </dd></dl>

<p>Definition at line <a class="el" href="SimTypes_8hpp_source.html#l00216">216</a> of file <a class="el" href="SimTypes_8hpp_source.html">SimTypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga48c093934ec4ec1c477415f86a2ffed3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt; std::vector&lt;double&gt;, std::vector&lt;std::string&gt; &gt; <a class="el" href="group__coalescent.html#ga48c093934ec4ec1c477415f86a2ffed3">Sequence::gamete_storage_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an object to store simulated gametes An object of this type will tend to exist in the calling environment of your program. If you are simulating a sample of n chromosomes, you would initialize the object as follows: </p>
<div class="fragment"><div class="line"><a class="code" href="group__coalescent.html#ga48c093934ec4ec1c477415f86a2ffed3">gamete_storage_type</a> gamete_bucket( std::vector&lt;double&gt;(<a class="code" href="group__coalescent.html#gaaa678e49901c1ef90b470ec226ac8f71">MAX_SEGSITES</a>,0.),</div>
<div class="line">std::vector&lt; std::string &gt;(n,std::string(<a class="code" href="group__coalescent.html#gaaa678e49901c1ef90b470ec226ac8f71">MAX_SEGSITES</a>,<span class="charliteral">&#39;0&#39;</span>)) );</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="Mutation_8hpp_source.html#l00041">41</a> of file <a class="el" href="Mutation_8hpp_source.html">Mutation.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5a0ebc12a347570625f4a5744b468fce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::add_S_inf_sites </td>
          <td>(</td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">marginal::const_iterator&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>first_snp_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_storage_type *&#160;</td>
          <td class="paramname"><em>gametes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add S segregating sites to sample with a particular marginal history, according to the infinitely-many sites model. </p>
<p>This routine places a fixed number of segregating sites on a marginal history that begins at position <em>beg</em> and ends at position <em>end-1</em>. Mutations are assigned positions randomly on the continuous, half-open interval [ beg/L,end/L ), where L = nsites-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as arguments </td></tr>
    <tr><td class="paramname">history</td><td>the history onto which mutations will be placed </td></tr>
    <tr><td class="paramname">tt</td><td>the total time on <em>history</em> </td></tr>
    <tr><td class="paramname">beg</td><td>the first site in the history (0 &lt;= beg &lt; nsites) </td></tr>
    <tr><td class="paramname">end</td><td>the last site in the history ( beg &lt; end &lt; nsites ) </td></tr>
    <tr><td class="paramname">nsam</td><td>the total sample size being simulated </td></tr>
    <tr><td class="paramname">nsites</td><td>the number of mutational sites simulated </td></tr>
    <tr><td class="paramname">S</td><td>the number of mutations to drop on <em>history</em> </td></tr>
    <tr><td class="paramname">first_snp_index</td><td>the index at which mutations will begin to be added into <em>gametes</em> </td></tr>
    <tr><td class="paramname">gametes</td><td>a container in which you are storing the mutations. Must be allocated in the calling environment. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00232">232</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="gaa308491171a00098f4fd4ef0b289e864"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::add_S_inf_sites </td>
          <td>(</td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">marginal::const_iterator&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>first_snp_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_storage_type *&#160;</td>
          <td class="paramname"><em>gametes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add S segregating sites to sample with a particular marginal history, according to the infinitely-many sites model. </p>
<p>This routine places a fixed number of segregating sites on a marginal history that begins at position <em>beg</em> and ends at position <em>end-1</em>. Mutations are assigned positions randomly on the continuous, half-open interval [ beg/L,end/L ), where L = nsites-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as arguments </td></tr>
    <tr><td class="paramname">history</td><td>the history onto which mutations will be placed </td></tr>
    <tr><td class="paramname">tt</td><td>the total time on <em>history</em> </td></tr>
    <tr><td class="paramname">beg</td><td>the first site in the history (0 &lt;= beg &lt; nsites) </td></tr>
    <tr><td class="paramname">end</td><td>the last site in the history ( beg &lt; end &lt; nsites ) </td></tr>
    <tr><td class="paramname">nsam</td><td>the total sample size being simulated </td></tr>
    <tr><td class="paramname">nsites</td><td>the number of mutational sites simulated </td></tr>
    <tr><td class="paramname">S</td><td>the number of mutations to drop on <em>history</em> </td></tr>
    <tr><td class="paramname">first_snp_index</td><td>the index at which mutations will begin to be added into <em>gametes</em> </td></tr>
    <tr><td class="paramname">gametes</td><td>a container in which you are storing the mutations. Must be allocated in the calling environment. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00268">268</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga3912c6722638e2f67d61caa4be52bcec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arg Sequence::bottleneck </td>
          <td>(</td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uniform01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exponential_generator &amp;&#160;</td>
          <td class="paramname"><em>expo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; chromosome &gt; &amp;&#160;</td>
          <td class="paramname"><em>initialized_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const marginal &amp;&#160;</td>
          <td class="paramname"><em>initialized_marginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>exponential_recovery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>recovered_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coalescent simulation of a population bottleneck Simulate a single, bottlenecked, population according to the Wright-Fisher model without selection. The population can recover from the bottleneck either instantaneously ("stepwise bottleneck"), or according to an exponential growth model. For the case of a stepwise bottleneck, this function is equivalent to the following options in Dick Hudson's program "ms": -eN 0 recovered_size -eN tr f -eN (tr+d) 1. For the case where recovery from the bottleneck is by exponential growth, the equivalent "ms" options are: -eN 0 recovered_size -eG tr (log(recovered_size)-log(f))/d -eG (tr+d) 0 -eN (tr+d) 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>A binary function object (or equivalent) that returns a random deviate between a and b such that a &lt;= x &lt; b. a and b are the arguments to operator() of <em>uni</em> </td></tr>
    <tr><td class="paramname">uni01</td><td>A function object (or equivalent) whose operator() takes no arguments and returns a random deviate 0 &lt;= x &lt; 1. </td></tr>
    <tr><td class="paramname">expo</td><td>A unary function object whose operator() takes the mean of an exponential process as an argument and returns a deviate from an exponential distribution with that mean </td></tr>
    <tr><td class="paramname">initialized_sample</td><td>An initialized vector of chromosomes for a single population. For example, this may be the return value of init_sample. This object is used to copy-construct a non-const sample for the simulation </td></tr>
    <tr><td class="paramname">initialized_marginal</td><td>An initialized marginal tree of the appropriate sample size for the simulation. For example, the return value of init_marginal. </td></tr>
    <tr><td class="paramname">tr</td><td>The time at which the population recovers from the bottleneck. In units of 4N0 generations, where N0 is the effective size before the bottleneck. </td></tr>
    <tr><td class="paramname">d</td><td>The duration of the bottleneck, in units of 4N0 generations, where N0 is the effective size before the bottleneck. </td></tr>
    <tr><td class="paramname">f</td><td>Bottleneck severity. Define Nb as the effective size during the bottleneck, and N0 the effective size prior to the bottleneck. f=Nb/N0. </td></tr>
    <tr><td class="paramname">rho</td><td>The population recombination rate 4N0r. The number of "sites" simulated is not neccesary, as it can be obtained from initialized_sample[0].last()+1. </td></tr>
    <tr><td class="paramname">exponential_recovery</td><td>If true, the population recovers from the bottleneck according to an exponential growth model. If false, a stepwise bottleneck is assumed. </td></tr>
    <tr><td class="paramname">recovered_size</td><td>If 1, the population recovers to N0 at time <em>tr</em>. If 0.5, the population recovers to 1/2 the pre-bottleneck size, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ancestral recombination graph (arg) describing the sample history. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>d&gt;0 and tr&gt;0 and f&gt;0 and rho&gt;=0 and recovered_size&gt;0 and initialized_marginal.nsam == initialized_sample.size() </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Preconditions are checked by the assert macro, and are therefore disabled when compiling with -DNDEBUG. No checks or warnings are otherwised performed nor given. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="bottleneck_8cc-example.html#a1">bottleneck.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="DemographicModels_8tcc_source.html#l00227">227</a> of file <a class="el" href="DemographicModels_8tcc_source.html">DemographicModels.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f25f44e663e7af13a8981adb8d4898f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arg Sequence::bottleneck </td>
          <td>(</td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uniform01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const exponential_generator &amp;&#160;</td>
          <td class="paramname"><em>expo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; chromosome &gt; &amp;&#160;</td>
          <td class="paramname"><em>initialized_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const marginal &amp;&#160;</td>
          <td class="paramname"><em>initialized_marginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>exponential_recovery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>recovered_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coalescent simulation of a population bottleneck Simulate a single, bottlenecked, population according to the Wright-Fisher model without selection. The population can recover from the bottleneck either instantaneously ("stepwise bottleneck"), or according to an exponential growth model. For the case of a stepwise bottleneck, this function is equivalent to the following options in Dick Hudson's program "ms": -eN 0 recovered_size -eN tr f -eN (tr+d) 1. For the case where recovery from the bottleneck is by exponential growth, the equivalent "ms" options are: -eN 0 recovered_size -eG tr (log(recovered_size)-log(f))/d -eG (tr+d) 0 -eN (tr+d) 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>A binary function object (or equivalent) that returns a random deviate between a and b such that a &lt;= x &lt; b. a and b are the arguments to operator() of <em>uni</em> </td></tr>
    <tr><td class="paramname">uni01</td><td>A function object (or equivalent) whose operator() takes no arguments and returns a random deviate 0 &lt;= x &lt; 1. </td></tr>
    <tr><td class="paramname">expo</td><td>A unary function object whose operator() takes the mean of an exponential process as an argument and returns a deviate from an exponential distribution with that mean </td></tr>
    <tr><td class="paramname">initialized_sample</td><td>An initialized vector of chromosomes for a single population. For example, this may be the return value of init_sample. This object is used to copy-construct a non-const sample for the simulation </td></tr>
    <tr><td class="paramname">initialized_marginal</td><td>An initialized marginal tree of the appropriate sample size for the simulation. For example, the return value of init_marginal. </td></tr>
    <tr><td class="paramname">tr</td><td>The time at which the population recovers from the bottleneck. In units of 4N0 generations, where N0 is the effective size before the bottleneck. </td></tr>
    <tr><td class="paramname">d</td><td>The duration of the bottleneck, in units of 4N0 generations, where N0 is the effective size before the bottleneck. </td></tr>
    <tr><td class="paramname">f</td><td>Bottleneck severity. Define Nb as the effective size during the bottleneck, and N0 the effective size prior to the bottleneck. f=Nb/N0. </td></tr>
    <tr><td class="paramname">rho</td><td>The population recombination rate 4N0r. The number of "sites" simulated is not neccesary, as it can be obtained from initialized_sample[0].last()+1. </td></tr>
    <tr><td class="paramname">exponential_recovery</td><td>If true, the population recovers from the bottleneck according to an exponential growth model. If false, a stepwise bottleneck is assumed. </td></tr>
    <tr><td class="paramname">recovered_size</td><td>If 1, the population recovers to N0 at time <em>tr</em>. If 0.5, the population recovers to 1/2 the pre-bottleneck size, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ancestral recombination graph (arg) describing the sample history. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>d&gt;0 and tr&gt;0 and f&gt;0 and rho&gt;=0 and recovered_size&gt;0 and initialized_marginal.nsam == initialized_sample.size() </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Preconditions are checked by the assert macro, and are therefore disabled when compiling with -DNDEBUG. No checks or warnings are otherwised performed nor given. </dd></dl>

<p>Definition at line <a class="el" href="DemographicModels_8tcc_source.html#l00264">264</a> of file <a class="el" href="DemographicModels_8tcc_source.html">DemographicModels.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga50a0f43f10ace15dc54a42f38ce598d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arg Sequence::exponential_change </td>
          <td>(</td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uniform01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exponential_generator &amp;&#160;</td>
          <td class="paramname"><em>expo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; chromosome &gt; &amp;&#160;</td>
          <td class="paramname"><em>initialized_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const marginal &amp;&#160;</td>
          <td class="paramname"><em>initialized_marginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>t_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>t_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>size_at_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coalescent simulation of exponential change in population size Simulate a single population whose size changes exponentially during some period of time. The relevant command line options for Hudson's program "ms" would be: -eG t_begin G -eG t_end 0. -eN t_end size_at_end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>A binary function object (or equivalent) that returns a random deviate between a and b such that a &lt;= x &lt; b. a and b are the arguments to operator() of <em>uni</em> </td></tr>
    <tr><td class="paramname">uni01</td><td>A function object (or equivalent) whose operator() takes no arguments and returns a random deviate 0 &lt;= x &lt; 1. </td></tr>
    <tr><td class="paramname">expo</td><td>A unary function object whose operator() takes the mean of an exponential process as an argument and returns a deviate from an exponential distribution with that mean </td></tr>
    <tr><td class="paramname">initialized_sample</td><td>An initialized vector of chromosomes for a single population. For example, this may be the return value of init_sample. This object is used to copy-construct a non-const sample for the simulation </td></tr>
    <tr><td class="paramname">initialized_marginal</td><td>An initialized marginal tree of the appropriate sample size for the simulation. For example, the return value of init_marginal. </td></tr>
    <tr><td class="paramname">G</td><td>The rate of exponential change in effective size. If G&gt;0, the population grows exponentially (forwards in time). If G&lt;0, it shrinks (again, forwards in time). </td></tr>
    <tr><td class="paramname">t_begin</td><td>The time in the past (in units of 4Ne generations) at which population size change begins (i.e., ends, moving forward in time) </td></tr>
    <tr><td class="paramname">t_end</td><td>The time in the past (in units of 4Ne generations) at which populations size change ends (begins forward in time) </td></tr>
    <tr><td class="paramname">rho</td><td>The population recombination rate 4N0r. The number of "sites" simulated is not neccesary, as it can be obtained from initialized_sample[0].last()+1. </td></tr>
    <tr><td class="paramname">size_at_end</td><td>At time <em>t_end</em> in the past, the population size is set to <em>size_at_end</em>. If <em>size_at_end</em> = 1, the population is set to the same size that is was at t=0 (i.e. the beginning of the simulation). If <em>size_at_and</em> &lt; 0, the population size is not adjusted at <em>t_end</em>. In other words, it is left at whatever it grew or shrank to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ancestral recombination graph (arg) describing the sample history. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>t_begin&gt;=0 and t_end&gt;=0 and t_end&gt;=t_begin and rho&gt;=0 and initialized_marginal.nsam == initialized_sample.size() </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Preconditions are checked by the assert macro, and are therefore disabled when compiling with -DNDEBUG. No checks or warnings are otherwised performed nor given. </dd></dl>

<p>Definition at line <a class="el" href="DemographicModels_8tcc_source.html#l00301">301</a> of file <a class="el" href="DemographicModels_8tcc_source.html">DemographicModels.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b46c1a1721fec3910aa1dda10a73ccd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arg Sequence::exponential_change </td>
          <td>(</td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uniform01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const exponential_generator &amp;&#160;</td>
          <td class="paramname"><em>expo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; chromosome &gt; &amp;&#160;</td>
          <td class="paramname"><em>initialized_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const marginal &amp;&#160;</td>
          <td class="paramname"><em>initialized_marginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>t_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>t_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>size_at_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coalescent simulation of exponential change in population size Simulate a single population whose size changes exponentially during some period of time. The relevant command line options for Hudson's program "ms" would be: -eG t_begin -eG t_end 0. -eN t_end size_at_end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>A binary function object (or equivalent) that returns a random deviate between a and b such that a &lt;= x &lt; b. a and b are the arguments to operator() of <em>uni</em> </td></tr>
    <tr><td class="paramname">uni01</td><td>A function object (or equivalent) whose operator() takes no arguments and returns a random deviate 0 &lt;= x &lt; 1. </td></tr>
    <tr><td class="paramname">expo</td><td>A unary function object whose operator() takes the mean of an exponential process as an argument and returns a deviate from an exponential distribution with that mean </td></tr>
    <tr><td class="paramname">initialized_sample</td><td>An initialized vector of chromosomes for a single population. For example, this may be the return value of init_sample. This object is used to copy-construct a non-const sample for the simulation </td></tr>
    <tr><td class="paramname">initialized_marginal</td><td>An initialized marginal tree of the appropriate sample size for the simulation. For example, the return value of init_marginal. </td></tr>
    <tr><td class="paramname">G</td><td>The rate of exponential change in effective size. If G&gt;0, the population grows exponentially (forwards in time). If G&lt;0, it shrinks (again, forwards in time). </td></tr>
    <tr><td class="paramname">t_begin</td><td>The time in the past (in units of 4Ne generations) at which population size change begins (i.e., ends, moving forward in time) </td></tr>
    <tr><td class="paramname">t_end</td><td>The time in the past (in units of 4Ne generations) at which populations size change ends (begins forward in time) </td></tr>
    <tr><td class="paramname">rho</td><td>The population recombination rate 4N0r. The number of "sites" simulated is not neccesary, as it can be obtained from initialized_sample[0].last()+1. </td></tr>
    <tr><td class="paramname">size_at_end</td><td>At time <em>t_end</em> in the past, the population size is set to <em>size_at_end</em>. If <em>size_at_end</em> = 1, the population is set to the same size that is was at t=0 (i.e. the beginning of the simulation). If <em>size_at_and</em> &lt; 0, the population size is not adjusted at <em>t_end</em>. In other words, it is left at whatever it grew or shrank to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ancestral recombination graph (arg) describing the sample history. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>t_begin&gt;=0 and t_end&gt;=0 and t_end&gt;=t_begin and rho&gt;=0 and initialized_marginal.nsam == initialized_sample.size() </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Preconditions are checked by the assert macro, and are therefore disabled when compiling with -DNDEBUG. No checks or warnings are otherwised performed nor given. </dd></dl>

<p>Definition at line <a class="el" href="DemographicModels_8tcc_source.html#l00337">337</a> of file <a class="el" href="DemographicModels_8tcc_source.html">DemographicModels.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="gac6380ab82353237eab66ee075d605356"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename poisson_generator , typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::infinite_sites </td>
          <td>(</td>
          <td class="paramtype">poisson_generator &amp;&#160;</td>
          <td class="paramname"><em>poiss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_storage_type *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the infinitely-many sites mutation model to an ancetral recombination graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poiss</td><td>a Poisson random number generator which takes the mean of the poisson as an argument </td></tr>
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as an argument </td></tr>
    <tr><td class="paramname">gametes</td><td>object in which to store the simulated gametes </td></tr>
    <tr><td class="paramname">nsites</td><td>the length of the region begin simulated </td></tr>
    <tr><td class="paramname">history</td><td>the list of marginal histories for the sample </td></tr>
    <tr><td class="paramname">theta</td><td>the coalescent-scaled mutation rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of mutations placed on the tree </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="freerec_8cc-example.html#a6">freerec.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00305">305</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga7e16e642151c413353bae43c819524d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename poisson_generator , typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::infinite_sites </td>
          <td>(</td>
          <td class="paramtype">const poisson_generator &amp;&#160;</td>
          <td class="paramname"><em>poiss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_storage_type *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the infinitely-many sites mutation model to an ancetral recombination graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poiss</td><td>a Poisson random number generator which takes the mean of the poisson as an argument </td></tr>
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as an argument </td></tr>
    <tr><td class="paramname">gametes</td><td>object in which to store the simulated gametes </td></tr>
    <tr><td class="paramname">nsites</td><td>the length of the region begin simulated </td></tr>
    <tr><td class="paramname">history</td><td>the list of marginal histories for the sample </td></tr>
    <tr><td class="paramname">theta</td><td>the coalescent-scaled mutation rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of mutations placed on the tree </dd></dl>

<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00328">328</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="gadb4cc5187dfd09cfe2fe498a2a76c048"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::infinite_sites </td>
          <td>(</td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_storage_type *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>total_times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>segsites</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as an argument </td></tr>
    <tr><td class="paramname">gametes</td><td>object in which to store the simulated gametes </td></tr>
    <tr><td class="paramname">nsites</td><td>the length of the region begin simulated </td></tr>
    <tr><td class="paramname">history</td><td>the list of marginal histories for the sample </td></tr>
    <tr><td class="paramname">total_times</td><td>the total times on each marginal tree in <em>history</em> </td></tr>
    <tr><td class="paramname">segsites</td><td>the number of segregating sites to place on each tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of mutations placed on the tree </dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>total_times</em> and <em>segsites</em> must contain a number of elements equal to history.size() </dd></dl>

<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00350">350</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="gac3cda726603c5a1b2dc2af80eb170482"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::infinite_sites </td>
          <td>(</td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_storage_type *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>total_times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>segsites</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as an argument </td></tr>
    <tr><td class="paramname">gametes</td><td>object in which to store the simulated gametes </td></tr>
    <tr><td class="paramname">nsites</td><td>the length of the region begin simulated </td></tr>
    <tr><td class="paramname">history</td><td>the list of marginal histories for the sample </td></tr>
    <tr><td class="paramname">total_times</td><td>the total times on each marginal tree in <em>history</em> </td></tr>
    <tr><td class="paramname">segsites</td><td>the number of segregating sites to place on each tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of mutations placed on the tree </dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>total_times</em> and <em>segsites</em> must contain a number of elements equal to history.size() </dd></dl>

<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00374">374</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga65bfd963d90840b88f3b9c81e0598a59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename poisson_generator , typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SimData Sequence::infinite_sites_sim_data </td>
          <td>(</td>
          <td class="paramtype">poisson_generator &amp;&#160;</td>
          <td class="paramname"><em>poiss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the infinitely-many sites mutation model to an ancetral recombination graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poiss</td><td>a Poisson random number generator which takes the mean of the poisson as an argument </td></tr>
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as an argument </td></tr>
    <tr><td class="paramname">nsites</td><td>the length of the region begin simulated </td></tr>
    <tr><td class="paramname">history</td><td>the list of marginal histories for the sample </td></tr>
    <tr><td class="paramname">theta</td><td>the coalescent-scaled mutation rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object of type <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> that represent the sample. (the gametes are also stored in <em>gametes</em>). The <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> object can be passed directly into class <a class="el" href="classSequence_1_1PolySIM.html" title="Analysis of coalescent simulation data. ">PolySIM</a> for analysis </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="bottleneck_8cc-example.html#a4">bottleneck.cc</a>, and <a class="el" href="fragments_8cc-example.html#a5">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00399">399</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga924b35d3b4f42a1c29b6eda772bbe721"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename poisson_generator , typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SimData Sequence::infinite_sites_sim_data </td>
          <td>(</td>
          <td class="paramtype">const poisson_generator &amp;&#160;</td>
          <td class="paramname"><em>poiss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the infinitely-many sites mutation model to an ancetral recombination graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poiss</td><td>a Poisson random number generator which takes the mean of the poisson as an argument </td></tr>
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as an argument </td></tr>
    <tr><td class="paramname">nsites</td><td>the length of the region begin simulated </td></tr>
    <tr><td class="paramname">history</td><td>the list of marginal histories for the sample </td></tr>
    <tr><td class="paramname">theta</td><td>the coalescent-scaled mutation rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object of type <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> that represent the sample. (the gametes are also stored in <em>gametes</em>). The <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> object can be passed directly into class <a class="el" href="classSequence_1_1PolySIM.html" title="Analysis of coalescent simulation data. ">PolySIM</a> for analysis </dd></dl>

<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00422">422</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga3f9a208ce162baf2202a13529692affa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SimData Sequence::infinite_sites_sim_data </td>
          <td>(</td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>total_times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>segsites</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as an argument </td></tr>
    <tr><td class="paramname">nsites</td><td>the length of the region begin simulated </td></tr>
    <tr><td class="paramname">history</td><td>the list of marginal histories for the sample </td></tr>
    <tr><td class="paramname">total_times</td><td>the total times on each marginal tree in <em>history</em> </td></tr>
    <tr><td class="paramname">segsites</td><td>the number of segregating sites to place on each tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object of type <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> that represent the sample. for analysis </dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>total_times</em> and <em>segsites</em> must contain a number of elements equal to history.size() </dd></dl>

<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00444">444</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga2e8d72f6eccc423582cb403fef97dcab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SimData Sequence::infinite_sites_sim_data </td>
          <td>(</td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>total_times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>segsites</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as an argument </td></tr>
    <tr><td class="paramname">nsites</td><td>the length of the region begin simulated </td></tr>
    <tr><td class="paramname">history</td><td>the list of marginal histories for the sample </td></tr>
    <tr><td class="paramname">total_times</td><td>the total times on each marginal tree in <em>history</em> </td></tr>
    <tr><td class="paramname">segsites</td><td>the number of segregating sites to place on each tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object of type <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> that represent the sample. for analysis </dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>total_times</em> and <em>segsites</em> must contain a number of elements equal to history.size() </dd></dl>

<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00467">467</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="gacd252657f1fdb3fe7d73fe23c468fd05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator , typename poisson_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSequence_1_1SimData.html">Sequence::SimData</a> Sequence::neutral_sample </td>
          <td>(</td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uniform01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exponential_generator &amp;&#160;</td>
          <td class="paramname"><em>expo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">poisson_generator &amp;&#160;</td>
          <td class="paramname"><em>poiss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; chromosome &gt; *&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arg *&#160;</td>
          <td class="paramname"><em>sample_history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>max_chromosomes</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>max_chromosomes_inc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple function to generate samples under a neutral equilibrium model. </p>
<p>A simple function to generate samples under a neutral equilibrium model with infinite-sites mutation and a constant recombination rate accross the region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a function/object capable of returning a random double uniformly from [0,k) </td></tr>
    <tr><td class="paramname">uni01</td><td>a function/object capable of returning a random probability uniformly from [0,1) </td></tr>
    <tr><td class="paramname">expo</td><td>a function/object capable of returning an exponentially distributed random variable. The function must take a single double as an argument, which is the mean of the exponential distribution </td></tr>
    <tr><td class="paramname">poiss</td><td>a function/object capable of returning an poisson distributed random variable. The function must take a single double as an argument, which is the mean of the poisson distribution </td></tr>
    <tr><td class="paramname">theta</td><td>4Nu, the coalescent-scaled mutation rate </td></tr>
    <tr><td class="paramname">rho</td><td>4Nr, the recombination rate for the whole region </td></tr>
    <tr><td class="paramname">nsites</td><td>the number of mutational sites to simulate. <a class="el" href="namespaceSequence_1_1Recombination.html" title="Methods dealing with recombination. ">Recombination</a> is equally likely between any two sites. </td></tr>
    <tr><td class="paramname">nsites</td><td>the total sample size. (There is no population structure in this routine) </td></tr>
    <tr><td class="paramname">sample</td><td>A pointer to the sample of chromosomes you wish to simulate. This must be properly initialized, for example using the function init_sample in &lt;<a class="el" href="Initialize_8hpp_source.html">Sequence/Coalescent/Initialize.hpp</a>&gt; </td></tr>
    <tr><td class="paramname">sample_history</td><td>a pointer to the ancestral recombination graph. This must be initialized in the calling enviroment. In general, you can use init_marginal in &lt;<a class="el" href="Initialize_8hpp_source.html">Sequence/Coalescent/Initialize.hpp</a>&gt; </td></tr>
    <tr><td class="paramname">max_chromosomes</td><td>This is a pointer to an integer in the calling environment which you can use to reserve memory in the array containing the sample of chromosomes. If the size of <em>sample</em> ever gets larger than this, max_chromosomes is incremented by <em>max_chromosomes_inc</em> </td></tr>
    <tr><td class="paramname">max_chromosomes_inc</td><td>the amount by which to increment <em>max_chromosomes</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does require a bit of work to use, although not much. Please see the example code that comes with the library, in particular ms&ndash;.cc </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ms--_8cc-example.html#a5">ms--.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="NeutralSample_8hpp_source.html#l00016">16</a> of file <a class="el" href="NeutralSample_8hpp_source.html">NeutralSample.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga1da6ee3005af95c7da8538bbf31c3298"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; Sequence::pick2 </td>
          <td>(</td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a random number function/object capable of returning a double-precision random number between 0 and <em>nsam-1</em> </td></tr>
    <tr><td class="paramname">nsam</td><td>the current sample size in the simulation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of integers which contains the indexes of two chromosomes in <em>sample</em> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a2">fragments.cc</a>, and <a class="el" href="freerec_8cc-example.html#a5">freerec.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="Coalesce_8tcc_source.html#l00090">90</a> of file <a class="el" href="Coalesce_8tcc_source.html">Coalesce.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="gade136a93206ae5aa4adb3399a541d07e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; Sequence::pick2 </td>
          <td>(</td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a random number function/object capable of returning a double-precision random number between 0 and <em>nsam-1</em> </td></tr>
    <tr><td class="paramname">nsam</td><td>the current sample size in the simulation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of integers which contains the indexes of two chromosomes in <em>sample</em> </dd></dl>

<p>Definition at line <a class="el" href="Coalesce_8tcc_source.html#l00103">103</a> of file <a class="el" href="Coalesce_8tcc_source.html">Coalesce.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga7aaea2e8c8e79530e7b537d3ab26a510"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; Sequence::pick2_in_deme </td>
          <td>(</td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structSequence_1_1chromosome.html">Sequence::chromosome</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>current_nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>deme_nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>deme</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose two random chromosomes from the same deme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>A random number generator taking two arguments, a and b, and returning a random variable distributed uniformly over [a,b) </td></tr>
    <tr><td class="paramname">sample</td><td>The current state of the simulated sample </td></tr>
    <tr><td class="paramname">current_nsam</td><td>The total sample size being simuled (the sum of sample sizes over all demes) </td></tr>
    <tr><td class="paramname">deme_nsam</td><td>The sample size of the deme from which you wish to sample </td></tr>
    <tr><td class="paramname">deme</td><td>The index ( 0 &lt;= deme &lt; # populations ) of the deme from which you wish to sample </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of integers which contains the indexes of two chromosomes in <em>sample</em> </dd></dl>

<p>Definition at line <a class="el" href="Coalesce_8tcc_source.html#l00069">69</a> of file <a class="el" href="Coalesce_8tcc_source.html">Coalesce.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="gadba4c228558e6c0c4b0b89cea7315c4d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform01_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; Sequence::pick_spot </td>
          <td>(</td>
          <td class="paramtype">uniform01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>total_reclen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>reclens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; chromosome &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>sample_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>current_nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rec_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Picks a positions amongst all chromosomes at which a recombination event will occur, based on an arbitrary genetic map </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni01</td><td>a function/object which takes no arguments and can return a U[0,1) </td></tr>
    <tr><td class="paramname">total_reclen</td><td>the total recombination length of all chromosomes in the sample </td></tr>
    <tr><td class="paramname">reclens</td><td>a vector of the proportion of <em>total_reclen</em> contributed by each chromosome. This needs to be ordered in the same order as <em>sample_begin</em> to (<em>sample_begin</em> + <em>current_nsam</em> - 1) </td></tr>
    <tr><td class="paramname">sample_begin</td><td>an iterator pointing to the beginning of the sample </td></tr>
    <tr><td class="paramname">current_nsam</td><td>the current sample size in the simulation </td></tr>
    <tr><td class="paramname">rec_map</td><td>an array of probabilities describing the recombination map. The map is completely up to the programmer, and it is not checked for sanity at all in this function. For a region of k sites, indexes 0 to k-2 of this array should be filled. The i-th element should contain the probability that a crossover occurs between position i and i+1. The sum of all elements should be 1, such that the array describes the recombination map in terms of a probability distribution function. An example of how to do this is in the file examples/msbeta.cc that comes with the source for this library. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of integers containing the index of the recombinant chromosome (.first), and the position at which the crossover will occur (.second) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a3">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="Recombination_8tcc_source.html#l00054">54</a> of file <a class="el" href="Recombination_8tcc_source.html">Recombination.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="gab0f690d4ac297fc6bd9583b735254547"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform01_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; Sequence::pick_spot </td>
          <td>(</td>
          <td class="paramtype">const uniform01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>total_reclen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>reclens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; chromosome &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>sample_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>current_nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rec_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Picks a positions amongst all chromosomes at which a recombination event will occur, based on an arbitrary genetic map </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni01</td><td>a function/object which takes no arguments and can return a U[0,1) </td></tr>
    <tr><td class="paramname">total_reclen</td><td>the total recombination length of all chromosomes in the sample </td></tr>
    <tr><td class="paramname">reclens</td><td>a vector of the proportion of <em>total_reclen</em> contributed by each chromosome. This needs to be ordered in the same order as <em>sample_begin</em> to (<em>sample_begin</em> + <em>current_nsam</em> - 1) </td></tr>
    <tr><td class="paramname">sample_begin</td><td>an iterator pointing to the beginning of the sample </td></tr>
    <tr><td class="paramname">current_nsam</td><td>the current sample size in the simulation </td></tr>
    <tr><td class="paramname">rec_map</td><td>an array of probabilities describing the recombination map. The map is completely up to the programmer, and it is not checked for sanity at all in this function. For a region of k sites, indexes 0 to k-2 of this array should be filled. The i-th element should contain the probability that a crossover occurs between position i and i+1. The sum of all elements should be 1, such that the array describes the recombination map in terms of a probability distribution function. An example of how to do this is in the file examples/msbeta.cc that comes with the source for this library. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of integers containing the index of the recombinant chromosome (.first), and the position at which the crossover will occur (.second) </dd></dl>

<p>Definition at line <a class="el" href="Recombination_8tcc_source.html#l00084">84</a> of file <a class="el" href="Recombination_8tcc_source.html">Recombination.tcc</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Dec 3 2014 17:45:51 for libsequence by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
