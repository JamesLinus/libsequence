<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>libsequence: Classes and functions related to simulating data under coalescent models</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsequence
   &#160;<span id="projectnumber">1.8.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__coalescent.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Classes and functions related to simulating data under coalescent models<div class="ingroups"><a class="el" href="group__popgen.html">Molecular Population Genetics</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1segment.html">Sequence::segment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A portion of a recombining chromosome.  <a href="structSequence_1_1segment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1chromosome.html">Sequence::chromosome</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A chromosome is a container of segments.  <a href="structSequence_1_1chromosome.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1node.html">Sequence::node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point on a marginal tree at which a coalescent event occurs.  <a href="structSequence_1_1node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1marginal.html">Sequence::marginal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The genealogy of a portion of a chromosome on which no recombination has occurred.  <a href="structSequence_1_1marginal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1newick__stream__marginal__tree.html">Sequence::newick_stream_marginal_tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides a typecast-on-output of a marginal tree to a newick tree Example use:  <a href="classSequence_1_1newick__stream__marginal__tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1SimData.html">Sequence::SimData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data from coalescent simulations.  <a href="classSequence_1_1SimData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1SimParams.html">Sequence::SimParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for Hudson's simulation program.  <a href="classSequence_1_1SimParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga48c093934ec4ec1c477415f86a2ffed3"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; std::vector<br class="typebreak" />
&lt; double &gt;, std::vector<br class="typebreak" />
&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga48c093934ec4ec1c477415f86a2ffed3">Sequence::gamete_storage_type</a></td></tr>
<tr class="memdesc:ga48c093934ec4ec1c477415f86a2ffed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">an object to store simulated gametes An object of this type will tend to exist in the calling environment of your program. If you are simulating a sample of n chromosomes, you would initialize the object as follows:  <a href="#ga48c093934ec4ec1c477415f86a2ffed3">More...</a><br /></td></tr>
<tr class="separator:ga48c093934ec4ec1c477415f86a2ffed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1116020585e7246433b28c69b0623a20"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; marginal &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">Sequence::arg</a></td></tr>
<tr class="memdesc:ga1116020585e7246433b28c69b0623a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ancestral <a class="el" href="namespaceSequence_1_1Recombination.html" title="Methods dealing with recombination. ">Recombination</a> Graph.  <a href="#ga1116020585e7246433b28c69b0623a20">More...</a><br /></td></tr>
<tr class="separator:ga1116020585e7246433b28c69b0623a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacd252657f1fdb3fe7d73fe23c468fd05"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator , typename poisson_generator &gt; </td></tr>
<tr class="memitem:gacd252657f1fdb3fe7d73fe23c468fd05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSequence_1_1SimData.html">Sequence::SimData</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gacd252657f1fdb3fe7d73fe23c468fd05">Sequence::neutral_sample</a> (uniform_generator &amp;uni, uniform01_generator &amp;uni01, exponential_generator &amp;expo, poisson_generator &amp;poiss, const double &amp;theta, const double &amp;rho, const int &amp;nsites, const int &amp;nsam, std::vector&lt; chromosome &gt; *sample, arg *sample_history, unsigned *max_chromosomes=NULL, const unsigned &amp;max_chromosomes_inc=0)</td></tr>
<tr class="memdesc:gacd252657f1fdb3fe7d73fe23c468fd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple function to generate samples under a neutral equilibrium model.  <a href="#gacd252657f1fdb3fe7d73fe23c468fd05">More...</a><br /></td></tr>
<tr class="separator:gacd252657f1fdb3fe7d73fe23c468fd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc67bf45f19257a18e6a05ccc472c433"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gadc67bf45f19257a18e6a05ccc472c433">Sequence::isseg</a> (chromosome::const_iterator seg, const unsigned &amp;nsegs, const int &amp;pos, unsigned *offset)</td></tr>
<tr class="memdesc:gadc67bf45f19257a18e6a05ccc472c433"><td class="mdescLeft">&#160;</td><td class="mdescRight">ask if a chromosome beginning at seg and containing nsegs contains a segment containing the position pos  <a href="#gadc67bf45f19257a18e6a05ccc472c433">More...</a><br /></td></tr>
<tr class="separator:gadc67bf45f19257a18e6a05ccc472c433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad689617c904bc44ec5fade5940273396"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gad689617c904bc44ec5fade5940273396">Sequence::coalesce</a> (const double &amp;time, const int &amp;ttl_nsam, const int &amp;current_nsam, const int &amp;c1, const int &amp;c2, const int &amp;nsites, int *nlinks, std::vector&lt; chromosome &gt; *sample, arg *sample_history)</td></tr>
<tr class="memdesc:gad689617c904bc44ec5fade5940273396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common ancestor routine for coalescent simulation. Merges chromosome segments and updates marginal trees.  <a href="#gad689617c904bc44ec5fade5940273396">More...</a><br /></td></tr>
<tr class="separator:gad689617c904bc44ec5fade5940273396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e686d875016adee17ea99e68d4eb127"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga1e686d875016adee17ea99e68d4eb127">Sequence::sample_length</a> (const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;fragments)</td></tr>
<tr class="memdesc:ga1e686d875016adee17ea99e68d4eb127"><td class="mdescLeft">&#160;</td><td class="mdescRight">When simulating partially linked regions, return the total length of sample material that we are simulating.  <a href="#ga1e686d875016adee17ea99e68d4eb127">More...</a><br /></td></tr>
<tr class="separator:ga1e686d875016adee17ea99e68d4eb127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad76215f50d491cee38ed10fdc9abeae2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gad76215f50d491cee38ed10fdc9abeae2">Sequence::total_length</a> (const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;fragments)</td></tr>
<tr class="memdesc:gad76215f50d491cee38ed10fdc9abeae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">When simulating partially linked regions, return the total length of the region.  <a href="#gad76215f50d491cee38ed10fdc9abeae2">More...</a><br /></td></tr>
<tr class="separator:gad76215f50d491cee38ed10fdc9abeae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6799b522bbd1873080aeb2107244172"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gaf6799b522bbd1873080aeb2107244172">Sequence::calculate_scales</a> (const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;fragments, std::vector&lt; std::pair&lt; double, double &gt; &gt; *sample_scale, std::vector&lt; std::pair&lt; double, double &gt; &gt; *mutation_scale)</td></tr>
<tr class="memdesc:gaf6799b522bbd1873080aeb2107244172"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function that rescales physical distance in base pairs to continuous distance on the interval 0,1.  <a href="#gaf6799b522bbd1873080aeb2107244172">More...</a><br /></td></tr>
<tr class="separator:gaf6799b522bbd1873080aeb2107244172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c22215ad956c74d797ee8aa31333afa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga0c22215ad956c74d797ee8aa31333afa">Sequence::rescale_mutation_positions</a> (SimData *d, const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;sample_scale, const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;mutation_scale)</td></tr>
<tr class="memdesc:ga0c22215ad956c74d797ee8aa31333afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescales the positions of the mutations in <em>d</em> from the scale given in <em>sample_scale</em> to that given in <em>mutation_scale</em>.  <a href="#ga0c22215ad956c74d797ee8aa31333afa">More...</a><br /></td></tr>
<tr class="separator:ga0c22215ad956c74d797ee8aa31333afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac593c97e75254030b0dc5b793603ebcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac593c97e75254030b0dc5b793603ebcd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gac593c97e75254030b0dc5b793603ebcd">Sequence::rescale_arg</a> (arg *sample_history, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;fragments)</td></tr>
<tr class="memdesc:gac593c97e75254030b0dc5b793603ebcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescales the beginnings of marginal trees in an ancestral recombination graph from a genetic scale to a physical scale. <br /></td></tr>
<tr class="separator:gac593c97e75254030b0dc5b793603ebcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac820614c0309bd7c2b8c613cb33c4ad5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gac820614c0309bd7c2b8c613cb33c4ad5">Sequence::integrate_genetic_map</a> (const std::vector&lt; chromosome &gt; &amp;sample, const int &amp;current_nsam, const std::vector&lt; double &gt; &amp;genetic_map, std::vector&lt; double &gt; *reclens)</td></tr>
<tr class="memdesc:gac820614c0309bd7c2b8c613cb33c4ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">When simulating non-uniform recombination rates, the probability of recombination at each point in the simulation needs to be obtained by integrating over the genetic map and the current sample configuration. This function does that.  <a href="#gac820614c0309bd7c2b8c613cb33c4ad5">More...</a><br /></td></tr>
<tr class="separator:gac820614c0309bd7c2b8c613cb33c4ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef587d0dd2c9f5fc9725cea9c166f73a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; chromosome &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gaef587d0dd2c9f5fc9725cea9c166f73a">Sequence::init_sample</a> (const std::vector&lt; int &gt; &amp;pop_config, const int &amp;nsites)</td></tr>
<tr class="memdesc:gaef587d0dd2c9f5fc9725cea9c166f73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple function to initialize a sample of chromosomes.  <a href="#gaef587d0dd2c9f5fc9725cea9c166f73a">More...</a><br /></td></tr>
<tr class="separator:gaef587d0dd2c9f5fc9725cea9c166f73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e3a9fa77284d9751ba6fb025c4d218f"><td class="memItemLeft" align="right" valign="top">marginal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga6e3a9fa77284d9751ba6fb025c4d218f">Sequence::init_marginal</a> (const int &amp;nsam)</td></tr>
<tr class="memdesc:ga6e3a9fa77284d9751ba6fb025c4d218f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple function to initialize a marginal tree.  <a href="#ga6e3a9fa77284d9751ba6fb025c4d218f">More...</a><br /></td></tr>
<tr class="separator:ga6e3a9fa77284d9751ba6fb025c4d218f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3697a3a402b2395fafc6dc2548721a1c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga3697a3a402b2395fafc6dc2548721a1c">Sequence::pick_uniform_spot</a> (const double &amp;random_01, const int &amp;nlinks, std::vector&lt; chromosome &gt;::const_iterator sample_begin, const unsigned &amp;current_nsam)</td></tr>
<tr class="memdesc:ga3697a3a402b2395fafc6dc2548721a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pick a crossover point for the model where recombination rates are constant across a recion. Picks a positions uniformly amongst all chromosomes at which a recombination event will occur.  <a href="#ga3697a3a402b2395fafc6dc2548721a1c">More...</a><br /></td></tr>
<tr class="separator:ga3697a3a402b2395fafc6dc2548721a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe0abcf7a1656a19ad282f44822d7b73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gafe0abcf7a1656a19ad282f44822d7b73">Sequence::crossover</a> (const int &amp;current_nsam, const int &amp;chromo, const int &amp;pos, std::vector&lt; chromosome &gt; *sample, arg *sample_history)</td></tr>
<tr class="memdesc:gafe0abcf7a1656a19ad282f44822d7b73"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSequence_1_1Recombination.html" title="Methods dealing with recombination. ">Recombination</a> function.  <a href="#gafe0abcf7a1656a19ad282f44822d7b73">More...</a><br /></td></tr>
<tr class="separator:gafe0abcf7a1656a19ad282f44822d7b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9f77f12a1707c21f20badb8b92b1d20"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gae9f77f12a1707c21f20badb8b92b1d20">Sequence::total_time</a> (const marginal::const_iterator beg, const int &amp;nsam)</td></tr>
<tr class="memdesc:gae9f77f12a1707c21f20badb8b92b1d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate total time on a marginal tree.  <a href="#gae9f77f12a1707c21f20badb8b92b1d20">More...</a><br /></td></tr>
<tr class="separator:gae9f77f12a1707c21f20badb8b92b1d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ae894594d083945cf2280d7b47797cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga1ae894594d083945cf2280d7b47797cd">Sequence::pick_branch</a> (marginal::const_iterator beg, const int &amp;nsam, const double &amp;rtime)</td></tr>
<tr class="memdesc:ga1ae894594d083945cf2280d7b47797cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">pick a random branch of a marginal tree  <a href="#ga1ae894594d083945cf2280d7b47797cd">More...</a><br /></td></tr>
<tr class="separator:ga1ae894594d083945cf2280d7b47797cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64568b80b98d2db6f3bbb89620beda36"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga64568b80b98d2db6f3bbb89620beda36">Sequence::get_all_descendants</a> (marginal::const_iterator beg, const int &amp;nsam, const int &amp;branch)</td></tr>
<tr class="memdesc:ga64568b80b98d2db6f3bbb89620beda36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the descendants of a branch on a marginal tree.  <a href="#ga64568b80b98d2db6f3bbb89620beda36">More...</a><br /></td></tr>
<tr class="separator:ga64568b80b98d2db6f3bbb89620beda36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c4e364eaf4124db5bacdb2d9f8f3950"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga4c4e364eaf4124db5bacdb2d9f8f3950">Sequence::is_descendant</a> (marginal::const_iterator beg, const int &amp;ind, const int &amp;branch)</td></tr>
<tr class="memdesc:ga4c4e364eaf4124db5bacdb2d9f8f3950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask if a tip of a tree is a descendant of a particular branch.  <a href="#ga4c4e364eaf4124db5bacdb2d9f8f3950">More...</a><br /></td></tr>
<tr class="separator:ga4c4e364eaf4124db5bacdb2d9f8f3950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00621e276219aca146a665b3699d9cfe"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga00621e276219aca146a665b3699d9cfe">Sequence::total_time_on_arg</a> (const <a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">Sequence::arg</a> &amp;sample_history, const int &amp;total_number_of_sites)</td></tr>
<tr class="memdesc:ga00621e276219aca146a665b3699d9cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total time on an ancestral recombination graph.  <a href="#ga00621e276219aca146a665b3699d9cfe">More...</a><br /></td></tr>
<tr class="separator:ga00621e276219aca146a665b3699d9cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaaa678e49901c1ef90b470ec226ac8f71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa678e49901c1ef90b470ec226ac8f71"></a>
MAX_SEG_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gaaa678e49901c1ef90b470ec226ac8f71">Sequence::MAX_SEGSITES</a> =200</td></tr>
<tr class="memdesc:gaaa678e49901c1ef90b470ec226ac8f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">controls allocation of simulated gametes You must define this in namespace <a class="el" href="namespaceSequence.html" title="The namespace in which this library resides. ">Sequence</a> in your program. A value of 200 works well. <br /></td></tr>
<tr class="separator:gaaa678e49901c1ef90b470ec226ac8f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa539fc37aaebc51fee7190755f49abb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa539fc37aaebc51fee7190755f49abb5"></a>
MAX_SEG_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gaa539fc37aaebc51fee7190755f49abb5">Sequence::MAX_SEGS_INC</a> =200</td></tr>
<tr class="memdesc:gaa539fc37aaebc51fee7190755f49abb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">controls (re)allocation of simulated gametes You must define this in namespace <a class="el" href="namespaceSequence.html" title="The namespace in which this library resides. ">Sequence</a> in your program. A value of 100 works well <br /></td></tr>
<tr class="separator:gaa539fc37aaebc51fee7190755f49abb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga1116020585e7246433b28c69b0623a20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;marginal&gt; <a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">Sequence::arg</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ancestral <a class="el" href="namespaceSequence_1_1Recombination.html" title="Methods dealing with recombination. ">Recombination</a> Graph. </p>
<p>An arg is an "ancestral recombination graph", which is a linked list of marginal histories.</p>
<dl class="section note"><dt>Note</dt><dd>The implementation of the crossover function ensures that the marginal trees are sorted in ascending order determined by <a class="el" href="structSequence_1_1marginal.html#a30c13f35cdf216e4930c25669cf4a0b3">marginal::beg</a> </dd></dl>

<p>Definition at line <a class="el" href="SimTypes_8hpp_source.html#l00216">216</a> of file <a class="el" href="SimTypes_8hpp_source.html">SimTypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga48c093934ec4ec1c477415f86a2ffed3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt; std::vector&lt;double&gt;, std::vector&lt;std::string&gt; &gt; <a class="el" href="group__coalescent.html#ga48c093934ec4ec1c477415f86a2ffed3">Sequence::gamete_storage_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an object to store simulated gametes An object of this type will tend to exist in the calling environment of your program. If you are simulating a sample of n chromosomes, you would initialize the object as follows: </p>
<div class="fragment"><div class="line"><a class="code" href="group__coalescent.html#ga48c093934ec4ec1c477415f86a2ffed3">gamete_storage_type</a> gamete_bucket( std::vector&lt;double&gt;(<a class="code" href="group__coalescent.html#gaaa678e49901c1ef90b470ec226ac8f71">MAX_SEGSITES</a>,0.),</div>
<div class="line">std::vector&lt; std::string &gt;(n,std::string(<a class="code" href="group__coalescent.html#gaaa678e49901c1ef90b470ec226ac8f71">MAX_SEGSITES</a>,<span class="charliteral">&#39;0&#39;</span>)) );</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="Mutation_8hpp_source.html#l00041">41</a> of file <a class="el" href="Mutation_8hpp_source.html">Mutation.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf6799b522bbd1873080aeb2107244172"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::calculate_scales </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>fragments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; double, double &gt; &gt; *&#160;</td>
          <td class="paramname"><em>sample_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; double, double &gt; &gt; *&#160;</td>
          <td class="paramname"><em>mutation_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a helper function that rescales physical distance in base pairs to continuous distance on the interval 0,1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fragments</td><td>A vector of pairs, representing physical distance in bp. For each pair, the first element is the distance to the next fragment, and the second element is the length of the fragment. For example, two 1kb fragments separated by 10kb would be represented by the pairs (0,1000) (10000,1000). </td></tr>
    <tr><td class="paramname">sample_scale</td><td>This vector will be filled with values representing the positions of the fragments on the continuous interval, without any space betwen them. This is because we will actually do the simulation using a non-uniform genetic map to represent the high recombination rates between fragments </td></tr>
    <tr><td class="paramname">mutation_scale</td><td>This is a direct mapping of the data contained in <em>fragments</em> to the continuous scale, and can be used to rescale the positions of mutations </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a0">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html#l00063">63</a> of file <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html">CoalescentFragmentsRescaling.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gad689617c904bc44ec5fade5940273396"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::coalesce </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>ttl_nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>current_nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nlinks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; chromosome &gt; *&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arg *&#160;</td>
          <td class="paramname"><em>sample_history</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Common ancestor routine for coalescent simulation. Merges chromosome segments and updates marginal trees. </p>
<p>Common ancestor routine for coalescent simulation. This routine performs the merging of two lineages by a coalescent event. Such merges usually require two sorts of operations. The first is an update to the segments contained in a chromosome, and the second is an update of the nodes on a marginal tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>the time at which the coalecent event is occuring </td></tr>
    <tr><td class="paramname">ttl_nsam</td><td>the total sample size being simulated </td></tr>
    <tr><td class="paramname">current_nsam</td><td>the current sample size in the simulation </td></tr>
    <tr><td class="paramname">c1</td><td>the array index of the first chromosome involved in the coalescent event </td></tr>
    <tr><td class="paramname">c2</td><td>the array index of the second chromosome involved in the coalescent event </td></tr>
    <tr><td class="paramname">nsites</td><td>the total mutational length of the region begin simulated. In the language of Hudson (1983), this is the number of infinitely-many-alleles loci in the simulation. </td></tr>
    <tr><td class="paramname">nlinks</td><td>a pointer to the number of "links" currently in the simulation. A link is the region between two sites, such that a chromosome currently with k sites has k-1 links </td></tr>
    <tr><td class="paramname">sample</td><td>a pointer to the vector of chromosomes which makes up the sample </td></tr>
    <tr><td class="paramname">sample_history</td><td>a pointer to the ancestral recombination graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the decrease in current_nsam due to the coalescent event. Usually, the return value is 1. Sometimes, however, it is two, when the two chromosomes being merged have no ancestral material on the same marginal tree. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a8">fragments.cc</a>, and <a class="el" href="freerec_8cc-example.html#a7">freerec.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentCoalesce_8cc_source.html#l00053">53</a> of file <a class="el" href="CoalescentCoalesce_8cc_source.html">CoalescentCoalesce.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gafe0abcf7a1656a19ad282f44822d7b73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::crossover </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>current_nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>chromo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; chromosome &gt; *&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arg *&#160;</td>
          <td class="paramname"><em>sample_history</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceSequence_1_1Recombination.html" title="Methods dealing with recombination. ">Recombination</a> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_nsam</td><td>the current sample size in the simulation </td></tr>
    <tr><td class="paramname">chromo</td><td>the chromosome on which the crossover event is to occur </td></tr>
    <tr><td class="paramname">pos</td><td>the crossover event happens between sites pos and pos+1 (0&lt;= pos &lt; nsites) </td></tr>
    <tr><td class="paramname">sample</td><td>the sample of chromosomes being simulated </td></tr>
    <tr><td class="paramname">sample_history</td><td>the genealogy of the sample </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of links lost due to the crossover event </dd></dl>
<dl class="section note"><dt>Note</dt><dd>as the type arg is based on std::list, and insertions into lists are done in constant time, this routine keeps the ancestral recombination graph sorted </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a9">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentRecombination_8cc_source.html#l00083">83</a> of file <a class="el" href="CoalescentRecombination_8cc_source.html">CoalescentRecombination.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga64568b80b98d2db6f3bbb89620beda36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Sequence::get_all_descendants </td>
          <td>(</td>
          <td class="paramtype">marginal::const_iterator&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>branch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all the descendants of a branch on a marginal tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>A pointer to the beginning of a marginal tree, i.e. the return value of <a class="el" href="structSequence_1_1marginal.html#a273689a66356661ee4f054a5c633af1b">marginal::begin()</a> </td></tr>
    <tr><td class="paramname">nsam</td><td>the total sample size simulated </td></tr>
    <tr><td class="paramname">branch</td><td>the index of the branch of the tree whose descendants you want. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>branch must be &lt;= 2*nsam-2, which is checked by assert </dd></dl>

<p>Definition at line <a class="el" href="CoalescentTreeOperations_8cc_source.html#l00081">81</a> of file <a class="el" href="CoalescentTreeOperations_8cc_source.html">CoalescentTreeOperations.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga6e3a9fa77284d9751ba6fb025c4d218f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">marginal Sequence::init_marginal </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple function to initialize a marginal tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nsam</td><td>the total sample size (i.e. summed over all populations) that you want to simulate </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="bottleneck_8cc-example.html#a2">bottleneck.cc</a>, <a class="el" href="fragments_8cc-example.html#a5">fragments.cc</a>, and <a class="el" href="freerec_8cc-example.html#a3">freerec.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentInitialize_8cc_source.html#l00061">61</a> of file <a class="el" href="CoalescentInitialize_8cc_source.html">CoalescentInitialize.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gaef587d0dd2c9f5fc9725cea9c166f73a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; chromosome &gt; Sequence::init_sample </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pop_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple function to initialize a sample of chromosomes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pop_config</td><td>For a k-population model, this vector contains the sample size for each pop. Individuals are labeled as beloning to population 0 to k-1, in the order specified in this vector </td></tr>
    <tr><td class="paramname">nsites</td><td>The number of sites at which mutations occur. For a k-site model, recombination occurs at any of the k-1 "links" between sites. Eaach chromosome is assigned a single segment starting at position 0 and ending at nsites-1. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="bottleneck_8cc-example.html#a0">bottleneck.cc</a>, <a class="el" href="fragments_8cc-example.html#a3">fragments.cc</a>, and <a class="el" href="freerec_8cc-example.html#a6">freerec.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentInitialize_8cc_source.html#l00030">30</a> of file <a class="el" href="CoalescentInitialize_8cc_source.html">CoalescentInitialize.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gac820614c0309bd7c2b8c613cb33c4ad5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Sequence::integrate_genetic_map </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; chromosome &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>current_nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>genetic_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>reclens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When simulating non-uniform recombination rates, the probability of recombination at each point in the simulation needs to be obtained by integrating over the genetic map and the current sample configuration. This function does that. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td>the vector containing the current state of all chromosomes in the sample </td></tr>
    <tr><td class="paramname">current_nsam</td><td>the current sample size in the simulation </td></tr>
    <tr><td class="paramname">genetic_map</td><td>a vector containing rho/"link" for each link in the sample. For the i-th base-pair in the chromosome, the "link" is the "space between" positions i and i+1. The value of genetic_map[i] is therefore 4Nr between site i and i+1 (sometimes called 4Nr/"site"). </td></tr>
    <tr><td class="paramname">reclens</td><td>a vector of doubles. This vector will be resized to <em>current_nsam</em> in this function, and filled with <em>current_nsam</em> values, each of which is the sum(genetic_map[beg],genetic_map[end-1]) for each chromosome in the sample, where beg and end are the first and last positions in each chromosome. These data are needed by the function pick_spot (<a class="el" href="Coalescent_2Recombination_8hpp_source.html">Sequence/Coalescent/Recombination.hpp</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cummulative recombination rate in the sample, which is obtained by integrating over the ancestral material in the sample and the genetic map. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a7">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html#l00167">167</a> of file <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html">CoalescentFragmentsRescaling.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga4c4e364eaf4124db5bacdb2d9f8f3950"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sequence::is_descendant </td>
          <td>(</td>
          <td class="paramtype">marginal::const_iterator&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>branch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask if a tip of a tree is a descendant of a particular branch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>A pointer to the beginning of a marginal tree, i.e. the return value of <a class="el" href="structSequence_1_1marginal.html#a273689a66356661ee4f054a5c633af1b">marginal::begin()</a> </td></tr>
    <tr><td class="paramname">ind</td><td>the index of the putative descendant node </td></tr>
    <tr><td class="paramname">branch</td><td>the index of the branch of the tree which may be the ancestor of <em>ind</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not check whether ind or branch go out of bounds, and so the programmer must ensure that both values are &lt;= 2*nsam-2, where nsam is the total sample size simulated </dd></dl>

<p>Definition at line <a class="el" href="CoalescentTreeOperations_8cc_source.html#l00105">105</a> of file <a class="el" href="CoalescentTreeOperations_8cc_source.html">CoalescentTreeOperations.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gadc67bf45f19257a18e6a05ccc472c433"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sequence::isseg </td>
          <td>(</td>
          <td class="paramtype">chromosome::const_iterator&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>nsegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ask if a chromosome beginning at seg and containing nsegs contains a segment containing the position pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>a pointer to a segment of a chromosome (this should be the 1st segment, such as the return value of <a class="el" href="structSequence_1_1chromosome.html#aa7092f3a0a23ba880d162c0365abd479">chromosome::begin()</a>) </td></tr>
    <tr><td class="paramname">nsegs</td><td>the number of segs in the chromosome pointed to by <em>seg</em> </td></tr>
    <tr><td class="paramname">offset</td><td>a pointer to an integer. This integer is used for repeated pointer arithmetic, and should be initalized to 0 before the first call. </td></tr>
    <tr><td class="paramname">pos</td><td>a position a long a chromosome. This function asks if pos is contained in the ancestral material of the chromosome whose segments begin at <em>seg</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a segment exists that contains the point pos </dd></dl>
<dl class="section note"><dt>Note</dt><dd>only used by the function coalesce </dd></dl>

<p>Definition at line <a class="el" href="CoalescentCoalesce_8cc_source.html#l00029">29</a> of file <a class="el" href="CoalescentCoalesce_8cc_source.html">CoalescentCoalesce.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gacd252657f1fdb3fe7d73fe23c468fd05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator , typename poisson_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSequence_1_1SimData.html">Sequence::SimData</a> Sequence::neutral_sample </td>
          <td>(</td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uniform01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exponential_generator &amp;&#160;</td>
          <td class="paramname"><em>expo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">poisson_generator &amp;&#160;</td>
          <td class="paramname"><em>poiss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; chromosome &gt; *&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arg *&#160;</td>
          <td class="paramname"><em>sample_history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>max_chromosomes</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>max_chromosomes_inc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple function to generate samples under a neutral equilibrium model. </p>
<p>A simple function to generate samples under a neutral equilibrium model with infinite-sites mutation and a constant recombination rate accross the region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a function/object capable of returning a random double uniformly from [0,k) </td></tr>
    <tr><td class="paramname">uni01</td><td>a function/object capable of returning a random probability uniformly from [0,1) </td></tr>
    <tr><td class="paramname">expo</td><td>a function/object capable of returning an exponentially distributed random variable. The function must take a single double as an argument, which is the mean of the exponential distribution </td></tr>
    <tr><td class="paramname">poiss</td><td>a function/object capable of returning an poisson distributed random variable. The function must take a single double as an argument, which is the mean of the poisson distribution </td></tr>
    <tr><td class="paramname">theta</td><td>4Nu, the coalescent-scaled mutation rate </td></tr>
    <tr><td class="paramname">rho</td><td>4Nr, the recombination rate for the whole region </td></tr>
    <tr><td class="paramname">nsites</td><td>the number of mutational sites to simulate. <a class="el" href="namespaceSequence_1_1Recombination.html" title="Methods dealing with recombination. ">Recombination</a> is equally likely between any two sites. </td></tr>
    <tr><td class="paramname">nsites</td><td>the total sample size. (There is no population structure in this routine) </td></tr>
    <tr><td class="paramname">sample</td><td>A pointer to the sample of chromosomes you wish to simulate. This must be properly initialized, for example using the function init_sample in &lt;<a class="el" href="Initialize_8hpp_source.html">Sequence/Coalescent/Initialize.hpp</a>&gt; </td></tr>
    <tr><td class="paramname">sample_history</td><td>a pointer to the ancestral recombination graph. This must be initialized in the calling enviroment. In general, you can use init_marginal in &lt;<a class="el" href="Initialize_8hpp_source.html">Sequence/Coalescent/Initialize.hpp</a>&gt; </td></tr>
    <tr><td class="paramname">max_chromosomes</td><td>This is a pointer to an integer in the calling environment which you can use to reserve memory in the array containing the sample of chromosomes. If the size of <em>sample</em> ever gets larger than this, max_chromosomes is incremented by <em>max_chromosomes_inc</em> </td></tr>
    <tr><td class="paramname">max_chromosomes_inc</td><td>the amount by which to increment <em>max_chromosomes</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does require a bit of work to use, although not much. Please see the example code that comes with the library, in particular ms&ndash;.cc </dd></dl>

<p>Definition at line <a class="el" href="NeutralSample_8hpp_source.html#l00016">16</a> of file <a class="el" href="NeutralSample_8hpp_source.html">NeutralSample.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga1ae894594d083945cf2280d7b47797cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::pick_branch </td>
          <td>(</td>
          <td class="paramtype">marginal::const_iterator&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rtime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pick a random branch of a marginal tree </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>A pointer to the beginning of a marginal tree, i.e. the return value of <a class="el" href="structSequence_1_1marginal.html#a273689a66356661ee4f054a5c633af1b">marginal::begin()</a> </td></tr>
    <tr><td class="paramname">nsam</td><td>the total sample size simulated </td></tr>
    <tr><td class="paramname">rtime</td><td>a (preferably random) double between 0 and the total_time on the marginal tree from which <em>beg</em> is the iterator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="CoalescentTreeOperations_8cc_source.html#l00054">54</a> of file <a class="el" href="CoalescentTreeOperations_8cc_source.html">CoalescentTreeOperations.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga3697a3a402b2395fafc6dc2548721a1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; Sequence::pick_uniform_spot </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>random_01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nlinks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; chromosome &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>sample_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>current_nsam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pick a crossover point for the model where recombination rates are constant across a recion. Picks a positions uniformly amongst all chromosomes at which a recombination event will occur. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">random_01</td><td>a random uniform deviate U[0,1) </td></tr>
    <tr><td class="paramname">nlinks</td><td>the number of links currently in the simulation </td></tr>
    <tr><td class="paramname">sample_begin</td><td>an iterator pointing to the beginning of the sample </td></tr>
    <tr><td class="paramname">current_nsam</td><td>the current sample size in the simulation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of integers containing the index of the recombinant chromosome (.first), and the position at which the crossover will occur (.second) </dd></dl>

<p>Definition at line <a class="el" href="CoalescentRecombination_8cc_source.html#l00051">51</a> of file <a class="el" href="CoalescentRecombination_8cc_source.html">CoalescentRecombination.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga0c22215ad956c74d797ee8aa31333afa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::rescale_mutation_positions </td>
          <td>(</td>
          <td class="paramtype">SimData *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mutation_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rescales the positions of the mutations in <em>d</em> from the scale given in <em>sample_scale</em> to that given in <em>mutation_scale</em>. </p>
<dl class="section note"><dt>Note</dt><dd>See documentation for calcualate_scales </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a12">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html#l00106">106</a> of file <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html">CoalescentFragmentsRescaling.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga1e686d875016adee17ea99e68d4eb127"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::sample_length </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>fragments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When simulating partially linked regions, return the total length of sample material that we are simulating. </p>
<dl class="section return"><dt>Returns</dt><dd>The sum of fragments[i].second for i=0 to i=fragments.size()-1 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a1">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html#l00031">31</a> of file <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html">CoalescentFragmentsRescaling.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gad76215f50d491cee38ed10fdc9abeae2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::total_length </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>fragments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When simulating partially linked regions, return the total length of the region. </p>
<dl class="section return"><dt>Returns</dt><dd>The sum of fragments[i].first + fragments[i].second for i=0 to i=fragments.size()-1 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a2">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html#l00047">47</a> of file <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html">CoalescentFragmentsRescaling.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gae9f77f12a1707c21f20badb8b92b1d20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Sequence::total_time </td>
          <td>(</td>
          <td class="paramtype">const marginal::const_iterator&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate total time on a marginal tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>A pointer to the beginning of a marginal tree, i.e. the return value of <a class="el" href="structSequence_1_1marginal.html#a273689a66356661ee4f054a5c633af1b">marginal::begin()</a> </td></tr>
    <tr><td class="paramname">nsam</td><td>the total sample size simulated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total time on the tree. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The scaling of time in the simulation is up to you </dd></dl>

<p>Definition at line <a class="el" href="CoalescentTreeOperations_8cc_source.html#l00032">32</a> of file <a class="el" href="CoalescentTreeOperations_8cc_source.html">CoalescentTreeOperations.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga00621e276219aca146a665b3699d9cfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Sequence::total_time_on_arg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coalescent.html#ga1116020585e7246433b28c69b0623a20">Sequence::arg</a> &amp;&#160;</td>
          <td class="paramname"><em>sample_history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>total_number_of_sites</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total time on an ancestral recombination graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample_history</td><td>an ancestral recombination graph </td></tr>
    <tr><td class="paramname">total_number_of_sites</td><td>the number of "sites" simulated on the ARG </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total time on an ancestral recombination graph. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The time is in terms of whatever units are recorded on the nodes of the mariginals of the ARG </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSequence_1_1SeqException.html" title="Base class for exceptions that may be thrown. ">Sequence::SeqException</a></td><td>if the beginning of any marginal tree is &gt;= total_number_of_sites </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="CoalescentTreeOperations_8cc_source.html#l00130">130</a> of file <a class="el" href="CoalescentTreeOperations_8cc_source.html">CoalescentTreeOperations.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Dec 16 2014 15:56:55 for libsequence by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
