<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libsequence: Classes and functions related to simulating data under coalescent models</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsequence
   &#160;<span id="projectnumber">1.8.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__coalescent.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Classes and functions related to simulating data under coalescent models<div class="ingroups"><a class="el" href="group__popgen.html">Molecular Population Genetics</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1coalsim_1_1segment.html">Sequence::coalsim::segment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A portion of a recombining chromosome.  <a href="structSequence_1_1coalsim_1_1segment.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1coalsim_1_1chromosome.html">Sequence::coalsim::chromosome</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A chromosome is a container of segments.  <a href="structSequence_1_1coalsim_1_1chromosome.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1coalsim_1_1node.html">Sequence::coalsim::node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A point on a marginal tree at which a coalescent event occurs.  <a href="structSequence_1_1coalsim_1_1node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSequence_1_1coalsim_1_1marginal.html">Sequence::coalsim::marginal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The genealogy of a portion of a chromosome on which no recombination has occurred.  <a href="structSequence_1_1coalsim_1_1marginal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1coalsim_1_1newick__stream__marginal__tree.html">Sequence::coalsim::newick_stream_marginal_tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides a typecast-on-output of a marginal tree to a newick tree Example use:  <a href="classSequence_1_1coalsim_1_1newick__stream__marginal__tree.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1SimData.html">Sequence::SimData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data from coalescent simulations.  <a href="classSequence_1_1SimData.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSequence_1_1SimParams.html">Sequence::SimParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for Hudson's simulation program.  <a href="classSequence_1_1SimParams.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga23ef0fa48fefd60c2b0d0e709e433871"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; std::vector<br class="typebreak"/>
&lt; double &gt;, std::vector<br class="typebreak"/>
&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga23ef0fa48fefd60c2b0d0e709e433871">Sequence::coalsim::gamete_storage_type</a></td></tr>
<tr class="memdesc:ga23ef0fa48fefd60c2b0d0e709e433871"><td class="mdescLeft">&#160;</td><td class="mdescRight">an object to store simulated gametes An object of this type will tend to exist in the calling environment of your program. If you are simulating a sample of n chromosomes, you would initialize the object as follows:  <a href="#ga23ef0fa48fefd60c2b0d0e709e433871">More...</a><br/></td></tr>
<tr class="separator:ga23ef0fa48fefd60c2b0d0e709e433871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf25e6e55ecf4ab56ffdaffcc69213e3"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; marginal &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gabf25e6e55ecf4ab56ffdaffcc69213e3">Sequence::coalsim::arg</a></td></tr>
<tr class="memdesc:gabf25e6e55ecf4ab56ffdaffcc69213e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ancestral <a class="el" href="namespaceSequence_1_1Recombination.html" title="Methods dealing with recombination. ">Recombination</a> Graph.  <a href="#gabf25e6e55ecf4ab56ffdaffcc69213e3">More...</a><br/></td></tr>
<tr class="separator:gabf25e6e55ecf4ab56ffdaffcc69213e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga52b664a290b8288678cd9e3fd46b379d"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga52b664a290b8288678cd9e3fd46b379d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga52b664a290b8288678cd9e3fd46b379d">Sequence::coalsim::pick2_in_deme</a> (const uniform_generator &amp;uni, const std::vector&lt; <a class="el" href="structSequence_1_1coalsim_1_1chromosome.html">Sequence::coalsim::chromosome</a> &gt; &amp;sample, const int &amp;current_nsam, const int &amp;deme_nsam, const int &amp;deme)</td></tr>
<tr class="memdesc:ga52b664a290b8288678cd9e3fd46b379d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose two random chromosomes from the same deme.  <a href="#ga52b664a290b8288678cd9e3fd46b379d">More...</a><br/></td></tr>
<tr class="separator:ga52b664a290b8288678cd9e3fd46b379d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga540749697bfc988d4b6270d9fff01cf1"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga540749697bfc988d4b6270d9fff01cf1"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga540749697bfc988d4b6270d9fff01cf1">Sequence::coalsim::pick2</a> (uniform_generator &amp;uni, const int &amp;nsam)</td></tr>
<tr class="separator:ga540749697bfc988d4b6270d9fff01cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e070750d8215e1b784401daddd187f"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:gae2e070750d8215e1b784401daddd187f"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gae2e070750d8215e1b784401daddd187f">Sequence::coalsim::pick2</a> (const uniform_generator &amp;uni, const int &amp;nsam)</td></tr>
<tr class="separator:gae2e070750d8215e1b784401daddd187f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga336bd37e53e80cbfd5ccc6dfea45dcbc"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </td></tr>
<tr class="memitem:ga336bd37e53e80cbfd5ccc6dfea45dcbc"><td class="memTemplItemLeft" align="right" valign="top">arg&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga336bd37e53e80cbfd5ccc6dfea45dcbc">Sequence::coalsim::bottleneck</a> (uniform_generator &amp;uni, uniform01_generator &amp;uni01, exponential_generator &amp;expo, const std::vector&lt; chromosome &gt; &amp;initialized_sample, const marginal &amp;initialized_marginal, const double &amp;tr, const double &amp;d, const double &amp;f, const double &amp;rho, const bool &amp;exponential_recovery, const double &amp;recovered_size)</td></tr>
<tr class="memdesc:ga336bd37e53e80cbfd5ccc6dfea45dcbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coalescent simulation of a population bottleneck Simulate a single, bottlenecked, population according to the Wright-Fisher model without selection. The population can recover from the bottleneck either instantaneously ("stepwise bottleneck"), or according to an exponential growth model. For the case of a stepwise bottleneck, this function is equivalent to the following options in Dick Hudson's program "ms": -eN 0 recovered_size -eN tr f -eN (tr+d) 1. For the case where recovery from the bottleneck is by exponential growth, the equivalent "ms" options are: -eN 0 recovered_size -eG tr (log(recovered_size)-log(f))/d -eG (tr+d) 0 -eN (tr+d) 1.  <a href="#ga336bd37e53e80cbfd5ccc6dfea45dcbc">More...</a><br/></td></tr>
<tr class="separator:ga336bd37e53e80cbfd5ccc6dfea45dcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9802f55cdbf810f590825d196fb17a3d"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </td></tr>
<tr class="memitem:ga9802f55cdbf810f590825d196fb17a3d"><td class="memTemplItemLeft" align="right" valign="top">arg&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga9802f55cdbf810f590825d196fb17a3d">Sequence::coalsim::bottleneck</a> (const uniform_generator &amp;uni, const uniform01_generator &amp;uni01, const exponential_generator &amp;expo, const std::vector&lt; chromosome &gt; &amp;initialized_sample, const marginal &amp;initialized_marginal, const double &amp;tr, const double &amp;d, const double &amp;f, const double &amp;rho, const bool &amp;exponential_recovery, const double &amp;recovered_size)</td></tr>
<tr class="memdesc:ga9802f55cdbf810f590825d196fb17a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coalescent simulation of a population bottleneck Simulate a single, bottlenecked, population according to the Wright-Fisher model without selection. The population can recover from the bottleneck either instantaneously ("stepwise bottleneck"), or according to an exponential growth model. For the case of a stepwise bottleneck, this function is equivalent to the following options in Dick Hudson's program "ms": -eN 0 recovered_size -eN tr f -eN (tr+d) 1. For the case where recovery from the bottleneck is by exponential growth, the equivalent "ms" options are: -eN 0 recovered_size -eG tr (log(recovered_size)-log(f))/d -eG (tr+d) 0 -eN (tr+d) 1.  <a href="#ga9802f55cdbf810f590825d196fb17a3d">More...</a><br/></td></tr>
<tr class="separator:ga9802f55cdbf810f590825d196fb17a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f38052a5261d2ea0cd55de41371c507"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </td></tr>
<tr class="memitem:ga8f38052a5261d2ea0cd55de41371c507"><td class="memTemplItemLeft" align="right" valign="top">arg&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga8f38052a5261d2ea0cd55de41371c507">Sequence::coalsim::exponential_change</a> (uniform_generator &amp;uni, uniform01_generator &amp;uni01, exponential_generator &amp;expo, const std::vector&lt; chromosome &gt; &amp;initialized_sample, const marginal &amp;initialized_marginal, const double &amp;G, const double &amp;t_begin, const double &amp;t_end, const double &amp;rho, const double &amp;size_at_end)</td></tr>
<tr class="memdesc:ga8f38052a5261d2ea0cd55de41371c507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coalescent simulation of exponential change in population size Simulate a single population whose size changes exponentially during some period of time. The relevant command line options for Hudson's program "ms" would be: -eG t_begin G -eG t_end 0. -eN t_end size_at_end.  <a href="#ga8f38052a5261d2ea0cd55de41371c507">More...</a><br/></td></tr>
<tr class="separator:ga8f38052a5261d2ea0cd55de41371c507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd24e6876eaab80d2126cea9e043c80"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </td></tr>
<tr class="memitem:gabcd24e6876eaab80d2126cea9e043c80"><td class="memTemplItemLeft" align="right" valign="top">arg&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gabcd24e6876eaab80d2126cea9e043c80">Sequence::coalsim::exponential_change</a> (const uniform_generator &amp;uni, const uniform01_generator &amp;uni01, const exponential_generator &amp;expo, const std::vector&lt; chromosome &gt; &amp;initialized_sample, const marginal &amp;initialized_marginal, const double &amp;G, const double &amp;t_begin, const double &amp;t_end, const double &amp;rho, const double &amp;size_at_end)</td></tr>
<tr class="memdesc:gabcd24e6876eaab80d2126cea9e043c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coalescent simulation of exponential change in population size Simulate a single population whose size changes exponentially during some period of time. The relevant command line options for Hudson's program "ms" would be: -eG t_begin -eG t_end 0. -eN t_end size_at_end.  <a href="#gabcd24e6876eaab80d2126cea9e043c80">More...</a><br/></td></tr>
<tr class="separator:gabcd24e6876eaab80d2126cea9e043c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44519e0a94e031435895434217198d25"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga44519e0a94e031435895434217198d25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga44519e0a94e031435895434217198d25">Sequence::coalsim::add_S_inf_sites</a> (uniform_generator &amp;uni, marginal::const_iterator history, const double &amp;tt, const int &amp;beg, const int &amp;end, const int &amp;nsam, const int &amp;nsites, const int &amp;S, const int &amp;first_snp_index, gamete_storage_type *gametes)</td></tr>
<tr class="memdesc:ga44519e0a94e031435895434217198d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add S segregating sites to sample with a particular marginal history, according to the infinitely-many sites model.  <a href="#ga44519e0a94e031435895434217198d25">More...</a><br/></td></tr>
<tr class="separator:ga44519e0a94e031435895434217198d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a1ce0225764c480ee961c4852aeeba1"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga2a1ce0225764c480ee961c4852aeeba1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga2a1ce0225764c480ee961c4852aeeba1">Sequence::coalsim::add_S_inf_sites</a> (const uniform_generator &amp;uni, marginal::const_iterator history, const double &amp;tt, const int &amp;beg, const int &amp;end, const int &amp;nsam, const int &amp;nsites, const int &amp;S, const int &amp;first_snp_index, gamete_storage_type *gametes)</td></tr>
<tr class="memdesc:ga2a1ce0225764c480ee961c4852aeeba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add S segregating sites to sample with a particular marginal history, according to the infinitely-many sites model.  <a href="#ga2a1ce0225764c480ee961c4852aeeba1">More...</a><br/></td></tr>
<tr class="separator:ga2a1ce0225764c480ee961c4852aeeba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40aa548b1d119b44605da893c5d7cffa"><td class="memTemplParams" colspan="2">template&lt;typename poisson_generator , typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga40aa548b1d119b44605da893c5d7cffa"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga40aa548b1d119b44605da893c5d7cffa">Sequence::coalsim::infinite_sites</a> (poisson_generator &amp;poiss, uniform_generator &amp;uni, gamete_storage_type *gametes, const int &amp;nsites, const arg &amp;history, const double &amp;theta)</td></tr>
<tr class="memdesc:ga40aa548b1d119b44605da893c5d7cffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph.  <a href="#ga40aa548b1d119b44605da893c5d7cffa">More...</a><br/></td></tr>
<tr class="separator:ga40aa548b1d119b44605da893c5d7cffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8efceef9b6eff28618ae51bbf1197f1f"><td class="memTemplParams" colspan="2">template&lt;typename poisson_generator , typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga8efceef9b6eff28618ae51bbf1197f1f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga8efceef9b6eff28618ae51bbf1197f1f">Sequence::coalsim::infinite_sites</a> (const poisson_generator &amp;poiss, const uniform_generator &amp;uni, gamete_storage_type *gametes, const int &amp;nsites, const arg &amp;history, const double &amp;theta)</td></tr>
<tr class="memdesc:ga8efceef9b6eff28618ae51bbf1197f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph.  <a href="#ga8efceef9b6eff28618ae51bbf1197f1f">More...</a><br/></td></tr>
<tr class="separator:ga8efceef9b6eff28618ae51bbf1197f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0be279dc4a03cde60ee2a649b620a63"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:gab0be279dc4a03cde60ee2a649b620a63"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gab0be279dc4a03cde60ee2a649b620a63">Sequence::coalsim::infinite_sites</a> (uniform_generator &amp;uni, gamete_storage_type *gametes, const int &amp;nsites, const arg &amp;history, const double *total_times, const unsigned *segsites)</td></tr>
<tr class="memdesc:gab0be279dc4a03cde60ee2a649b620a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites.  <a href="#gab0be279dc4a03cde60ee2a649b620a63">More...</a><br/></td></tr>
<tr class="separator:gab0be279dc4a03cde60ee2a649b620a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78d7f92f43b376948eade29e38f95af8"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga78d7f92f43b376948eade29e38f95af8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga78d7f92f43b376948eade29e38f95af8">Sequence::coalsim::infinite_sites</a> (const uniform_generator &amp;uni, gamete_storage_type *gametes, const int &amp;nsites, const arg &amp;history, const double *total_times, const unsigned *segsites)</td></tr>
<tr class="memdesc:ga78d7f92f43b376948eade29e38f95af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites.  <a href="#ga78d7f92f43b376948eade29e38f95af8">More...</a><br/></td></tr>
<tr class="separator:ga78d7f92f43b376948eade29e38f95af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc06180851946ec2190ae93785a8a0a3"><td class="memTemplParams" colspan="2">template&lt;typename poisson_generator , typename uniform_generator &gt; </td></tr>
<tr class="memitem:gabc06180851946ec2190ae93785a8a0a3"><td class="memTemplItemLeft" align="right" valign="top">SimData&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gabc06180851946ec2190ae93785a8a0a3">Sequence::coalsim::infinite_sites_sim_data</a> (poisson_generator &amp;poiss, uniform_generator &amp;uni, const int &amp;nsites, const arg &amp;history, const double &amp;theta)</td></tr>
<tr class="memdesc:gabc06180851946ec2190ae93785a8a0a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph.  <a href="#gabc06180851946ec2190ae93785a8a0a3">More...</a><br/></td></tr>
<tr class="separator:gabc06180851946ec2190ae93785a8a0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef36909309a8ce1fd7ff4da9ffe1aed3"><td class="memTemplParams" colspan="2">template&lt;typename poisson_generator , typename uniform_generator &gt; </td></tr>
<tr class="memitem:gaef36909309a8ce1fd7ff4da9ffe1aed3"><td class="memTemplItemLeft" align="right" valign="top">SimData&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gaef36909309a8ce1fd7ff4da9ffe1aed3">Sequence::coalsim::infinite_sites_sim_data</a> (const poisson_generator &amp;poiss, const uniform_generator &amp;uni, const int &amp;nsites, const arg &amp;history, const double &amp;theta)</td></tr>
<tr class="memdesc:gaef36909309a8ce1fd7ff4da9ffe1aed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph.  <a href="#gaef36909309a8ce1fd7ff4da9ffe1aed3">More...</a><br/></td></tr>
<tr class="separator:gaef36909309a8ce1fd7ff4da9ffe1aed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0c8f4db37c99fb894337fbcce910dd6"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:gab0c8f4db37c99fb894337fbcce910dd6"><td class="memTemplItemLeft" align="right" valign="top">SimData&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gab0c8f4db37c99fb894337fbcce910dd6">Sequence::coalsim::infinite_sites_sim_data</a> (uniform_generator &amp;uni, const int &amp;nsites, const arg &amp;history, const double *total_times, const unsigned *segsites)</td></tr>
<tr class="memdesc:gab0c8f4db37c99fb894337fbcce910dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites.  <a href="#gab0c8f4db37c99fb894337fbcce910dd6">More...</a><br/></td></tr>
<tr class="separator:gab0c8f4db37c99fb894337fbcce910dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84db82131b381d35d77286be8ace562e"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator &gt; </td></tr>
<tr class="memitem:ga84db82131b381d35d77286be8ace562e"><td class="memTemplItemLeft" align="right" valign="top">SimData&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga84db82131b381d35d77286be8ace562e">Sequence::coalsim::infinite_sites_sim_data</a> (const uniform_generator &amp;uni, const int &amp;nsites, const arg &amp;history, const double *total_times, const unsigned *segsites)</td></tr>
<tr class="memdesc:ga84db82131b381d35d77286be8ace562e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites.  <a href="#ga84db82131b381d35d77286be8ace562e">More...</a><br/></td></tr>
<tr class="separator:ga84db82131b381d35d77286be8ace562e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeead0752500575b9483f54965ba9b3ea"><td class="memTemplParams" colspan="2">template&lt;typename uniform01_generator &gt; </td></tr>
<tr class="memitem:gaeead0752500575b9483f54965ba9b3ea"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gaeead0752500575b9483f54965ba9b3ea">Sequence::coalsim::pick_spot</a> (uniform01_generator &amp;uni01, const double &amp;total_reclen, const std::vector&lt; double &gt; &amp;reclens, std::vector&lt; chromosome &gt;::const_iterator sample_begin, const unsigned &amp;current_nsam, const double *rec_map)</td></tr>
<tr class="separator:gaeead0752500575b9483f54965ba9b3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f0cb180d2cee65c58c8ae1c973e709d"><td class="memTemplParams" colspan="2">template&lt;typename uniform01_generator &gt; </td></tr>
<tr class="memitem:ga9f0cb180d2cee65c58c8ae1c973e709d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga9f0cb180d2cee65c58c8ae1c973e709d">Sequence::coalsim::pick_spot</a> (const uniform01_generator &amp;uni01, const double &amp;total_reclen, const std::vector&lt; double &gt; &amp;reclens, std::vector&lt; chromosome &gt;::const_iterator sample_begin, const unsigned &amp;current_nsam, const double *rec_map)</td></tr>
<tr class="separator:ga9f0cb180d2cee65c58c8ae1c973e709d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e904076ec7e35caabd2a69e3dffa297"><td class="memTemplParams" colspan="2">template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator , typename poisson_generator &gt; </td></tr>
<tr class="memitem:ga6e904076ec7e35caabd2a69e3dffa297"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSequence_1_1SimData.html">Sequence::SimData</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga6e904076ec7e35caabd2a69e3dffa297">Sequence::coalsim::neutral_sample</a> (uniform_generator &amp;uni, uniform01_generator &amp;uni01, exponential_generator &amp;expo, poisson_generator &amp;poiss, const double &amp;theta, const double &amp;rho, const int &amp;nsites, const int &amp;nsam, std::vector&lt; chromosome &gt; *sample, arg *sample_history, unsigned *max_chromosomes=NULL, const unsigned &amp;max_chromosomes_inc=0)</td></tr>
<tr class="memdesc:ga6e904076ec7e35caabd2a69e3dffa297"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple function to generate samples under a neutral equilibrium model.  <a href="#ga6e904076ec7e35caabd2a69e3dffa297">More...</a><br/></td></tr>
<tr class="separator:ga6e904076ec7e35caabd2a69e3dffa297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3356506cf30cbfc7193a17f206d0de9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga3356506cf30cbfc7193a17f206d0de9b">Sequence::coalsim::isseg</a> (chromosome::const_iterator seg, const unsigned &amp;nsegs, const int &amp;pos, unsigned *offset)</td></tr>
<tr class="memdesc:ga3356506cf30cbfc7193a17f206d0de9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ask if a chromosome beginning at seg and containing nsegs contains a segment containing the position pos  <a href="#ga3356506cf30cbfc7193a17f206d0de9b">More...</a><br/></td></tr>
<tr class="separator:ga3356506cf30cbfc7193a17f206d0de9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0db60eb08eadab4d2cc9c3a4ccdf846"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gae0db60eb08eadab4d2cc9c3a4ccdf846">Sequence::coalsim::coalesce</a> (const double &amp;time, const int &amp;ttl_nsam, const int &amp;current_nsam, const int &amp;c1, const int &amp;c2, const int &amp;nsites, int *nlinks, std::vector&lt; chromosome &gt; *sample, arg *sample_history)</td></tr>
<tr class="memdesc:gae0db60eb08eadab4d2cc9c3a4ccdf846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common ancestor routine for coalescent simulation. Merges chromosome segments and updates marginal trees.  <a href="#gae0db60eb08eadab4d2cc9c3a4ccdf846">More...</a><br/></td></tr>
<tr class="separator:gae0db60eb08eadab4d2cc9c3a4ccdf846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7f5707d2a650dbd3021e2a7403942b3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gae7f5707d2a650dbd3021e2a7403942b3">Sequence::coalsim::sample_length</a> (const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;fragments)</td></tr>
<tr class="memdesc:gae7f5707d2a650dbd3021e2a7403942b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">When simulating partially linked regions, return the total length of sample material that we are simulating.  <a href="#gae7f5707d2a650dbd3021e2a7403942b3">More...</a><br/></td></tr>
<tr class="separator:gae7f5707d2a650dbd3021e2a7403942b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6f384ac658344ff44f4413b1a77a34e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gac6f384ac658344ff44f4413b1a77a34e">Sequence::coalsim::total_length</a> (const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;fragments)</td></tr>
<tr class="memdesc:gac6f384ac658344ff44f4413b1a77a34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">When simulating partially linked regions, return the total length of the region.  <a href="#gac6f384ac658344ff44f4413b1a77a34e">More...</a><br/></td></tr>
<tr class="separator:gac6f384ac658344ff44f4413b1a77a34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fe3c0b20183faf7b3329d286b223c22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga6fe3c0b20183faf7b3329d286b223c22">Sequence::coalsim::calculate_scales</a> (const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;fragments, std::vector&lt; std::pair&lt; double, double &gt; &gt; *sample_scale, std::vector&lt; std::pair&lt; double, double &gt; &gt; *mutation_scale)</td></tr>
<tr class="memdesc:ga6fe3c0b20183faf7b3329d286b223c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a helper function that rescales physical distance in base pairs to continuous distance on the interval 0,1.  <a href="#ga6fe3c0b20183faf7b3329d286b223c22">More...</a><br/></td></tr>
<tr class="separator:ga6fe3c0b20183faf7b3329d286b223c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e2444231cd36ed90653671b0d1197c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gad4e2444231cd36ed90653671b0d1197c">Sequence::coalsim::rescale_mutation_positions</a> (<a class="el" href="classSequence_1_1SimData.html">Sequence::SimData</a> *d, const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;sample_scale, const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;mutation_scale)</td></tr>
<tr class="memdesc:gad4e2444231cd36ed90653671b0d1197c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescales the positions of the mutations in <em>d</em> from the scale given in <em>sample_scale</em> to that given in <em>mutation_scale</em>.  <a href="#gad4e2444231cd36ed90653671b0d1197c">More...</a><br/></td></tr>
<tr class="separator:gad4e2444231cd36ed90653671b0d1197c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae05bf27fdb8db26d8d5f0c348d11e41b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae05bf27fdb8db26d8d5f0c348d11e41b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gae05bf27fdb8db26d8d5f0c348d11e41b">Sequence::coalsim::rescale_arg</a> (arg *sample_history, const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;fragments)</td></tr>
<tr class="memdesc:gae05bf27fdb8db26d8d5f0c348d11e41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rescales the beginnings of marginal trees in an ancestral recombination graph from a genetic scale to a physical scale. <br/></td></tr>
<tr class="separator:gae05bf27fdb8db26d8d5f0c348d11e41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97cb42aca9d2e63e3d9a5ef949fdbde2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga97cb42aca9d2e63e3d9a5ef949fdbde2">Sequence::coalsim::integrate_genetic_map</a> (const std::vector&lt; chromosome &gt; &amp;sample, const int &amp;current_nsam, const std::vector&lt; double &gt; &amp;genetic_map, std::vector&lt; double &gt; *reclens)</td></tr>
<tr class="memdesc:ga97cb42aca9d2e63e3d9a5ef949fdbde2"><td class="mdescLeft">&#160;</td><td class="mdescRight">When simulating non-uniform recombination rates, the probability of recombination at each point in the simulation needs to be obtained by integrating over the genetic map and the current sample configuration. This function does that.  <a href="#ga97cb42aca9d2e63e3d9a5ef949fdbde2">More...</a><br/></td></tr>
<tr class="separator:ga97cb42aca9d2e63e3d9a5ef949fdbde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19b90389f6021ec39447c8119d3c1adb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; chromosome &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga19b90389f6021ec39447c8119d3c1adb">Sequence::coalsim::init_sample</a> (const std::vector&lt; int &gt; &amp;pop_config, const int &amp;nsites)</td></tr>
<tr class="memdesc:ga19b90389f6021ec39447c8119d3c1adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple function to initialize a sample of chromosomes.  <a href="#ga19b90389f6021ec39447c8119d3c1adb">More...</a><br/></td></tr>
<tr class="separator:ga19b90389f6021ec39447c8119d3c1adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef932eb70718010392dd1f5e079889ea"><td class="memItemLeft" align="right" valign="top">marginal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gaef932eb70718010392dd1f5e079889ea">Sequence::coalsim::init_marginal</a> (const int &amp;nsam)</td></tr>
<tr class="memdesc:gaef932eb70718010392dd1f5e079889ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple function to initialize a marginal tree.  <a href="#gaef932eb70718010392dd1f5e079889ea">More...</a><br/></td></tr>
<tr class="separator:gaef932eb70718010392dd1f5e079889ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18ec6185c7d04ddeaea5cc3fd6db674a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga18ec6185c7d04ddeaea5cc3fd6db674a">Sequence::coalsim::pick_uniform_spot</a> (const double &amp;random_01, const int &amp;nlinks, std::vector&lt; chromosome &gt;::const_iterator sample_begin, const unsigned &amp;current_nsam)</td></tr>
<tr class="memdesc:ga18ec6185c7d04ddeaea5cc3fd6db674a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pick a crossover point for the model where recombination rates are constant across a recion. Picks a positions uniformly amongst all chromosomes at which a recombination event will occur.  <a href="#ga18ec6185c7d04ddeaea5cc3fd6db674a">More...</a><br/></td></tr>
<tr class="separator:ga18ec6185c7d04ddeaea5cc3fd6db674a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b2ec8b27b3800757f2e360f6c000499"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga9b2ec8b27b3800757f2e360f6c000499">Sequence::coalsim::crossover</a> (const int &amp;current_nsam, const int &amp;chromo, const int &amp;pos, std::vector&lt; chromosome &gt; *sample, arg *sample_history)</td></tr>
<tr class="memdesc:ga9b2ec8b27b3800757f2e360f6c000499"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceSequence_1_1Recombination.html" title="Methods dealing with recombination. ">Recombination</a> function.  <a href="#ga9b2ec8b27b3800757f2e360f6c000499">More...</a><br/></td></tr>
<tr class="separator:ga9b2ec8b27b3800757f2e360f6c000499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0ff9c3e23f97cb0f8dd91ef8d92d82a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gad0ff9c3e23f97cb0f8dd91ef8d92d82a">Sequence::coalsim::total_time</a> (const marginal::const_iterator beg, const int &amp;nsam)</td></tr>
<tr class="memdesc:gad0ff9c3e23f97cb0f8dd91ef8d92d82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate total time on a marginal tree.  <a href="#gad0ff9c3e23f97cb0f8dd91ef8d92d82a">More...</a><br/></td></tr>
<tr class="separator:gad0ff9c3e23f97cb0f8dd91ef8d92d82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga251bf5c7391b67539653596adad31190"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga251bf5c7391b67539653596adad31190">Sequence::coalsim::pick_branch</a> (marginal::const_iterator beg, const int &amp;nsam, const double &amp;rtime)</td></tr>
<tr class="memdesc:ga251bf5c7391b67539653596adad31190"><td class="mdescLeft">&#160;</td><td class="mdescRight">pick a random branch of a marginal tree  <a href="#ga251bf5c7391b67539653596adad31190">More...</a><br/></td></tr>
<tr class="separator:ga251bf5c7391b67539653596adad31190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf275bccabacaf225fe538d3cfd7415d3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#gaf275bccabacaf225fe538d3cfd7415d3">Sequence::coalsim::get_all_descendants</a> (marginal::const_iterator beg, const int &amp;nsam, const int &amp;branch)</td></tr>
<tr class="memdesc:gaf275bccabacaf225fe538d3cfd7415d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the descendants of a branch on a marginal tree.  <a href="#gaf275bccabacaf225fe538d3cfd7415d3">More...</a><br/></td></tr>
<tr class="separator:gaf275bccabacaf225fe538d3cfd7415d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9913d3aabae0dcf75e447ff61404155c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga9913d3aabae0dcf75e447ff61404155c">Sequence::coalsim::is_descendant</a> (marginal::const_iterator beg, const int &amp;ind, const int &amp;branch)</td></tr>
<tr class="memdesc:ga9913d3aabae0dcf75e447ff61404155c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask if a tip of a tree is a descendant of a particular branch.  <a href="#ga9913d3aabae0dcf75e447ff61404155c">More...</a><br/></td></tr>
<tr class="separator:ga9913d3aabae0dcf75e447ff61404155c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a17f57753ba045fb00e008b086f59fa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga5a17f57753ba045fb00e008b086f59fa">Sequence::coalsim::total_time_on_arg</a> (const <a class="el" href="group__coalescent.html#gabf25e6e55ecf4ab56ffdaffcc69213e3">Sequence::coalsim::arg</a> &amp;sample_history, const int &amp;total_number_of_sites)</td></tr>
<tr class="memdesc:ga5a17f57753ba045fb00e008b086f59fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total time on an ancestral recombination graph.  <a href="#ga5a17f57753ba045fb00e008b086f59fa">More...</a><br/></td></tr>
<tr class="separator:ga5a17f57753ba045fb00e008b086f59fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga95ca27a218bc65bafa365720ce9ae0e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga95ca27a218bc65bafa365720ce9ae0e9"></a>
MAX_SEG_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga95ca27a218bc65bafa365720ce9ae0e9">Sequence::coalsim::MAX_SEGSITES</a> =200</td></tr>
<tr class="memdesc:ga95ca27a218bc65bafa365720ce9ae0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">controls allocation of simulated gametes You must define this in namespace <a class="el" href="namespaceSequence.html" title="The namespace in which this library resides. ">Sequence</a> in your program. A value of 200 works well. <br/></td></tr>
<tr class="separator:ga95ca27a218bc65bafa365720ce9ae0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72b16171adfc94478afd30fb088c15cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga72b16171adfc94478afd30fb088c15cf"></a>
MAX_SEG_T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__coalescent.html#ga72b16171adfc94478afd30fb088c15cf">Sequence::coalsim::MAX_SEGS_INC</a> =200</td></tr>
<tr class="memdesc:ga72b16171adfc94478afd30fb088c15cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">controls (re)allocation of simulated gametes You must define this in namespace <a class="el" href="namespaceSequence.html" title="The namespace in which this library resides. ">Sequence</a> in your program. A value of 100 works well <br/></td></tr>
<tr class="separator:ga72b16171adfc94478afd30fb088c15cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gabf25e6e55ecf4ab56ffdaffcc69213e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;marginal&gt; <a class="el" href="group__coalescent.html#gabf25e6e55ecf4ab56ffdaffcc69213e3">Sequence::coalsim::arg</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ancestral <a class="el" href="namespaceSequence_1_1Recombination.html" title="Methods dealing with recombination. ">Recombination</a> Graph. </p>
<p>An arg is an "ancestral recombination graph", which is a linked list of marginal histories.</p>
<dl class="section note"><dt>Note</dt><dd>The implementation of the crossover function ensures that the marginal trees are sorted in ascending order determined by <a class="el" href="structSequence_1_1coalsim_1_1marginal.html#a23884e37bc210e35f5beb0068c6dcb00">marginal::beg</a> </dd></dl>

<p>Definition at line <a class="el" href="SimTypes_8hpp_source.html#l00217">217</a> of file <a class="el" href="SimTypes_8hpp_source.html">SimTypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga23ef0fa48fefd60c2b0d0e709e433871"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt; std::vector&lt;double&gt;, std::vector&lt;std::string&gt; &gt; <a class="el" href="group__coalescent.html#ga23ef0fa48fefd60c2b0d0e709e433871">Sequence::coalsim::gamete_storage_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an object to store simulated gametes An object of this type will tend to exist in the calling environment of your program. If you are simulating a sample of n chromosomes, you would initialize the object as follows: </p>
<div class="fragment"><div class="line"><a class="code" href="group__coalescent.html#ga23ef0fa48fefd60c2b0d0e709e433871">gamete_storage_type</a> gamete_bucket( std::vector&lt;double&gt;(<a class="code" href="group__coalescent.html#ga95ca27a218bc65bafa365720ce9ae0e9">MAX_SEGSITES</a>,0.),</div>
<div class="line">std::vector&lt; std::string &gt;(n,std::string(<a class="code" href="group__coalescent.html#ga95ca27a218bc65bafa365720ce9ae0e9">MAX_SEGSITES</a>,<span class="charliteral">&#39;0&#39;</span>)) );</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="Mutation_8hpp_source.html#l00042">42</a> of file <a class="el" href="Mutation_8hpp_source.html">Mutation.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga44519e0a94e031435895434217198d25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::coalsim::add_S_inf_sites </td>
          <td>(</td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">marginal::const_iterator&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>first_snp_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_storage_type *&#160;</td>
          <td class="paramname"><em>gametes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add S segregating sites to sample with a particular marginal history, according to the infinitely-many sites model. </p>
<p>This routine places a fixed number of segregating sites on a marginal history that begins at position <em>beg</em> and ends at position <em>end-1</em>. Mutations are assigned positions randomly on the continuous, half-open interval [ beg/L,end/L ), where L = nsites-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as arguments </td></tr>
    <tr><td class="paramname">history</td><td>the history onto which mutations will be placed </td></tr>
    <tr><td class="paramname">tt</td><td>the total time on <em>history</em> </td></tr>
    <tr><td class="paramname">beg</td><td>the first site in the history (0 &lt;= beg &lt; nsites) </td></tr>
    <tr><td class="paramname">end</td><td>the last site in the history ( beg &lt; end &lt; nsites ) </td></tr>
    <tr><td class="paramname">nsam</td><td>the total sample size being simulated </td></tr>
    <tr><td class="paramname">nsites</td><td>the number of mutational sites simulated </td></tr>
    <tr><td class="paramname">S</td><td>the number of mutations to drop on <em>history</em> </td></tr>
    <tr><td class="paramname">first_snp_index</td><td>the index at which mutations will begin to be added into <em>gametes</em> </td></tr>
    <tr><td class="paramname">gametes</td><td>a container in which you are storing the mutations. Must be allocated in the calling environment. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00234">234</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga2a1ce0225764c480ee961c4852aeeba1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::coalsim::add_S_inf_sites </td>
          <td>(</td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">marginal::const_iterator&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>first_snp_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_storage_type *&#160;</td>
          <td class="paramname"><em>gametes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add S segregating sites to sample with a particular marginal history, according to the infinitely-many sites model. </p>
<p>This routine places a fixed number of segregating sites on a marginal history that begins at position <em>beg</em> and ends at position <em>end-1</em>. Mutations are assigned positions randomly on the continuous, half-open interval [ beg/L,end/L ), where L = nsites-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as arguments </td></tr>
    <tr><td class="paramname">history</td><td>the history onto which mutations will be placed </td></tr>
    <tr><td class="paramname">tt</td><td>the total time on <em>history</em> </td></tr>
    <tr><td class="paramname">beg</td><td>the first site in the history (0 &lt;= beg &lt; nsites) </td></tr>
    <tr><td class="paramname">end</td><td>the last site in the history ( beg &lt; end &lt; nsites ) </td></tr>
    <tr><td class="paramname">nsam</td><td>the total sample size being simulated </td></tr>
    <tr><td class="paramname">nsites</td><td>the number of mutational sites simulated </td></tr>
    <tr><td class="paramname">S</td><td>the number of mutations to drop on <em>history</em> </td></tr>
    <tr><td class="paramname">first_snp_index</td><td>the index at which mutations will begin to be added into <em>gametes</em> </td></tr>
    <tr><td class="paramname">gametes</td><td>a container in which you are storing the mutations. Must be allocated in the calling environment. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00270">270</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga336bd37e53e80cbfd5ccc6dfea45dcbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arg Sequence::coalsim::bottleneck </td>
          <td>(</td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uniform01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exponential_generator &amp;&#160;</td>
          <td class="paramname"><em>expo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; chromosome &gt; &amp;&#160;</td>
          <td class="paramname"><em>initialized_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const marginal &amp;&#160;</td>
          <td class="paramname"><em>initialized_marginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>exponential_recovery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>recovered_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coalescent simulation of a population bottleneck Simulate a single, bottlenecked, population according to the Wright-Fisher model without selection. The population can recover from the bottleneck either instantaneously ("stepwise bottleneck"), or according to an exponential growth model. For the case of a stepwise bottleneck, this function is equivalent to the following options in Dick Hudson's program "ms": -eN 0 recovered_size -eN tr f -eN (tr+d) 1. For the case where recovery from the bottleneck is by exponential growth, the equivalent "ms" options are: -eN 0 recovered_size -eG tr (log(recovered_size)-log(f))/d -eG (tr+d) 0 -eN (tr+d) 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>A binary function object (or equivalent) that returns a random deviate between a and b such that a &lt;= x &lt; b. a and b are the arguments to operator() of <em>uni</em> </td></tr>
    <tr><td class="paramname">uni01</td><td>A function object (or equivalent) whose operator() takes no arguments and returns a random deviate 0 &lt;= x &lt; 1. </td></tr>
    <tr><td class="paramname">expo</td><td>A unary function object whose operator() takes the mean of an exponential process as an argument and returns a deviate from an exponential distribution with that mean </td></tr>
    <tr><td class="paramname">initialized_sample</td><td>An initialized vector of chromosomes for a single population. For example, this may be the return value of init_sample. This object is used to copy-construct a non-const sample for the simulation </td></tr>
    <tr><td class="paramname">initialized_marginal</td><td>An initialized marginal tree of the appropriate sample size for the simulation. For example, the return value of init_marginal. </td></tr>
    <tr><td class="paramname">tr</td><td>The time at which the population recovers from the bottleneck. In units of 4N0 generations, where N0 is the effective size before the bottleneck. </td></tr>
    <tr><td class="paramname">d</td><td>The duration of the bottleneck, in units of 4N0 generations, where N0 is the effective size before the bottleneck. </td></tr>
    <tr><td class="paramname">f</td><td>Bottleneck severity. Define Nb as the effective size during the bottleneck, and N0 the effective size prior to the bottleneck. f=Nb/N0. </td></tr>
    <tr><td class="paramname">rho</td><td>The population recombination rate 4N0r. The number of "sites" simulated is not neccesary, as it can be obtained from initialized_sample[0].last()+1. </td></tr>
    <tr><td class="paramname">exponential_recovery</td><td>If true, the population recovers from the bottleneck according to an exponential growth model. If false, a stepwise bottleneck is assumed. </td></tr>
    <tr><td class="paramname">recovered_size</td><td>If 1, the population recovers to N0 at time <em>tr</em>. If 0.5, the population recovers to 1/2 the pre-bottleneck size, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ancestral recombination graph (arg) describing the sample history. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>d&gt;0 and tr&gt;0 and f&gt;0 and rho&gt;=0 and recovered_size&gt;0 and initialized_marginal.nsam == initialized_sample.size() </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Preconditions are checked by the assert macro, and are therefore disabled when compiling with -DNDEBUG. No checks or warnings are otherwised performed nor given. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="bottleneck_8cc-example.html#a3">bottleneck.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="DemographicModels_8tcc_source.html#l00228">228</a> of file <a class="el" href="DemographicModels_8tcc_source.html">DemographicModels.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga9802f55cdbf810f590825d196fb17a3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arg Sequence::coalsim::bottleneck </td>
          <td>(</td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uniform01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const exponential_generator &amp;&#160;</td>
          <td class="paramname"><em>expo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; chromosome &gt; &amp;&#160;</td>
          <td class="paramname"><em>initialized_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const marginal &amp;&#160;</td>
          <td class="paramname"><em>initialized_marginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>tr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>exponential_recovery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>recovered_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coalescent simulation of a population bottleneck Simulate a single, bottlenecked, population according to the Wright-Fisher model without selection. The population can recover from the bottleneck either instantaneously ("stepwise bottleneck"), or according to an exponential growth model. For the case of a stepwise bottleneck, this function is equivalent to the following options in Dick Hudson's program "ms": -eN 0 recovered_size -eN tr f -eN (tr+d) 1. For the case where recovery from the bottleneck is by exponential growth, the equivalent "ms" options are: -eN 0 recovered_size -eG tr (log(recovered_size)-log(f))/d -eG (tr+d) 0 -eN (tr+d) 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>A binary function object (or equivalent) that returns a random deviate between a and b such that a &lt;= x &lt; b. a and b are the arguments to operator() of <em>uni</em> </td></tr>
    <tr><td class="paramname">uni01</td><td>A function object (or equivalent) whose operator() takes no arguments and returns a random deviate 0 &lt;= x &lt; 1. </td></tr>
    <tr><td class="paramname">expo</td><td>A unary function object whose operator() takes the mean of an exponential process as an argument and returns a deviate from an exponential distribution with that mean </td></tr>
    <tr><td class="paramname">initialized_sample</td><td>An initialized vector of chromosomes for a single population. For example, this may be the return value of init_sample. This object is used to copy-construct a non-const sample for the simulation </td></tr>
    <tr><td class="paramname">initialized_marginal</td><td>An initialized marginal tree of the appropriate sample size for the simulation. For example, the return value of init_marginal. </td></tr>
    <tr><td class="paramname">tr</td><td>The time at which the population recovers from the bottleneck. In units of 4N0 generations, where N0 is the effective size before the bottleneck. </td></tr>
    <tr><td class="paramname">d</td><td>The duration of the bottleneck, in units of 4N0 generations, where N0 is the effective size before the bottleneck. </td></tr>
    <tr><td class="paramname">f</td><td>Bottleneck severity. Define Nb as the effective size during the bottleneck, and N0 the effective size prior to the bottleneck. f=Nb/N0. </td></tr>
    <tr><td class="paramname">rho</td><td>The population recombination rate 4N0r. The number of "sites" simulated is not neccesary, as it can be obtained from initialized_sample[0].last()+1. </td></tr>
    <tr><td class="paramname">exponential_recovery</td><td>If true, the population recovers from the bottleneck according to an exponential growth model. If false, a stepwise bottleneck is assumed. </td></tr>
    <tr><td class="paramname">recovered_size</td><td>If 1, the population recovers to N0 at time <em>tr</em>. If 0.5, the population recovers to 1/2 the pre-bottleneck size, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ancestral recombination graph (arg) describing the sample history. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>d&gt;0 and tr&gt;0 and f&gt;0 and rho&gt;=0 and recovered_size&gt;0 and initialized_marginal.nsam == initialized_sample.size() </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Preconditions are checked by the assert macro, and are therefore disabled when compiling with -DNDEBUG. No checks or warnings are otherwised performed nor given. </dd></dl>

<p>Definition at line <a class="el" href="DemographicModels_8tcc_source.html#l00265">265</a> of file <a class="el" href="DemographicModels_8tcc_source.html">DemographicModels.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga6fe3c0b20183faf7b3329d286b223c22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::coalsim::calculate_scales </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>fragments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; double, double &gt; &gt; *&#160;</td>
          <td class="paramname"><em>sample_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; double, double &gt; &gt; *&#160;</td>
          <td class="paramname"><em>mutation_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a helper function that rescales physical distance in base pairs to continuous distance on the interval 0,1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fragments</td><td>A vector of pairs, representing physical distance in bp. For each pair, the first element is the distance to the next fragment, and the second element is the length of the fragment. For example, two 1kb fragments separated by 10kb would be represented by the pairs (0,1000) (10000,1000). </td></tr>
    <tr><td class="paramname">sample_scale</td><td>This vector will be filled with values representing the positions of the fragments on the continuous interval, without any space betwen them. This is because we will actually do the simulation using a non-uniform genetic map to represent the high recombination rates between fragments </td></tr>
    <tr><td class="paramname">mutation_scale</td><td>This is a direct mapping of the data contained in <em>fragments</em> to the continuous scale, and can be used to rescale the positions of mutations </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a0">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html#l00064">64</a> of file <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html">CoalescentFragmentsRescaling.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gae0db60eb08eadab4d2cc9c3a4ccdf846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::coalsim::coalesce </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>ttl_nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>current_nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nlinks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; chromosome &gt; *&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arg *&#160;</td>
          <td class="paramname"><em>sample_history</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Common ancestor routine for coalescent simulation. Merges chromosome segments and updates marginal trees. </p>
<p>Common ancestor routine for coalescent simulation. This routine performs the merging of two lineages by a coalescent event. Such merges usually require two sorts of operations. The first is an update to the segments contained in a chromosome, and the second is an update of the nodes on a marginal tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>the time at which the coalecent event is occuring </td></tr>
    <tr><td class="paramname">ttl_nsam</td><td>the total sample size being simulated </td></tr>
    <tr><td class="paramname">current_nsam</td><td>the current sample size in the simulation </td></tr>
    <tr><td class="paramname">c1</td><td>the array index of the first chromosome involved in the coalescent event </td></tr>
    <tr><td class="paramname">c2</td><td>the array index of the second chromosome involved in the coalescent event </td></tr>
    <tr><td class="paramname">nsites</td><td>the total mutational length of the region begin simulated. In the language of Hudson (1983), this is the number of infinitely-many-alleles loci in the simulation. </td></tr>
    <tr><td class="paramname">nlinks</td><td>a pointer to the number of "links" currently in the simulation. A link is the region between two sites, such that a chromosome currently with k sites has k-1 links </td></tr>
    <tr><td class="paramname">sample</td><td>a pointer to the vector of chromosomes which makes up the sample </td></tr>
    <tr><td class="paramname">sample_history</td><td>a pointer to the ancestral recombination graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the decrease in current_nsam due to the coalescent event. Usually, the return value is 1. Sometimes, however, it is two, when the two chromosomes being merged have no ancestral material on the same marginal tree. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a9">fragments.cc</a>, and <a class="el" href="freerec_8cc-example.html#a8">freerec.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentCoalesce_8cc_source.html#l00054">54</a> of file <a class="el" href="CoalescentCoalesce_8cc_source.html">CoalescentCoalesce.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga9b2ec8b27b3800757f2e360f6c000499"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::coalsim::crossover </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>current_nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>chromo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; chromosome &gt; *&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arg *&#160;</td>
          <td class="paramname"><em>sample_history</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespaceSequence_1_1Recombination.html" title="Methods dealing with recombination. ">Recombination</a> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_nsam</td><td>the current sample size in the simulation </td></tr>
    <tr><td class="paramname">chromo</td><td>the chromosome on which the crossover event is to occur </td></tr>
    <tr><td class="paramname">pos</td><td>the crossover event happens between sites pos and pos+1 (0&lt;= pos &lt; nsites) </td></tr>
    <tr><td class="paramname">sample</td><td>the sample of chromosomes being simulated </td></tr>
    <tr><td class="paramname">sample_history</td><td>the genealogy of the sample </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of links lost due to the crossover event </dd></dl>
<dl class="section note"><dt>Note</dt><dd>as the type arg is based on std::list, and insertions into lists are done in constant time, this routine keeps the ancestral recombination graph sorted </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a11">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentRecombination_8cc_source.html#l00084">84</a> of file <a class="el" href="CoalescentRecombination_8cc_source.html">CoalescentRecombination.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga8f38052a5261d2ea0cd55de41371c507"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arg Sequence::coalsim::exponential_change </td>
          <td>(</td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uniform01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exponential_generator &amp;&#160;</td>
          <td class="paramname"><em>expo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; chromosome &gt; &amp;&#160;</td>
          <td class="paramname"><em>initialized_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const marginal &amp;&#160;</td>
          <td class="paramname"><em>initialized_marginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>t_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>t_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>size_at_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coalescent simulation of exponential change in population size Simulate a single population whose size changes exponentially during some period of time. The relevant command line options for Hudson's program "ms" would be: -eG t_begin G -eG t_end 0. -eN t_end size_at_end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>A binary function object (or equivalent) that returns a random deviate between a and b such that a &lt;= x &lt; b. a and b are the arguments to operator() of <em>uni</em> </td></tr>
    <tr><td class="paramname">uni01</td><td>A function object (or equivalent) whose operator() takes no arguments and returns a random deviate 0 &lt;= x &lt; 1. </td></tr>
    <tr><td class="paramname">expo</td><td>A unary function object whose operator() takes the mean of an exponential process as an argument and returns a deviate from an exponential distribution with that mean </td></tr>
    <tr><td class="paramname">initialized_sample</td><td>An initialized vector of chromosomes for a single population. For example, this may be the return value of init_sample. This object is used to copy-construct a non-const sample for the simulation </td></tr>
    <tr><td class="paramname">initialized_marginal</td><td>An initialized marginal tree of the appropriate sample size for the simulation. For example, the return value of init_marginal. </td></tr>
    <tr><td class="paramname">G</td><td>The rate of exponential change in effective size. If G&gt;0, the population grows exponentially (forwards in time). If G&lt;0, it shrinks (again, forwards in time). </td></tr>
    <tr><td class="paramname">t_begin</td><td>The time in the past (in units of 4Ne generations) at which population size change begins (i.e., ends, moving forward in time) </td></tr>
    <tr><td class="paramname">t_end</td><td>The time in the past (in units of 4Ne generations) at which populations size change ends (begins forward in time) </td></tr>
    <tr><td class="paramname">rho</td><td>The population recombination rate 4N0r. The number of "sites" simulated is not neccesary, as it can be obtained from initialized_sample[0].last()+1. </td></tr>
    <tr><td class="paramname">size_at_end</td><td>At time <em>t_end</em> in the past, the population size is set to <em>size_at_end</em>. If <em>size_at_end</em> = 1, the population is set to the same size that is was at t=0 (i.e. the beginning of the simulation). If <em>size_at_and</em> &lt; 0, the population size is not adjusted at <em>t_end</em>. In other words, it is left at whatever it grew or shrank to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ancestral recombination graph (arg) describing the sample history. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>t_begin&gt;=0 and t_end&gt;=0 and t_end&gt;=t_begin and rho&gt;=0 and initialized_marginal.nsam == initialized_sample.size() </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Preconditions are checked by the assert macro, and are therefore disabled when compiling with -DNDEBUG. No checks or warnings are otherwised performed nor given. </dd></dl>

<p>Definition at line <a class="el" href="DemographicModels_8tcc_source.html#l00302">302</a> of file <a class="el" href="DemographicModels_8tcc_source.html">DemographicModels.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="gabcd24e6876eaab80d2126cea9e043c80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">arg Sequence::coalsim::exponential_change </td>
          <td>(</td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uniform01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const exponential_generator &amp;&#160;</td>
          <td class="paramname"><em>expo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; chromosome &gt; &amp;&#160;</td>
          <td class="paramname"><em>initialized_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const marginal &amp;&#160;</td>
          <td class="paramname"><em>initialized_marginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>t_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>t_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>size_at_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coalescent simulation of exponential change in population size Simulate a single population whose size changes exponentially during some period of time. The relevant command line options for Hudson's program "ms" would be: -eG t_begin -eG t_end 0. -eN t_end size_at_end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>A binary function object (or equivalent) that returns a random deviate between a and b such that a &lt;= x &lt; b. a and b are the arguments to operator() of <em>uni</em> </td></tr>
    <tr><td class="paramname">uni01</td><td>A function object (or equivalent) whose operator() takes no arguments and returns a random deviate 0 &lt;= x &lt; 1. </td></tr>
    <tr><td class="paramname">expo</td><td>A unary function object whose operator() takes the mean of an exponential process as an argument and returns a deviate from an exponential distribution with that mean </td></tr>
    <tr><td class="paramname">initialized_sample</td><td>An initialized vector of chromosomes for a single population. For example, this may be the return value of init_sample. This object is used to copy-construct a non-const sample for the simulation </td></tr>
    <tr><td class="paramname">initialized_marginal</td><td>An initialized marginal tree of the appropriate sample size for the simulation. For example, the return value of init_marginal. </td></tr>
    <tr><td class="paramname">G</td><td>The rate of exponential change in effective size. If G&gt;0, the population grows exponentially (forwards in time). If G&lt;0, it shrinks (again, forwards in time). </td></tr>
    <tr><td class="paramname">t_begin</td><td>The time in the past (in units of 4Ne generations) at which population size change begins (i.e., ends, moving forward in time) </td></tr>
    <tr><td class="paramname">t_end</td><td>The time in the past (in units of 4Ne generations) at which populations size change ends (begins forward in time) </td></tr>
    <tr><td class="paramname">rho</td><td>The population recombination rate 4N0r. The number of "sites" simulated is not neccesary, as it can be obtained from initialized_sample[0].last()+1. </td></tr>
    <tr><td class="paramname">size_at_end</td><td>At time <em>t_end</em> in the past, the population size is set to <em>size_at_end</em>. If <em>size_at_end</em> = 1, the population is set to the same size that is was at t=0 (i.e. the beginning of the simulation). If <em>size_at_and</em> &lt; 0, the population size is not adjusted at <em>t_end</em>. In other words, it is left at whatever it grew or shrank to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ancestral recombination graph (arg) describing the sample history. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>t_begin&gt;=0 and t_end&gt;=0 and t_end&gt;=t_begin and rho&gt;=0 and initialized_marginal.nsam == initialized_sample.size() </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Preconditions are checked by the assert macro, and are therefore disabled when compiling with -DNDEBUG. No checks or warnings are otherwised performed nor given. </dd></dl>

<p>Definition at line <a class="el" href="DemographicModels_8tcc_source.html#l00338">338</a> of file <a class="el" href="DemographicModels_8tcc_source.html">DemographicModels.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="gaf275bccabacaf225fe538d3cfd7415d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Sequence::coalsim::get_all_descendants </td>
          <td>(</td>
          <td class="paramtype">marginal::const_iterator&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>branch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all the descendants of a branch on a marginal tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>A pointer to the beginning of a marginal tree, i.e. the return value of <a class="el" href="structSequence_1_1coalsim_1_1marginal.html#a6a62002818a9358cc410b4f2d8b80476">marginal::begin()</a> </td></tr>
    <tr><td class="paramname">nsam</td><td>the total sample size simulated </td></tr>
    <tr><td class="paramname">branch</td><td>the index of the branch of the tree whose descendants you want. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>branch must be &lt;= 2*nsam-2, which is checked by assert </dd></dl>

<p>Definition at line <a class="el" href="CoalescentTreeOperations_8cc_source.html#l00082">82</a> of file <a class="el" href="CoalescentTreeOperations_8cc_source.html">CoalescentTreeOperations.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga40aa548b1d119b44605da893c5d7cffa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename poisson_generator , typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::coalsim::infinite_sites </td>
          <td>(</td>
          <td class="paramtype">poisson_generator &amp;&#160;</td>
          <td class="paramname"><em>poiss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_storage_type *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the infinitely-many sites mutation model to an ancetral recombination graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poiss</td><td>a Poisson random number generator which takes the mean of the poisson as an argument </td></tr>
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as an argument </td></tr>
    <tr><td class="paramname">gametes</td><td>object in which to store the simulated gametes </td></tr>
    <tr><td class="paramname">nsites</td><td>the length of the region begin simulated </td></tr>
    <tr><td class="paramname">history</td><td>the list of marginal histories for the sample </td></tr>
    <tr><td class="paramname">theta</td><td>the coalescent-scaled mutation rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of mutations placed on the tree </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="freerec_8cc-example.html#a9">freerec.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00307">307</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga8efceef9b6eff28618ae51bbf1197f1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename poisson_generator , typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::coalsim::infinite_sites </td>
          <td>(</td>
          <td class="paramtype">const poisson_generator &amp;&#160;</td>
          <td class="paramname"><em>poiss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_storage_type *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the infinitely-many sites mutation model to an ancetral recombination graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poiss</td><td>a Poisson random number generator which takes the mean of the poisson as an argument </td></tr>
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as an argument </td></tr>
    <tr><td class="paramname">gametes</td><td>object in which to store the simulated gametes </td></tr>
    <tr><td class="paramname">nsites</td><td>the length of the region begin simulated </td></tr>
    <tr><td class="paramname">history</td><td>the list of marginal histories for the sample </td></tr>
    <tr><td class="paramname">theta</td><td>the coalescent-scaled mutation rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of mutations placed on the tree </dd></dl>

<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00330">330</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="gab0be279dc4a03cde60ee2a649b620a63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::coalsim::infinite_sites </td>
          <td>(</td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_storage_type *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>total_times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>segsites</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as an argument </td></tr>
    <tr><td class="paramname">gametes</td><td>object in which to store the simulated gametes </td></tr>
    <tr><td class="paramname">nsites</td><td>the length of the region begin simulated </td></tr>
    <tr><td class="paramname">history</td><td>the list of marginal histories for the sample </td></tr>
    <tr><td class="paramname">total_times</td><td>the total times on each marginal tree in <em>history</em> </td></tr>
    <tr><td class="paramname">segsites</td><td>the number of segregating sites to place on each tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of mutations placed on the tree </dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>total_times</em> and <em>segsites</em> must contain a number of elements equal to history.size() </dd></dl>

<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00352">352</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga78d7f92f43b376948eade29e38f95af8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::coalsim::infinite_sites </td>
          <td>(</td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gamete_storage_type *&#160;</td>
          <td class="paramname"><em>gametes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>total_times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>segsites</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as an argument </td></tr>
    <tr><td class="paramname">gametes</td><td>object in which to store the simulated gametes </td></tr>
    <tr><td class="paramname">nsites</td><td>the length of the region begin simulated </td></tr>
    <tr><td class="paramname">history</td><td>the list of marginal histories for the sample </td></tr>
    <tr><td class="paramname">total_times</td><td>the total times on each marginal tree in <em>history</em> </td></tr>
    <tr><td class="paramname">segsites</td><td>the number of segregating sites to place on each tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of mutations placed on the tree </dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>total_times</em> and <em>segsites</em> must contain a number of elements equal to history.size() </dd></dl>

<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00376">376</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="gabc06180851946ec2190ae93785a8a0a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename poisson_generator , typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SimData Sequence::coalsim::infinite_sites_sim_data </td>
          <td>(</td>
          <td class="paramtype">poisson_generator &amp;&#160;</td>
          <td class="paramname"><em>poiss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the infinitely-many sites mutation model to an ancetral recombination graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poiss</td><td>a Poisson random number generator which takes the mean of the poisson as an argument </td></tr>
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as an argument </td></tr>
    <tr><td class="paramname">nsites</td><td>the length of the region begin simulated </td></tr>
    <tr><td class="paramname">history</td><td>the list of marginal histories for the sample </td></tr>
    <tr><td class="paramname">theta</td><td>the coalescent-scaled mutation rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object of type <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> that represent the sample. (the gametes are also stored in <em>gametes</em>). The <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> object can be passed directly into class <a class="el" href="classSequence_1_1PolySIM.html" title="Analysis of coalescent simulation data. ">PolySIM</a> for analysis </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="bottleneck_8cc-example.html#a6">bottleneck.cc</a>, and <a class="el" href="fragments_8cc-example.html#a14">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00401">401</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="gaef36909309a8ce1fd7ff4da9ffe1aed3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename poisson_generator , typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SimData Sequence::coalsim::infinite_sites_sim_data </td>
          <td>(</td>
          <td class="paramtype">const poisson_generator &amp;&#160;</td>
          <td class="paramname"><em>poiss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the infinitely-many sites mutation model to an ancetral recombination graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poiss</td><td>a Poisson random number generator which takes the mean of the poisson as an argument </td></tr>
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as an argument </td></tr>
    <tr><td class="paramname">nsites</td><td>the length of the region begin simulated </td></tr>
    <tr><td class="paramname">history</td><td>the list of marginal histories for the sample </td></tr>
    <tr><td class="paramname">theta</td><td>the coalescent-scaled mutation rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object of type <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> that represent the sample. (the gametes are also stored in <em>gametes</em>). The <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> object can be passed directly into class <a class="el" href="classSequence_1_1PolySIM.html" title="Analysis of coalescent simulation data. ">PolySIM</a> for analysis </dd></dl>

<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00424">424</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="gab0c8f4db37c99fb894337fbcce910dd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SimData Sequence::coalsim::infinite_sites_sim_data </td>
          <td>(</td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>total_times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>segsites</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as an argument </td></tr>
    <tr><td class="paramname">nsites</td><td>the length of the region begin simulated </td></tr>
    <tr><td class="paramname">history</td><td>the list of marginal histories for the sample </td></tr>
    <tr><td class="paramname">total_times</td><td>the total times on each marginal tree in <em>history</em> </td></tr>
    <tr><td class="paramname">segsites</td><td>the number of segregating sites to place on each tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object of type <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> that represent the sample. for analysis </dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>total_times</em> and <em>segsites</em> must contain a number of elements equal to history.size() </dd></dl>

<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00446">446</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga84db82131b381d35d77286be8ace562e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SimData Sequence::coalsim::infinite_sites_sim_data </td>
          <td>(</td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arg &amp;&#160;</td>
          <td class="paramname"><em>history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>total_times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>segsites</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the infinitely-many sites mutation model to an ancetral recombination graph with a fixed number of segregating sites. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a uniform random number generator that takes two doubles as an argument </td></tr>
    <tr><td class="paramname">nsites</td><td>the length of the region begin simulated </td></tr>
    <tr><td class="paramname">history</td><td>the list of marginal histories for the sample </td></tr>
    <tr><td class="paramname">total_times</td><td>the total times on each marginal tree in <em>history</em> </td></tr>
    <tr><td class="paramname">segsites</td><td>the number of segregating sites to place on each tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an object of type <a class="el" href="classSequence_1_1SimData.html" title="Data from coalescent simulations. ">SimData</a> that represent the sample. for analysis </dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>total_times</em> and <em>segsites</em> must contain a number of elements equal to history.size() </dd></dl>

<p>Definition at line <a class="el" href="Mutation_8tcc_source.html#l00469">469</a> of file <a class="el" href="Mutation_8tcc_source.html">Mutation.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="gaef932eb70718010392dd1f5e079889ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">marginal Sequence::coalsim::init_marginal </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple function to initialize a marginal tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nsam</td><td>the total sample size (i.e. summed over all populations) that you want to simulate </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="bottleneck_8cc-example.html#a2">bottleneck.cc</a>, <a class="el" href="fragments_8cc-example.html#a5">fragments.cc</a>, <a class="el" href="freerec_8cc-example.html#a3">freerec.cc</a>, and <a class="el" href="msmm_8cc-example.html#a5">msmm.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentInitialize_8cc_source.html#l00062">62</a> of file <a class="el" href="CoalescentInitialize_8cc_source.html">CoalescentInitialize.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga19b90389f6021ec39447c8119d3c1adb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; chromosome &gt; Sequence::coalsim::init_sample </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pop_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple function to initialize a sample of chromosomes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pop_config</td><td>For a k-population model, this vector contains the sample size for each pop. Individuals are labeled as beloning to population 0 to k-1, in the order specified in this vector </td></tr>
    <tr><td class="paramname">nsites</td><td>The number of sites at which mutations occur. For a k-site model, recombination occurs at any of the k-1 "links" between sites. Eaach chromosome is assigned a single segment starting at position 0 and ending at nsites-1. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="bottleneck_8cc-example.html#a0">bottleneck.cc</a>, <a class="el" href="fragments_8cc-example.html#a3">fragments.cc</a>, <a class="el" href="freerec_8cc-example.html#a6">freerec.cc</a>, and <a class="el" href="msmm_8cc-example.html#a3">msmm.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentInitialize_8cc_source.html#l00031">31</a> of file <a class="el" href="CoalescentInitialize_8cc_source.html">CoalescentInitialize.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga97cb42aca9d2e63e3d9a5ef949fdbde2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Sequence::coalsim::integrate_genetic_map </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; chromosome &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>current_nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>genetic_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>reclens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When simulating non-uniform recombination rates, the probability of recombination at each point in the simulation needs to be obtained by integrating over the genetic map and the current sample configuration. This function does that. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample</td><td>the vector containing the current state of all chromosomes in the sample </td></tr>
    <tr><td class="paramname">current_nsam</td><td>the current sample size in the simulation </td></tr>
    <tr><td class="paramname">genetic_map</td><td>a vector containing rho/"link" for each link in the sample. For the i-th base-pair in the chromosome, the "link" is the "space between" positions i and i+1. The value of genetic_map[i] is therefore 4Nr between site i and i+1 (sometimes called 4Nr/"site"). </td></tr>
    <tr><td class="paramname">reclens</td><td>a vector of doubles. This vector will be resized to <em>current_nsam</em> in this function, and filled with <em>current_nsam</em> values, each of which is the sum(genetic_map[beg],genetic_map[end-1]) for each chromosome in the sample, where beg and end are the first and last positions in each chromosome. These data are needed by the function pick_spot (<a class="el" href="Coalescent_2Recombination_8hpp_source.html">Sequence/Coalescent/Recombination.hpp</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cummulative recombination rate in the sample, which is obtained by integrating over the ancestral material in the sample and the genetic map. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a7">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html#l00168">168</a> of file <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html">CoalescentFragmentsRescaling.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga9913d3aabae0dcf75e447ff61404155c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sequence::coalsim::is_descendant </td>
          <td>(</td>
          <td class="paramtype">marginal::const_iterator&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>branch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask if a tip of a tree is a descendant of a particular branch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>A pointer to the beginning of a marginal tree, i.e. the return value of <a class="el" href="structSequence_1_1coalsim_1_1marginal.html#a6a62002818a9358cc410b4f2d8b80476">marginal::begin()</a> </td></tr>
    <tr><td class="paramname">ind</td><td>the index of the putative descendant node </td></tr>
    <tr><td class="paramname">branch</td><td>the index of the branch of the tree which may be the ancestor of <em>ind</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does not check whether ind or branch go out of bounds, and so the programmer must ensure that both values are &lt;= 2*nsam-2, where nsam is the total sample size simulated </dd></dl>

<p>Definition at line <a class="el" href="CoalescentTreeOperations_8cc_source.html#l00106">106</a> of file <a class="el" href="CoalescentTreeOperations_8cc_source.html">CoalescentTreeOperations.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga3356506cf30cbfc7193a17f206d0de9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sequence::coalsim::isseg </td>
          <td>(</td>
          <td class="paramtype">chromosome::const_iterator&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>nsegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ask if a chromosome beginning at seg and containing nsegs contains a segment containing the position pos </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>a pointer to a segment of a chromosome (this should be the 1st segment, such as the return value of <a class="el" href="structSequence_1_1coalsim_1_1chromosome.html#abcafee5062a8767aa4a0b5f8234957c8">chromosome::begin()</a>) </td></tr>
    <tr><td class="paramname">nsegs</td><td>the number of segs in the chromosome pointed to by <em>seg</em> </td></tr>
    <tr><td class="paramname">offset</td><td>a pointer to an integer. This integer is used for repeated pointer arithmetic, and should be initalized to 0 before the first call. </td></tr>
    <tr><td class="paramname">pos</td><td>a position a long a chromosome. This function asks if pos is contained in the ancestral material of the chromosome whose segments begin at <em>seg</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a segment exists that contains the point pos </dd></dl>
<dl class="section note"><dt>Note</dt><dd>only used by the function coalesce </dd></dl>

<p>Definition at line <a class="el" href="CoalescentCoalesce_8cc_source.html#l00030">30</a> of file <a class="el" href="CoalescentCoalesce_8cc_source.html">CoalescentCoalesce.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga6e904076ec7e35caabd2a69e3dffa297"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator , typename uniform01_generator , typename exponential_generator , typename poisson_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSequence_1_1SimData.html">Sequence::SimData</a> Sequence::coalsim::neutral_sample </td>
          <td>(</td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uniform01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exponential_generator &amp;&#160;</td>
          <td class="paramname"><em>expo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">poisson_generator &amp;&#160;</td>
          <td class="paramname"><em>poiss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsites</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; chromosome &gt; *&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arg *&#160;</td>
          <td class="paramname"><em>sample_history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>max_chromosomes</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>max_chromosomes_inc</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple function to generate samples under a neutral equilibrium model. </p>
<p>A simple function to generate samples under a neutral equilibrium model with infinite-sites mutation and a constant recombination rate accross the region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a function/object capable of returning a random double uniformly from [0,k) </td></tr>
    <tr><td class="paramname">uni01</td><td>a function/object capable of returning a random probability uniformly from [0,1) </td></tr>
    <tr><td class="paramname">expo</td><td>a function/object capable of returning an exponentially distributed random variable. The function must take a single double as an argument, which is the mean of the exponential distribution </td></tr>
    <tr><td class="paramname">poiss</td><td>a function/object capable of returning an poisson distributed random variable. The function must take a single double as an argument, which is the mean of the poisson distribution </td></tr>
    <tr><td class="paramname">theta</td><td>4Nu, the coalescent-scaled mutation rate </td></tr>
    <tr><td class="paramname">rho</td><td>4Nr, the recombination rate for the whole region </td></tr>
    <tr><td class="paramname">nsites</td><td>the number of mutational sites to simulate. <a class="el" href="namespaceSequence_1_1Recombination.html" title="Methods dealing with recombination. ">Recombination</a> is equally likely between any two sites. </td></tr>
    <tr><td class="paramname">nsites</td><td>the total sample size. (There is no population structure in this routine) </td></tr>
    <tr><td class="paramname">sample</td><td>A pointer to the sample of chromosomes you wish to simulate. This must be properly initialized, for example using the function init_sample in &lt;<a class="el" href="Initialize_8hpp_source.html">Sequence/Coalescent/Initialize.hpp</a>&gt; </td></tr>
    <tr><td class="paramname">sample_history</td><td>a pointer to the ancestral recombination graph. This must be initialized in the calling enviroment. In general, you can use init_marginal in &lt;<a class="el" href="Initialize_8hpp_source.html">Sequence/Coalescent/Initialize.hpp</a>&gt; </td></tr>
    <tr><td class="paramname">max_chromosomes</td><td>This is a pointer to an integer in the calling environment which you can use to reserve memory in the array containing the sample of chromosomes. If the size of <em>sample</em> ever gets larger than this, max_chromosomes is incremented by <em>max_chromosomes_inc</em> </td></tr>
    <tr><td class="paramname">max_chromosomes_inc</td><td>the amount by which to increment <em>max_chromosomes</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function does require a bit of work to use, although not much. Please see the example code that comes with the library, in particular ms&ndash;.cc </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="msmm_8cc-example.html#a7">msmm.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="NeutralSample_8hpp_source.html#l00017">17</a> of file <a class="el" href="NeutralSample_8hpp_source.html">NeutralSample.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga540749697bfc988d4b6270d9fff01cf1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; Sequence::coalsim::pick2 </td>
          <td>(</td>
          <td class="paramtype">uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a random number function/object capable of returning a double-precision random number between 0 and <em>nsam-1</em> </td></tr>
    <tr><td class="paramname">nsam</td><td>the current sample size in the simulation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of integers which contains the indexes of two chromosomes in <em>sample</em> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a8">fragments.cc</a>, and <a class="el" href="freerec_8cc-example.html#a7">freerec.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="Coalesce_8tcc_source.html#l00091">91</a> of file <a class="el" href="Coalesce_8tcc_source.html">Coalesce.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="gae2e070750d8215e1b784401daddd187f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; Sequence::coalsim::pick2 </td>
          <td>(</td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>a random number function/object capable of returning a double-precision random number between 0 and <em>nsam-1</em> </td></tr>
    <tr><td class="paramname">nsam</td><td>the current sample size in the simulation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of integers which contains the indexes of two chromosomes in <em>sample</em> </dd></dl>

<p>Definition at line <a class="el" href="Coalesce_8tcc_source.html#l00104">104</a> of file <a class="el" href="Coalesce_8tcc_source.html">Coalesce.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga52b664a290b8288678cd9e3fd46b379d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; Sequence::coalsim::pick2_in_deme </td>
          <td>(</td>
          <td class="paramtype">const uniform_generator &amp;&#160;</td>
          <td class="paramname"><em>uni</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structSequence_1_1coalsim_1_1chromosome.html">Sequence::coalsim::chromosome</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>current_nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>deme_nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>deme</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose two random chromosomes from the same deme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni</td><td>A random number generator taking two arguments, a and b, and returning a random variable distributed uniformly over [a,b) </td></tr>
    <tr><td class="paramname">sample</td><td>The current state of the simulated sample </td></tr>
    <tr><td class="paramname">current_nsam</td><td>The total sample size being simuled (the sum of sample sizes over all demes) </td></tr>
    <tr><td class="paramname">deme_nsam</td><td>The sample size of the deme from which you wish to sample </td></tr>
    <tr><td class="paramname">deme</td><td>The index ( 0 &lt;= deme &lt; # populations ) of the deme from which you wish to sample </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of integers which contains the indexes of two chromosomes in <em>sample</em> </dd></dl>

<p>Definition at line <a class="el" href="Coalesce_8tcc_source.html#l00070">70</a> of file <a class="el" href="Coalesce_8tcc_source.html">Coalesce.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga251bf5c7391b67539653596adad31190"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::coalsim::pick_branch </td>
          <td>(</td>
          <td class="paramtype">marginal::const_iterator&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>rtime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pick a random branch of a marginal tree </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>A pointer to the beginning of a marginal tree, i.e. the return value of <a class="el" href="structSequence_1_1coalsim_1_1marginal.html#a6a62002818a9358cc410b4f2d8b80476">marginal::begin()</a> </td></tr>
    <tr><td class="paramname">nsam</td><td>the total sample size simulated </td></tr>
    <tr><td class="paramname">rtime</td><td>a (preferably random) double between 0 and the total_time on the marginal tree from which <em>beg</em> is the iterator </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="CoalescentTreeOperations_8cc_source.html#l00055">55</a> of file <a class="el" href="CoalescentTreeOperations_8cc_source.html">CoalescentTreeOperations.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gaeead0752500575b9483f54965ba9b3ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform01_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; Sequence::coalsim::pick_spot </td>
          <td>(</td>
          <td class="paramtype">uniform01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>total_reclen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>reclens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; chromosome &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>sample_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>current_nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rec_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Picks a positions amongst all chromosomes at which a recombination event will occur, based on an arbitrary genetic map </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni01</td><td>a function/object which takes no arguments and can return a U[0,1) </td></tr>
    <tr><td class="paramname">total_reclen</td><td>the total recombination length of all chromosomes in the sample </td></tr>
    <tr><td class="paramname">reclens</td><td>a vector of the proportion of <em>total_reclen</em> contributed by each chromosome. This needs to be ordered in the same order as <em>sample_begin</em> to (<em>sample_begin</em> + <em>current_nsam</em> - 1) </td></tr>
    <tr><td class="paramname">sample_begin</td><td>an iterator pointing to the beginning of the sample </td></tr>
    <tr><td class="paramname">current_nsam</td><td>the current sample size in the simulation </td></tr>
    <tr><td class="paramname">rec_map</td><td>an array of probabilities describing the recombination map. The map is completely up to the programmer, and it is not checked for sanity at all in this function. For a region of k sites, indexes 0 to k-2 of this array should be filled. The i-th element should contain the probability that a crossover occurs between position i and i+1. The sum of all elements should be 1, such that the array describes the recombination map in terms of a probability distribution function. An example of how to do this is in the file examples/msbeta.cc that comes with the source for this library. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of integers containing the index of the recombinant chromosome (.first), and the position at which the crossover will occur (.second) </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a10">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="Recombination_8tcc_source.html#l00055">55</a> of file <a class="el" href="Recombination_8tcc_source.html">Recombination.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga9f0cb180d2cee65c58c8ae1c973e709d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename uniform01_generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; Sequence::coalsim::pick_spot </td>
          <td>(</td>
          <td class="paramtype">const uniform01_generator &amp;&#160;</td>
          <td class="paramname"><em>uni01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>total_reclen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>reclens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; chromosome &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>sample_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>current_nsam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rec_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Picks a positions amongst all chromosomes at which a recombination event will occur, based on an arbitrary genetic map </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uni01</td><td>a function/object which takes no arguments and can return a U[0,1) </td></tr>
    <tr><td class="paramname">total_reclen</td><td>the total recombination length of all chromosomes in the sample </td></tr>
    <tr><td class="paramname">reclens</td><td>a vector of the proportion of <em>total_reclen</em> contributed by each chromosome. This needs to be ordered in the same order as <em>sample_begin</em> to (<em>sample_begin</em> + <em>current_nsam</em> - 1) </td></tr>
    <tr><td class="paramname">sample_begin</td><td>an iterator pointing to the beginning of the sample </td></tr>
    <tr><td class="paramname">current_nsam</td><td>the current sample size in the simulation </td></tr>
    <tr><td class="paramname">rec_map</td><td>an array of probabilities describing the recombination map. The map is completely up to the programmer, and it is not checked for sanity at all in this function. For a region of k sites, indexes 0 to k-2 of this array should be filled. The i-th element should contain the probability that a crossover occurs between position i and i+1. The sum of all elements should be 1, such that the array describes the recombination map in terms of a probability distribution function. An example of how to do this is in the file examples/msbeta.cc that comes with the source for this library. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of integers containing the index of the recombinant chromosome (.first), and the position at which the crossover will occur (.second) </dd></dl>

<p>Definition at line <a class="el" href="Recombination_8tcc_source.html#l00085">85</a> of file <a class="el" href="Recombination_8tcc_source.html">Recombination.tcc</a>.</p>

</div>
</div>
<a class="anchor" id="ga18ec6185c7d04ddeaea5cc3fd6db674a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; Sequence::coalsim::pick_uniform_spot </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>random_01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nlinks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; chromosome &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>sample_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>current_nsam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pick a crossover point for the model where recombination rates are constant across a recion. Picks a positions uniformly amongst all chromosomes at which a recombination event will occur. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">random_01</td><td>a random uniform deviate U[0,1) </td></tr>
    <tr><td class="paramname">nlinks</td><td>the number of links currently in the simulation </td></tr>
    <tr><td class="paramname">sample_begin</td><td>an iterator pointing to the beginning of the sample </td></tr>
    <tr><td class="paramname">current_nsam</td><td>the current sample size in the simulation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of integers containing the index of the recombinant chromosome (.first), and the position at which the crossover will occur (.second) </dd></dl>

<p>Definition at line <a class="el" href="CoalescentRecombination_8cc_source.html#l00052">52</a> of file <a class="el" href="CoalescentRecombination_8cc_source.html">CoalescentRecombination.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gad4e2444231cd36ed90653671b0d1197c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sequence::coalsim::rescale_mutation_positions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSequence_1_1SimData.html">Sequence::SimData</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mutation_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rescales the positions of the mutations in <em>d</em> from the scale given in <em>sample_scale</em> to that given in <em>mutation_scale</em>. </p>
<dl class="section note"><dt>Note</dt><dd>See documentation for calcualate_scales </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a15">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html#l00107">107</a> of file <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html">CoalescentFragmentsRescaling.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gae7f5707d2a650dbd3021e2a7403942b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::coalsim::sample_length </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>fragments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When simulating partially linked regions, return the total length of sample material that we are simulating. </p>
<dl class="section return"><dt>Returns</dt><dd>The sum of fragments[i].second for i=0 to i=fragments.size()-1 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a1">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html#l00032">32</a> of file <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html">CoalescentFragmentsRescaling.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gac6f384ac658344ff44f4413b1a77a34e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Sequence::coalsim::total_length </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>fragments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When simulating partially linked regions, return the total length of the region. </p>
<dl class="section return"><dt>Returns</dt><dd>The sum of fragments[i].first + fragments[i].second for i=0 to i=fragments.size()-1 </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="fragments_8cc-example.html#a2">fragments.cc</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html#l00048">48</a> of file <a class="el" href="CoalescentFragmentsRescaling_8cc_source.html">CoalescentFragmentsRescaling.cc</a>.</p>

</div>
</div>
<a class="anchor" id="gad0ff9c3e23f97cb0f8dd91ef8d92d82a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Sequence::coalsim::total_time </td>
          <td>(</td>
          <td class="paramtype">const marginal::const_iterator&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nsam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate total time on a marginal tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>A pointer to the beginning of a marginal tree, i.e. the return value of <a class="el" href="structSequence_1_1coalsim_1_1marginal.html#a6a62002818a9358cc410b4f2d8b80476">marginal::begin()</a> </td></tr>
    <tr><td class="paramname">nsam</td><td>the total sample size simulated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total time on the tree. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The scaling of time in the simulation is up to you </dd></dl>

<p>Definition at line <a class="el" href="CoalescentTreeOperations_8cc_source.html#l00033">33</a> of file <a class="el" href="CoalescentTreeOperations_8cc_source.html">CoalescentTreeOperations.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ga5a17f57753ba045fb00e008b086f59fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Sequence::coalsim::total_time_on_arg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__coalescent.html#gabf25e6e55ecf4ab56ffdaffcc69213e3">Sequence::coalsim::arg</a> &amp;&#160;</td>
          <td class="paramname"><em>sample_history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>total_number_of_sites</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total time on an ancestral recombination graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sample_history</td><td>an ancestral recombination graph </td></tr>
    <tr><td class="paramname">total_number_of_sites</td><td>the number of "sites" simulated on the ARG </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total time on an ancestral recombination graph. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The time is in terms of whatever units are recorded on the nodes of the mariginals of the ARG </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classSequence_1_1SeqException.html" title="Base class for exceptions that may be thrown. ">Sequence::SeqException</a></td><td>if the beginning of any marginal tree is &gt;= total_number_of_sites </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="CoalescentTreeOperations_8cc_source.html#l00131">131</a> of file <a class="el" href="CoalescentTreeOperations_8cc_source.html">CoalescentTreeOperations.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Jul 4 2015 09:59:14 for libsequence by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
