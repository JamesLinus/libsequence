<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libsequence: tutorial.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsequence
   &#160;<span id="projectnumber">1.8.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial_8md.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">tutorial.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor"># Tutorial/overview</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;[TOC]</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;The citation <span class="keywordflow">for</span> the library is \cite Thornton:2003vz</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;This document is a rapid-fire overview of library features.</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;\section background Background</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;I assume a working familiarity with:</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;* C++ and <span class="stringliteral">&quot;C++11&quot;</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;The code snippets below all use C++11 language features (initialization lists, lambda expressions, etc.).  Using GCC/clang, you would need to compile with -std=c++11.  Note, however, that none of the snippets below will actually compile, as they are not complete C++ programs.</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;\subsection streams A quick note on streams</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;In C++, input from streams are handled via <span class="keyword">operator</span>&gt;&gt; and <span class="keyword">operator</span>&lt;&lt;. libsequence defines many of these operators <span class="keywordflow">for</span> its types (see \ref operators).  These operators are overloaded <span class="keywordflow">for</span> uncompressed ASCII streams (aka plain-text files and buffers).  However, all of these operators are compatible with well-designed compressed-file streams, too.  Programmers <span class="keyword">using</span> libsequence may use [boost](http:<span class="comment">//www.boost.org)&#39;s filtering_ostream libraries as replacements for &lt;fstream&gt; as they see fit.</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;\section seq Handling biological sequences.</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;A sequence is defined by the <span class="stringliteral">&quot;pure virtual&quot;</span> <span class="keyword">class </span><a class="code" href="classSequence_1_1Seq.html">Sequence::Seq</a>, which publicly inherits from std::pair&lt;std::string,std::string&gt;.  The two members of the pair are the sequence name and the sequence itself, respectively.</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;A programmer may define new sequences via <span class="keyword">public</span> inheritance from <a class="code" href="classSequence_1_1Seq.html">Sequence::Seq</a>.  The programmer must define the <span class="keyword">public</span> member funtions Sequence::read and Sequence::print in order to make a valid class.  See <a class="code" href="classSequence_1_1Fasta.html">Sequence::Fasta</a> and <a class="code" href="classSequence_1_1fastq.html">Sequence::fastq</a> for examples.  These two functions (read/print) allow sequences to be <a class="code" href="classSequence_1_1Seq.html#a6e8fd025d52d0183b70ecc327a9f2eb4">read</a>/written to/from C++ streams.</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<a class="code" href="classSequence_1_1Seq.html">Sequence::Seq</a> defines several functions for data access and various biological operations (Sequence::Seq::Revcom, etc.).</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;\subsection seqio Reading and writing</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;During <a class="code" href="classSequence_1_1Seq.html#a6e8fd025d52d0183b70ecc327a9f2eb4">read</a> operations, a sequence object may throw an exception of type <a class="code" href="classSequence_1_1badFormat.html">Sequence::badFormat</a> if the data stream is not in the correct format.  The built-int types (Sequence::Fasta and Sequence::fastq) do not throw on write (although the output stream type could if something bad happens with the stream itself, etc.).</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;~~~~{.cpp}</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="Fasta_8hpp.html">Sequence/Fasta.hpp</a>&gt;</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<a class="code" href="classSequence_1_1Fasta.html">Sequence::Fasta</a> f;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;std::ifstream in(<span class="stringliteral">&quot;filename.fasta&quot;</span>)</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="keyword">try</span> {</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;in &gt;&gt; f &gt;&gt; std::wd;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;} <span class="keywordflow">catch</span> (<a class="code" href="classSequence_1_1badFormat.html">Sequence::badFormat</a> &amp; __b)</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;{</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;std::cerr &lt;&lt; __b &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;exit(1);</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;}</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;~~~~</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;A sequence may be written to an output stream <span class="keyword">using</span> the usual C++ output <span class="keyword">operator</span> &lt;&lt;.</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;\subsubsection seqgz Gzipped files, etc.</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;For reading/writing compressed files, see the [boost](http:<span class="comment">//www.boost.org)&#39;s filtering_ostream libraries.  They have been tested, and &quot;just work&quot; with libsequence objects.</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;Note: at the time of <span class="keyword">this</span> writing (and as per my latest testing) the boost libraries <span class="keywordflow">do</span> not support opening compressed streams in append mode.  If you need to append to files, then buffer output to a std::ostringstream and write the buffer to a gzFile <span class="keyword">using</span> [zlib](http:<span class="comment">//zlib.net) directly:</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;~~~~{.cpp}</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="preprocessor">#include &lt;zlib.h&gt;</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;std::ostringstream o;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">//Fill o with stuff</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;gzFile f = gzopen(<span class="stringliteral">&quot;file.gz&quot;</span>,<span class="stringliteral">&quot;a&quot;</span>);</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment">//Write your data to the .gz file</span></div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;gzwrite(f,o.str().c_str(),o.str().size());</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment">//Clear your buffer</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;o.str(std::string());</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;~~~~</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;\subsection manip Manipulating a sequence</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<a class="code" href="classSequence_1_1Seq.html">Sequence::Seq</a> provides obvious member functions <span class="keywordflow">for</span> element access and iteration. Further, because a sequence inherits from std::pair&lt;std::string,std::string&gt;, a library user may use any of std::string<span class="stringliteral">&#39;s member functions as well:</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="stringliteral">~~~~{.cpp}</span></div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="stringliteral">Sequence fasta f;</span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="stringliteral">//This is the name, whose type is std::string</span></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="stringliteral">auto namelen = f.first.size();</span></div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="stringliteral">//The sequence is also std::string:</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="stringliteral">auto seqlen = f.second.size();</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="stringliteral">~~~~</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="stringliteral">You may also access the data in the sequence (but not the name!) using C++11 range-based for loops:</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="stringliteral">~~~~~{.cpp}</span></div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="stringliteral">Sequence::Fasta f(&quot;name&quot;,&quot;TTT&quot;);</span></div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="stringliteral">//The for loop is equavalent to:</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="stringliteral">//for( auto &amp; c : f.second )</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="stringliteral">for( auto &amp; c : f )</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="stringliteral">{</span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="stringliteral">        c = &#39;</span>C<span class="stringliteral">&#39;;</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="stringliteral">~~~~~</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="stringliteral">\section alphabet Testing for correct character sets</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="stringliteral">The list of characters accepted as DNA is defined in the constant array Sequence::dna_alphabet, declared in Sequence/SeqAlphabets.hpp.  The type of Sequence::dna_alphabet is std::array&lt;const char,17&gt;, and may therefore be iterated over, etc., as per a normal std::array type.</span></div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="stringliteral">The function Sequence::isDNA accepts a single char as an argument and returns true if the argument is found in Sequence::dna_alphabet:</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="stringliteral">~~~{.cpp}</span></div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="stringliteral">#include &lt;Sequence/Fasta.hpp&gt;</span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="stringliteral">#include &lt;Sequence/SeqAlphabets.hpp&gt;</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="stringliteral">#include &lt;algorithm&gt;</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="stringliteral">Sequence::Fasta f = { &quot;name&quot;,   &quot;ATGCZAGC&quot; };  //Z is a non-DNA character</span></div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="stringliteral">//Find non-DNA characters:</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="stringliteral">auto itr = std::find_if( f.begin(),f.end(),</span></div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="stringliteral">                            [](const char &amp; __ch) {</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="stringliteral">                            return !Sequence::isDNA(__ch);</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="stringliteral">                           } );</span></div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="stringliteral">//Delete them from sequences:</span></div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="stringliteral">  f.second.erase( std::remove_if(f.begin(),</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="stringliteral">                                 f.end(),</span></div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="stringliteral">                                 [](const char &amp; __ch) {</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="stringliteral">                                   return !Sequence::isDNA(__ch);</span></div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="stringliteral">                                 }), f.second.end() );</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="stringliteral">The above code block comes from the unit test file alphabets.cc</span></div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="stringliteral">\section alignments Input and output of DNA sequence alignments</span></div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="stringliteral">libsequence contains support for I/O and processing of sequence alignments.  The primary use for these functions and classes is to handle the sorts of data that one would collect for population genetic analysis based on Sanger resequencing data and/or phylogenetic analysis.</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="stringliteral">The relevant modules are:</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="stringliteral">* Sequence::AlignStream is a template class abstracting the I/O for alignment data.</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="stringliteral">* namespace Sequence::Alignment</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="stringliteral">Concrete examples of Sequence::AlignStream include:</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="stringliteral">* Sequence::ClustalW</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="stringliteral">* Sequence::phylipData</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="stringliteral">Developers wishing to handle other input/output formats should study the implementation of those two classes.</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="stringliteral">As of the time of this writing (2014), these classes may be viewed as quaint.  However, I still think that there is some value to them, and refer the reader to the following sources for usage examples:</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="stringliteral">* The [analysis](http://github.com/molpopgen/analysis) package that I maintain</span></div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="stringliteral">* The unit test files AlignStreamTest.cc and AlignmentTest.cc.  These tests provide good coverage of relevant usage cases (and a few cases of user error, too).</span></div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="stringliteral">\section polymorphism_tables Polymorphism tables</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="stringliteral">Perhaps the most powerful part of libsequence is the efficient handling of tables of variable sites (polymorphism tables).</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="stringliteral">There are three basic types for the maninpulation of variation data:</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="stringliteral">* Sequence::PolyTable is a pure virtual base class for polymorphism tables. In essence, a PolyTable is a std::vector&lt;std::string&gt;, where the strings are the variable sites comprising the haplotypes in the sample.  In addition to this vector of strings, a std::vector&lt;double&gt; stores the positions of the variable sites.  This representation of variation data is the oldest in the library, several functions exist for processing these types.</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="stringliteral">* Sequence::polymorphicSite is a typedef for std::pair&lt;double, std::string&gt;.  The double represents the site position, and the string represents the state of each individual in the sample.  </span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="stringliteral">* Sequence::polySiteVector is a typedef for std::vector&lt;Sequence::polymorphicSite&gt;.  This type has existed for a while, and is a handy way to manipulate data in a SNP-centric way.</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="stringliteral">The major difference between Sequence::PolyTable and Sequence::polySiteVector is how the data are stored internally.  Iteration over a Sequence::PolyTable iterates over _haplotypes_, whereas iteration through a polySiteVector moves across _variable sites_.  These concepts will become more clear when we look at specific examples below.</span></div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="stringliteral">\subsection polytable_terms Definitions of terms</span></div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="stringliteral">Formally, the objects discussed in this section are agnostic with respect to ploidy.  Further, I use the term _haplotype_ here loosely.  If the data that populate a PolyTable or polySiteVector come from sources such as X-chromosome sequences obtained from males, autosomal sequences from a highly-inbred _Drosophila_ or _Arabidopsis_, or the output of some sort of haplotype phasing algorithm, then the haplotypes are indeed haplotypes (although, for the latter case, one should use the likeliehood of the haplotype inference as a weight on any results, if appropriate).  However, if the input are diploid genotype data, then those data must be split into two strings for that individual (in the case of a PolyTable), which will require arbitrarily assigning the values for a heterozygote to each string.   For such data, __it is user error to then apply any haplotype- or LD-based calculation to the data__.</span></div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="stringliteral">The only allowed characters in these objects are the set A,G,C,T,N,.,-,0,1.  The first five values should be obvious.  The next two are the identity and gap characters, respectively.  The 0 and 1 may be used in various ways, such as representing arbitrary states of biallelic data, ancestral vs. derived character states, minor/major alleles, or to represent more complex genotypes at a site.  A programmer may check that data contain valid characters using functions declared in Sequence/SeqAlphabets.hpp: Sequence::ambiguousNucleotide and Sequence::invalidPolyChar.</span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="stringliteral">\subsection polytable Sequence::PolyTable in detail</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="stringliteral">\subsubsection polytables The inheritance hierarchy.</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="stringliteral">Sequence::PolyTable is a pure virtual class that inherits publicly from objects in namespace std:</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="stringliteral">~~~{.cpp}</span></div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="stringliteral">//The vector of doubles are the site positions.  The strings are the haplotypes</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="stringliteral">class Sequence::PolyTable : public std::pair&lt;std::vector&lt;double&gt;, std::vector&lt;std::string&gt; &gt;</span></div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="stringliteral">{</span></div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="stringliteral">};</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="stringliteral">As with Sequence::Seq, there are two pure virtuals member functions, Sequence::PolyTable::read and Sequence::PolyTable::print.  A valid class must publicly inherit from Sequence::PolyTable and define these functions.  The library defines the following three classes that publicly inherit from the base class:</span></div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="stringliteral">* Sequence::SimData is intended to represent binary variation data in the format used by Dick Hudson&#39;</span>s coalescent simulation program \cite Hudson:2002vy.  This is the <span class="stringliteral">&quot;standard&quot;</span> format used <span class="keywordflow">for</span> simulating biallelic sites, and the character states have a very specific meaning: 0 = the ancestral state, 1 = the derived state.  See the example program msstats.cc <span class="keywordflow">for</span> how to read these objects in from streams, and the documentation <span class="keywordflow">for</span> the file Sequence/SimDataIO.hpp <span class="keywordflow">for</span> how to read/write from gzipped streams, binary streams, etc.</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;* <a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> This is a <span class="keyword">generic</span>/<span class="keywordflow">catch</span>-all <span class="keyword">class </span><span class="keywordflow">for</span> nucleotide-based SNP data.</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;* <a class="code" href="classSequence_1_1SimpleSNP.html">Sequence::SimpleSNP</a> This <span class="keyword">class </span>handles the format used by the software described in [Hudson (2001)](http:<span class="comment">//www.genetics.org/content/159/4/1805.abstract).</span></div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;The examples below focus on <a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a>.</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;\subsubsection customptables Handling custom input formats</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;If a user requires reading in data from a custom input format (HapMap, VCF, etc.), take the following steps:</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;* Create a <span class="keyword">new</span> <span class="keyword">class </span>that publicly inherits from <a class="code" href="classSequence_1_1PolyTable.html">Sequence::PolyTable</a>.  For example:</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="keyword">class </span>myPT : <span class="keyword">public</span> <a class="code" href="classSequence_1_1PolyTable.html">Sequence::PolyTable</a></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;{</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;};</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;~~~</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;* Define the read and print member functions.  See implementations of <a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> and/or <a class="code" href="classSequence_1_1SimData.html">Sequence::SimData</a> <span class="keywordflow">for</span> inspiration.  These functions make your <span class="keyword">class </span>compatible with <span class="keyword">operator</span>&gt;&gt; and <span class="keyword">operator</span>&lt;&lt;, respectively.  Ideally, your <span class="keyword">class </span>would be compatible with std::istream_iterator&lt;myPT&gt; as well, but that is often a little harder to do.</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;* Define move-constructors and move-assignment operators.  If you only want to construct myPTs from other myPTs, then the compiler defaults will be fine.  However, if you want to convert from any other type of PolyTable, then you must also define custom move-constructors and move-assigment operators:</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="keyword">class </span>myPT : <span class="keyword">public</span> <a class="code" href="classSequence_1_1PolyTable.html">Sequence::PolyTable</a></div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;{</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        myPT( myPT &amp;&amp; ) = <span class="keywordflow">default</span>;</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        myPT( myPT &amp; ) = <span class="keywordflow">default</span>;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        myPT( <a class="code" href="classSequence_1_1PolyTable.html">Sequence::PolyTable</a> &amp; ); <span class="comment">//you&#39;ll need to define this elsewhere</span></div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        myPT &amp; operator=( myPT &amp; ) = <span class="keywordflow">default</span>;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        myPT &amp; operator=( myPT &amp;&amp; ) = <span class="keywordflow">default</span>;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        myPT &amp; operator=( <a class="code" href="classSequence_1_1PolyTable.html">Sequence::PolyTable</a> &amp; ); <span class="comment">//you&#39;ll need to define this elsewhere</span></div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        myPT &amp; operator=( <a class="code" href="classSequence_1_1PolyTable.html">Sequence::PolyTable</a> &amp;&amp; ); <span class="comment">//you&#39;ll need to define this elsewhere</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;};</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;~~~</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;* Write unit tests showing that all of the above works. See the following unit tests <span class="keywordflow">for</span> examples: testSimDataIO.cc, PolyTableConversions.cc SimpleSNPIO.cc PolySitesIO.cc</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;An alternative approach to creating your own <span class="keyword">class </span>is to simply read the data into two vectors:</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;1. A std::vector&lt;double&gt; representing the mutation positions</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;2. A std::vector&lt;std::string&gt; representing the haplotypes</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;From these two containers, a programmer can construct a <a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> using move semantics.  The construction of PolyTables is covered in the next section.</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;\subsubsection polytable_construct Constructing PolyTables</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;\paragraph polytable_read From streams</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;Most trivially, a polymorphism table may be read in via Sequence::operator&gt;&gt;, which redirects to <a class="code" href="classSequence_1_1PolyTable.html#a27a62e9ee28d31f4b386c79a7af167a0">Sequence::PolyTable::read</a>.  For example, to read in data from a coalescent simulation that writes to stdout:</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="SimData_8hpp.html">Sequence/SimData.hpp</a>&gt;</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv ) {</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <a class="code" href="classSequence_1_1SimData.html">Sequence::SimData</a> d;</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    <span class="keywordflow">while</span> (! std::cin.eof() )</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    {</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        std::cin &gt;&gt; d &gt;&gt; std::ws;</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        <span class="comment">//do something interesting with &quot;d&quot; here:</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    }   </div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;}</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;~~~</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;See the unit test testSimDataIO.cc <span class="keywordflow">for</span> other ways to read/write objects of type <a class="code" href="classSequence_1_1SimData.html">Sequence::SimData</a>.</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;See the unit test PolySitesIO.cc <span class="keywordflow">for</span> an example <span class="keyword">using</span> <a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a>.</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;\subsubsection polytable_move Using move construction</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;Let<span class="stringliteral">&#39;s say we have the following data in C++ containers:</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="stringliteral">~~~{.cpp}</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="stringliteral">  std::vector&lt;double&gt; pos = {1,2,3,4,5};</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="stringliteral">  std::vector&lt;std::string&gt; data = {&quot;AAAAA&quot;,</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="stringliteral">                                   &quot;AAGAA&quot;,</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="stringliteral">                                   &quot;CTGAA&quot;,</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="stringliteral">                                   &quot;NAACT&quot;};</span></div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="stringliteral">  //We can construct a PolySites by moving our data: </span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="stringliteral">  Sequence::PolySites ps(std::move(pos),std::move(data));</span></div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="stringliteral">  //Now, accessing the elements of pos and data are undefined!</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="stringliteral">These move semantics allow a library user to populate vectors and then fill PolyTables with no extra copying.</span></div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="stringliteral">Remember that std::move results in the source of the move being left in what may be an undefined state.  Typically, the classes in namespace std will be re-assigned some sensible default.  In the above example, the &quot;pos&quot; and &quot;data&quot; vectors should both be empty.  You can check if that is true on your system by runnning the unit tests in PolyTableTweaking.cc.</span></div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="stringliteral">In addition to the above example, a well-defined PolyTable has a move constructor and an overload of operator= that takes an lvalue reference as an argument, _e.g._:</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="stringliteral">~~~{.cpp}</span></div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="stringliteral">        //The &amp;&amp; is an lvalue reference</span></div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="stringliteral">        myPT &amp; operator=( myPT &amp;&amp; ) = default;</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="stringliteral">See the header files PolySites.hpp, SimData.hpp, and PolyTable.hpp for examples of declarations.  The corresponding definitions are in PolySites.cc, SimData.cc, and PolyTable.cc, respectively.</span></div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="stringliteral">\subsubsection polytable_access Accessing the data</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="stringliteral">The data stored in a PolyTable may be accessed in a variety of ways.  The following types are relevant, and are analogs to the usual typedefs found in STL containers (click to see their documentation):</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="stringliteral">* Sequence::PolyTable::reference </span></div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="stringliteral">* Sequence::PolyTable::const_reference</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="stringliteral">* Sequence::PolyTable::size_type</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="stringliteral">* Sequence::PolyTable::data_iterator</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="stringliteral">* Sequence::PolyTable::const_data_iterator</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="stringliteral">* Sequence::PolyTable::pos_iterator</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="stringliteral">* Sequence::PolyTable::const_pos_iterator</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="stringliteral">* Sequence::PolyTable::const_site_iterator</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="stringliteral">The following member functions exist for data access:</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="stringliteral">* Sequence::PolyTable::operator[] returns a reference or const_reference.  The data returned correspond to a std::string representing a haplotype.</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="stringliteral">* Sequence::PolyTable::begin and Sequence::PolyTable::end return either Sequence::PolyTable::const_data_iterator or Sequence::PolyTabe::data_iterator to haplotypes, depending on the context</span></div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="stringliteral">* Sequence::PolyTable::cbegin and Sequence::PolyTable::cend return Sequence::PolyTable::const_data_iterator to haplotypes</span></div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="stringliteral">* Sequence::PolyTable::pbegin and Sequence::PolyTable::pend return either pos_iteraor or const_pos_iterator to the mutation positions, depending on the context</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="stringliteral">* Sequence::PolyTable::pcbegin and Sequence::PolyTable::pcend return const_pos_iterator to the mutation positions.</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="stringliteral">* Sequence::PolyTable::sbegin and Sequence::PolyTable::send return const_site_iterators</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="stringliteral">* Sequence::PolyTable::scbegin and Sequence::PolyTable::scend return const_site iterators</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="stringliteral">The versions with &quot;c&quot; in them may appear redundant, but they are used in C++11 in the context of type deduction using keywords like auto or the declytpe function.</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;<span class="stringliteral">__NOTE:__ these iterators are aliases to the underling vectors in the base class, and should be preferred.  In other words, this code:</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;<span class="stringliteral">~~~{.cpp}</span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;<span class="stringliteral">Sequence::PolySites ps;</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="stringliteral">std::for_each(ps.begin(),ps.end(),[](const Sequence::PolySites::const_reference &amp; __s) { std::cout &lt;&lt; __s.length() &lt;&lt; &#39;</span>\n<span class="stringliteral">&#39;; });</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="stringliteral">is better than this code:</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="stringliteral">~~~{.cpp}</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<span class="stringliteral">Sequence::PolySites ps;</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="stringliteral">std::for_each(ps.second.begin(),ps.second.end(),[](const Sequence::PolySites::const_reference &amp; __s) { std::cout &lt;&lt; __s.length() &lt;&lt; &#39;</span>\n<span class="stringliteral">&#39;; });</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="stringliteral">The reason why will be explained in \ref polytable_csi</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="stringliteral">Let&#39;</span>s look at some examples.</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;</div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;<a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> p;</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;<span class="comment">//fill p somehow...</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="comment">//Write the haplotypes to stdout</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="keywordflow">for</span>( <a class="code" href="classSequence_1_1PolyTable.html#a05bb8d5b84760082a5b20a3598fa4f57">Sequence::PolySites::size_type</a> i = 0 ; i &lt; p.<a class="code" href="classSequence_1_1PolyTable.html#a0ad9fa4c28b8568a1bde74e13d10f1b3">size</a>() ; ++i )</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;{</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        std::cout &lt;&lt; p[i] &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;}</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;~~~</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;The above example shows us that <a class="code" href="classSequence_1_1PolyTable.html#a0ad9fa4c28b8568a1bde74e13d10f1b3">Sequence::PolyTable::size</a> exists.  There is also <a class="code" href="classSequence_1_1PolyTable.html#a131a61d74eb612a3e419aa4ae1c38a24">Sequence::PolyTable::empty</a>.</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;</div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;Let<span class="stringliteral">&#39;s do the above using iteration:</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="stringliteral">~~~{.cpp}</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="stringliteral">Sequence::PolySites p;</span></div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="stringliteral">//fill p somehow...</span></div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="stringliteral">//Write the haplotypes to stdout</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="stringliteral">for( Sequence::PolySites::data_iterator i = p.begin() ; </span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="stringliteral">     i &lt; p.end() ; ++i )</span></div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="stringliteral">{</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="stringliteral">        //i is an iterator pointing to a std::string</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="stringliteral">        std::cout &lt;&lt; *i &lt;&lt; &#39;</span>\n<span class="stringliteral">&#39;;</span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="stringliteral">Because we have begin and end defined, we can use range-based for loops in C++11:</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="stringliteral">~~~{.cpp}</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="stringliteral">  std::vector&lt;double&gt; pos = {1,2,3,4,5};</span></div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="stringliteral">  std::vector&lt;std::string&gt; data = {&quot;AAAAA&quot;,</span></div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="stringliteral">                                   &quot;AAGAA&quot;,</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="stringliteral">                                   &quot;CTGAA&quot;,</span></div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="stringliteral">                                   &quot;NAACT&quot;};</span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;<span class="stringliteral">  </span></div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="stringliteral">  Sequence::PolySites ps(std::move(pos),std::move(data)),ps2;</span></div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="stringliteral">  for( auto d : ps )</span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<span class="stringliteral">  {</span></div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;<span class="stringliteral">        std::cout &lt;&lt; d &lt;&lt; &#39;</span>\n<span class="stringliteral">&#39;;</span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="stringliteral">\subsubsection polytable_manip Manipulating PolyTables</span></div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;<span class="stringliteral">We can take advantage of non-const access to data in order to manipulate what is stored:</span></div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;<span class="stringliteral">~~~{.cpp}</span></div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="stringliteral">  std::vector&lt;double&gt; pos = {1,2,3,4,5};</span></div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;<span class="stringliteral">  std::vector&lt;std::string&gt; data = {&quot;AAAAA&quot;,</span></div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;<span class="stringliteral">                                   &quot;AAGAA&quot;,</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;<span class="stringliteral">                                   &quot;CTGAA&quot;,</span></div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;<span class="stringliteral">                                   &quot;NAACT&quot;};</span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;<span class="stringliteral">  Sequence::PolySites ps(std::move(pos),std::move(data)),</span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="stringliteral">    ps2(ps);</span></div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;<span class="stringliteral">//Make everything lower-case</span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;<span class="stringliteral">        //Non-const access to the strings</span></div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<span class="stringliteral">for( auto &amp; d : ps ) {</span></div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;<span class="stringliteral">        //non-const access to the char within the strings</span></div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;<span class="stringliteral">        for(auto &amp; ch : d ) {</span></div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;<span class="stringliteral">        ch = std::tolower(ch);</span></div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;<span class="stringliteral">        }</span></div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;<span class="stringliteral">    //Restore it to upper-case</span></div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;<span class="stringliteral">for( auto &amp; d : ps ) {</span></div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;<span class="stringliteral">        for( auto &amp; ch : d ) {</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;<span class="stringliteral">                ch = std::toupper(ch);</span></div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;<span class="stringliteral">        }</span></div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;<span class="stringliteral">  }</span></div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;<span class="stringliteral">\subsubsection polytable_manip_builtin Methods provided</span></div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="stringliteral">The library provides a variety of methods for doing things like removing missing data, applying frequency filters, etc.  Unfortunately (for now), these functions are mixed between member functions of Sequence::PolyTable and the file PolyTableFunctions.hpp.  See the documentation for Sequence::PolyTable and PolyTableFunctions.hpp as well as the unit test code PolyTableTweaking.cc for usage examples.  It is possible that a future release of libsequence will deprecate the member functions in favor of standalone functions.</span></div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;<span class="stringliteral">A user unfamiliar with C++ may think that many features are missing.  How does one permute site positions or the order of the haplotypes?  How can you remove a single haplotype?  These functions are not necessary as they are possible because of the definition of Sequence::PolyTable itself and the functions that already exist in the C++ Standard Template Library (STL).  For example, to remove all haplotypes containing missing data, simply use the erase/remove idiom:</span></div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;<span class="stringliteral">~~~{.cpp}</span></div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;<span class="stringliteral">std::vector&lt;double&gt; pos = {1,2,3,4,5};</span></div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;<span class="stringliteral">std::vector&lt;std::string&gt; data = {&quot;AAAAA&quot;,</span></div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;<span class="stringliteral">        &quot;AAGAA&quot;,</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="stringliteral">        &quot;CTGAA&quot;,</span></div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="stringliteral">        &quot;NAACT&quot;}; //This sequence will get erased below</span></div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="stringliteral">Sequence::PolySites ps(std::move(pos),std::move(data));</span></div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;<span class="stringliteral">ps.second.erase( std::remove_if(ps.begin(),</span></div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="stringliteral">        ps.end(),</span></div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="stringliteral">                [](const std::string &amp; __s) {</span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="stringliteral">                        return __s.find(&#39;</span>N<span class="stringliteral">&#39;) != std::string::npos;</span></div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="stringliteral">        }),</span></div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="stringliteral">        ps.end() );</span></div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;<span class="stringliteral">Similarly, one may permute the haplotype order and/or the site positions using std::random_shuffle.  If you are not familiar with what is in the STL, it would be a good idea to learn more about it.  I quite like [cppreference](http://en.cppreference.com/w/) as an online source.</span></div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;<span class="stringliteral">\paragraph polytable_idiot Don&#39;</span>t be <span class="keyword">this</span> guy</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;Because you have non-<span class="keyword">const</span> access to the data, you can <span class="keywordflow">do</span> <span class="keyword">this</span>:</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;  std::vector&lt;double&gt; pos = {1,2,3,4,5};</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;  std::vector&lt;std::string&gt; data = {<span class="stringliteral">&quot;AAAAA&quot;</span>,</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;                                   <span class="stringliteral">&quot;AAGAA&quot;</span>,</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;                                   <span class="stringliteral">&quot;CTGAA&quot;</span>,</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;                                   <span class="stringliteral">&quot;NAACT&quot;</span>};</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;  </div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;  <a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> ps(std::move(pos),std::move(data)),ps2;</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;  <span class="comment">//You now have a table with unequal haplotype lengths</span></div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;  <span class="comment">//This is bad, and is user error.</span></div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;  ps[0] = std::string(<span class="stringliteral">&quot;A&quot;</span>);</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;~~~</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;\subsubsection polytable_csi Iterating over sites directly</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;The examples above iterate over haplotypes.   It is sometimes useful to iterate over the variable sites themselves.  However, iterating over site positions <span class="keyword">using</span> <a class="code" href="classSequence_1_1PolyTable.html#aae81867f990cacbd36bce631c8c95bf3">Sequence::PolyTable::pbegin</a> and <a class="code" href="classSequence_1_1PolyTable.html#a906a808ab8ae90406a1f66fc7d38da38">Sequence::PolyTable::pend</a> only gives you access to the positions, and not to the character states.  The library allows <span class="keyword">const</span> access to sites via the member functions <a class="code" href="classSequence_1_1PolyTable.html#a9c5e337cb00acba2ab83174ac933bb9e">Sequence::PolyTable::sbegin</a> and <a class="code" href="classSequence_1_1PolyTable.html#afe610e36cc38d3a77dfe9d6254deb789">Sequence::PolyTable::send</a>, where the <span class="stringliteral">&quot;s&quot;</span> means <span class="stringliteral">&quot;site&quot;</span>.  These functions <span class="keywordflow">return</span> types <a class="code" href="classSequence_1_1PolyTable.html#a7096e7ad3abcb257a8e7ac8c28a23e5c">Sequence::PolyTable::const_site_iterator</a>, whose value_type is __const__ <a class="code" href="namespaceSequence.html#a08841c3bd3b0999a40dfdadbee4a6b0d">Sequence::polymorphicSite</a>, which is itself a <span class="keyword">typedef</span> <span class="keywordflow">for</span> std::pair&lt; double, std::string &gt;.  Let<span class="stringliteral">&#39;s look at an example:</span></div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;<span class="stringliteral">~~~{.cpp}</span></div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="stringliteral">std::vector&lt;double&gt; pos = {1,2,3,4,5};</span></div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;<span class="stringliteral">std::vector&lt;std::string&gt; data =</span></div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<span class="stringliteral">        {&quot;AAAAA&quot;,</span></div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;<span class="stringliteral">         &quot;AAGAA&quot;,</span></div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;<span class="stringliteral">     &quot;CTGAA&quot;,</span></div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;<span class="stringliteral">         &quot;NAACT&quot;};</span></div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;<span class="stringliteral">Sequence::PolySites ps(std::move(pos),std::move(data));</span></div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="stringliteral">/*</span></div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="stringliteral">The output of this block will be:</span></div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="stringliteral">1 AACN</span></div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="stringliteral">2 AATA</span></div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="stringliteral">3 AGGA</span></div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="stringliteral">4 AAAC</span></div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="stringliteral">5 AAAT</span></div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="stringliteral">*/</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="stringliteral">for( auto i = ps.sbegin() ; i &lt; ps.send() ; ++i )</span></div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="stringliteral">{</span></div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;<span class="stringliteral">std::cout &lt;&lt; i-&gt;first &lt;&lt; &#39;</span> <span class="stringliteral">&#39;</span></div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<span class="stringliteral">        &lt;&lt; i-&gt;second &lt;&lt; &#39;</span>\n<span class="stringliteral">&#39;;</span></div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="stringliteral">}</span></div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;<span class="stringliteral">~~~</span></div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="stringliteral">Let&#39;</span>s call <span class="keyword">this</span> type of output <span class="stringliteral">&quot;rotated&quot;</span>, in the sense that the sites are the rows and the haplotypes are now columns.</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;The fact that <span class="keyword">this</span> access is <span class="keyword">const</span>-only brings up several important points:</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;1.  <a class="code" href="classSequence_1_1PolyTable.html">Sequence::PolyTable</a> knows <span class="keywordflow">if</span> you have accessed it in a <span class="keyword">const</span> or non-<span class="keyword">const</span> context.</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;2.  If you access a PolyTable in a non-<span class="keyword">const</span> context, the <span class="stringliteral">&quot;rotated&quot;</span> representation of the data will be recalculated the next time <a class="code" href="classSequence_1_1PolyTable.html#a9c5e337cb00acba2ab83174ac933bb9e">Sequence::PolyTable::sbegin</a> or Sequence::PolyTable::send is called.  The reason is that your non-<span class="keyword">const</span> access may have removed some data.</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;3. In the section called \ref polytable_access, I said that you should prefer iterator-based access to the data via the <span class="keyword">class</span><span class="stringliteral">&#39;s member functions rather than the base classes.  The reason is that _only the former is cabable of distinguishing const from non-const access_, and therefore modifying the data via the latter method will result in const_site_iterators whose data are inconsistent with what the object currently stores.</span></div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;<span class="stringliteral"></span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;<span class="stringliteral">Let&#39;</span>s look at a concrete example of that last point.  The following example appeared above (in the section \ref polytable_manip_builtin):</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;std::vector&lt;double&gt; pos = {1,2,3,4,5};</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;std::vector&lt;std::string&gt; data = {<span class="stringliteral">&quot;AAAAA&quot;</span>,</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        <span class="stringliteral">&quot;AAGAA&quot;</span>,</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;        <span class="stringliteral">&quot;CTGAA&quot;</span>,</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        <span class="stringliteral">&quot;NAACT&quot;</span>}; <span class="comment">//This sequence will get erased below</span></div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;<a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> ps(std::move(pos),std::move(data));</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;ps.second.erase( std::remove_if(ps.begin(),</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;        ps.end(),</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;                [](<span class="keyword">const</span> std::string &amp; __s) {</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;                        <span class="keywordflow">return</span> __s.find(<span class="charliteral">&#39;N&#39;</span>) != std::string::npos;</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;        }),</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;        ps.end() );</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;<span class="comment">/*</span></div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;<span class="comment">The output will be:</span></div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;<span class="comment">1 AAC</span></div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;<span class="comment">2 AAT</span></div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;<span class="comment">3 AGG</span></div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;<span class="comment">4 AAA</span></div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;<span class="comment">5 AAA</span></div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;<span class="comment">*/</span></div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;std::for_each( ps.sbegin(),ps.send(),</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;[](<span class="keyword">const</span> Sequence::polymorphicSite &amp; __p) {</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;        std::cout &lt;&lt; __p.first &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; p.second &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;});</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;~~~</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;However, <span class="keywordflow">if</span> we had applied the erase/<span class="keyword">remove</span> step with <span class="keyword">this</span> code instead:</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;<span class="comment">/*</span></div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;<span class="comment">Here, we never call Sequence::PolyTable::begin or end.</span></div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;<span class="comment">Rather, we are calling std::vector&lt;std::string&gt;&#39;s versions</span></div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;<span class="comment">of the same functions.</span></div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="comment">Therefore, does not know that it has been accessed in</span></div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;<span class="comment">a non-const context, and calls to sbegin/send should</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;<span class="comment">be viewed as leading to undefined behavior</span></div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;<span class="comment">*/</span></div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;ps.second.erase( std::remove_if(ps.second.begin(),</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;        ps.second.end(),</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;                [](<span class="keyword">const</span> std::string &amp; __s) {</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;                        <span class="keywordflow">return</span> __s.find(<span class="charliteral">&#39;N&#39;</span>) != std::string::npos;</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;        }),</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;        ps.second.end() );</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;~~~</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;How does the above lead to bizarre behavior?  Well, it depends:</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;1.  If const_site_iterators have never been accessed, then the next call will regenerate the data, and all will be well.</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;2.  If const_site_iterators _have_ been previously accessed, then the above block will not signal that their data needs to be recalculated.  Exactly what will happen depends on the nature of your non-<span class="keyword">const</span> access, and should therfore be classified as <span class="stringliteral">&quot;scary&quot;</span> at best.</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;To see how things go badly, look at the unit test file PolyTableBadBehavior.cc

\subsection ptable_detail <a class="code" href="namespaceSequence.html#aa52c570782b66af0cddf21ccaa86c768">Sequence::polySiteVector</a> in detail</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;<a class="code" href="namespaceSequence.html#aa52c570782b66af0cddf21ccaa86c768">Sequence::polySiteVector</a> is declared in Sequence/<a class="code" href="namespaceSequence.html#aa52c570782b66af0cddf21ccaa86c768">polySiteVector</a>.hpp and defined in <a class="code" href="namespaceSequence.html#aa52c570782b66af0cddf21ccaa86c768">polySiteVector</a>.cc.  From these files, you will see that <span class="keyword">this</span> is an extremely simple <span class="keyword">class</span>.  <a class="code" href="namespaceSequence.html#aa52c570782b66af0cddf21ccaa86c768">Sequence::polySiteVector</a> is simply a std::vector&lt; Sequence::polymorphicSite &gt;, and is therefore related to the objects referred to by <a class="code" href="classSequence_1_1PolyTable.html#a7096e7ad3abcb257a8e7ac8c28a23e5c">Sequence::PolyTable::const_site_iterator</a> (whose value_type is Sequence::polymorphicSite).</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;This <span class="keyword">class </span>is most powerful in light of C++11&#39;s addition of lambda expressions to the language.  The definition of Sequence::<a class="code" href="namespaceSequence.html#aa52c570782b66af0cddf21ccaa86c768">polySiteVector</a> plus the power of lambda expressions leads to a very powerful grammer for manipulating variation tables.  For example, let is remove all sites with invalid characters (as defined in \ref polytable_terms) from a <a class="code" href="namespaceSequence.html#aa52c570782b66af0cddf21ccaa86c768">polySiteVector</a>:</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;  <span class="keyword">using</span> psite = <a class="code" href="namespaceSequence.html#a08841c3bd3b0999a40dfdadbee4a6b0d">Sequence::polymorphicSite</a>;</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;  <a class="code" href="namespaceSequence.html#aa52c570782b66af0cddf21ccaa86c768">Sequence::polySiteVector</a> t = { psite(1.,<span class="stringliteral">&quot;AAGC&quot;</span>),</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;                         psite(2.,<span class="stringliteral">&quot;ACZA&quot;</span>) }; <span class="comment">//site 2 has a non-DNA character</span></div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;        <span class="comment">//This will remove site 2:</span></div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;  t.erase( std::remove_if( t.begin(),</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;                        t.end(),</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;                        []( <span class="keyword">const</span> psite &amp; __p ) {</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;                             <span class="keywordflow">return</span> std::find_if(__p.second.begin(),</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;                                                 __p.second.end(),</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;                                                 <a class="code" href="structSequence_1_1invalidPolyChar.html">Sequence::invalidPolyChar</a>())</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;                               != __p.second.end();</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;                           } ),</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;           t.end() );</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;~~~</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;The syntax in the above example is compact, readable, efficient, and avoids the pre-C++11 headache of having to define standalone <span class="keyword">function</span> objects <span class="keywordflow">for</span> such simple tasks.  The above code block is from the unit test file polySiteVectorTest.cc.  See the example program polySiteVector_test.cc <span class="keywordflow">for</span> some cool usage cases.</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;\subsection polytable_ptable The relationship between PolyTable and <a class="code" href="namespaceSequence.html#aa52c570782b66af0cddf21ccaa86c768">polySiteVector</a></div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;These two types are intimately-related and may be constructed from one another.</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;\subsection 

\section summstats Summary statistics</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;\subsection classic Standard summary statistics</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;libsequence contains routines <span class="keywordflow">for</span> calculating several standard summary statistics (Watterson<span class="stringliteral">&#39;s \f$\theta\f$, Tajima&#39;</span>s \f$\pi\f$, etc.).  The relevant classes are:</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;* <a class="code" href="classSequence_1_1PolySNP.html">Sequence::PolySNP</a> to calculate statistics from nucleotide data.  The allowed character set is A,G,C,T,N,-.</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;* <a class="code" href="classSequence_1_1PolySIM.html">Sequence::PolySIM</a> inherits from PolySNP and is intended to be used with biallelic data encoded in a 0/1 format where 0 = ancestral and 1 = the derived character state.  This <span class="keyword">class </span>is tightly-coupled to Sequence::SimData.  See the example program msstats.cc for how to use this class.</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;These classes are constructed from objects in the <a class="code" href="classSequence_1_1PolyTable.html">Sequence::PolyTable</a> class hierarchy:</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="PolySNP_8hpp.html">Sequence/PolySNP.hpp</a>&gt;</span></div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="PolySites_8hpp.html">Sequence/PolySites.hpp</a>&gt;</span></div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;<span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;std::vector&lt;double&gt; pos = {1,2,3,4,5};</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;std::vector&lt;std::string&gt; data = {<span class="stringliteral">&quot;AAAAA&quot;</span>,</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;        <span class="stringliteral">&quot;AAGAA&quot;</span>,</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;        <span class="stringliteral">&quot;CTGAA&quot;</span>,</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;        <span class="stringliteral">&quot;NAACT&quot;</span>}; </div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;<a class="code" href="classSequence_1_1PolySites.html">Sequence::PolySites</a> ps(std::move(pos),std::move(data));</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<a class="code" href="classSequence_1_1PolySNP.html">Sequence::PolySNP</a> aps(&amp;ps);</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="comment">//Now, output some summary stats</span></div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;std::cout &lt;&lt; aps.NumPoly() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> <span class="comment">//Number of segregating sites</span></div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;        &lt;&lt; aps.ThetaW() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> <span class="comment">//Watterson&#39;s theta</span></div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;        &lt;&lt; aps.ThetaPi() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> <span class="comment">//Tajima&#39;s pi</span></div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;        &lt;&lt; aps.TajimasD() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; <span class="comment">//Tajima&#39;s D</span></div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;~~~</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;Take a look at the <span class="keyword">class </span>documentation for Sequence::PolySNP and <a class="code" href="classSequence_1_1PolySIM.html">Sequence::PolySIM</a> for a list of all the things that you can calculate from a PolyTable -- there is a lot there.</div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;</div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;\subsection classic_fst FST</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;The class <a class="code" href="classSequence_1_1FST.html">Sequence::FST</a> allows the calculation of \f$F_{st}\f$ statistics from PolyTables + a vector of the sample sizes per population:</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="PolySites_8hpp.html">Sequence/PolySites.hpp</a>&gt;</span></div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="FST_8hpp.html">Sequence/FST.hpp</a>&gt;</span></div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;<span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;std::vector&lt;double&gt; pos = {1,2,3,4,5};</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;std::vector&lt;std::string&gt; data = {<span class="stringliteral">&quot;AAAAA&quot;</span>,</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;        <span class="stringliteral">&quot;AAGAA&quot;</span>,</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;        <span class="stringliteral">&quot;CTGAA&quot;</span>,</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;        <span class="stringliteral">&quot;CAACT&quot;</span>};</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="comment">//The sample size is 2 in each subpop:</span></div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;std::vector&lt;unsigned&gt; sample_sizes = {2,2};</div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;Sequence FST fst_calculator(&amp;data,sample_sizes.size(),&amp;sample_sizes[0]);</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;std::cout &lt;&lt; fst_calculator.HSM() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> <span class="comment">//Hudson, Slaktin, Maddison</span></div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;        &lt;&lt; fst_calculator.HBK() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> <span class="comment">//Hudson, Boos, Kaplan</span></div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;        &lt;&lt; fst_calculator.Slatkin() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span>  <span class="comment">//Slatkin</span></div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;        <span class="comment">//below are the components of Fst calculations:</span></div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;        &lt;&lt; fst_calculator.piB() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> <span class="comment">//Mean pairwise divergence b/w pops</span></div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;        &lt;&lt; fst_calculator.piT() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> <span class="comment">//Total diversity</span></div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;        &lt;&lt; fst_calculator.piS() &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> <span class="comment">//mean within-pop diversity</span></div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;        &lt;&lt; fst_calculator.piD() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;<span class="comment">//The difference between- and within- pop diversity</span></div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;~~~</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;\subsection hka The HKA test</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;The HKA test statistic is available via the functions <a class="code" href="group__popgen.html#ga490ad3c8b4e548d1cf850806b6a5be1d">Sequence::calcHKA</a>.</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;\subsection stat_future The future </div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;<a class="code" href="classSequence_1_1PolySNP.html">Sequence::PolySNP</a> and <a class="code" href="classSequence_1_1PolySIM.html">Sequence::PolySIM</a> are <span class="stringliteral">&quot;factory&quot;</span> objects, which means that they pre-process your data and contain lots of member functions to calculate various statistics.  A significant problem with <span class="keyword">this</span> design is that adding <span class="keyword">new</span> summary statistics breaks the library<span class="stringliteral">&#39;s compatibility with existing programs compiled against it (because the sizeof(Sequence::PolySNP) changes with the addition of new funtions).   The future of libsequence&#39;</span>s <span class="keyword">interface </span>to summary statistics will be:</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;* Extracting the preprocessing steps from <a class="code" href="classSequence_1_1PolySNP.html">Sequence::PolySNP</a> to a standalone class</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;* Rewriting the summary statistic calculations as standalone functions taking the preprocessed data object as a parameter.</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;The interface described above will be kept because there is a lot of code sitting around that depends upon it.</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;\section coalsim Coalescent simulation</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;The sub-namespace Sequence::coalsim contains the routines required for implementing coalescent simulations with recombination using Hudson&#39;s algorithm (e.g., the one that underlies his [ms](http:<span class="comment">//www.ncbi.nlm.nih.gov/pubmed/11847089) program, \cite Hudson:2002vy).  A full introduction to these routines is beyond the scope of this document at the moment, but the namespace has the following features:</span></div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;* There are no global variables representing the fundamental data structures.  Thus, the code base is prone to fewer side-effects than one would encounter in modifying ms directly.</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;* It is agnostic with respect to time scale, and may be used for discrete or continuous time scales at the user&#39;s discretion</div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;* The current implementation has the Kingman coalescent in mind, in which all coalsecent events are between pairs of lineages.  However, the fundamental data structure (Sequence::coalsim::marginal) will also be compatible with simulating &quot;lamba&quot; coalescents.</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;* The recombination method implemented in Sequence::coalsim::crossover is Hudson&#39;s algorithm.  There is currently no support for the Markovian approximation to this process, but there could be in the future.</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;* The namespace uses templates to achieve independence from any particular random number generation system.  I have successfully used it with both the C++11 &lt;random&gt; header and the [GSL](http:<span class="comment">//gnu.org/software/gsl) functions.</span></div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;The namespace implements several standard/simple demographic scenarios in the file Sequence/Coalescent/DemographicModels.hpp.</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;The following example programs show more complex use scenarios:</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;* msmm.cc</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;* freerec.cc</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;* fragments.cc</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;* bottleneck.cc</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;There is support for simulation involving selection via the header Sequence/Coalescent/Trajectories.hpp.</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;__DISCLAIMER:__ Please note that this namespace may easily lead to having &quot;too much rope&quot;.  As with any simulation interface, knowing how to test what you&#39;ve coded up is critical, and these functions are intended for people who are comfortable with coalescent theory.</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;\section hts_tut High-throughput sequencing</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;\subsection sam SAM records</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;The class Sequence::samrecord allows processing SAM records from streams:</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;#include &lt;Sequence/samrecord.hpp&gt;</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;#include &lt;iostream&gt;</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;Sequence::samrecord r;</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;while( ! std::cin.eof() )</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;{</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;        std::cin &gt;&gt; r &gt;&gt; std::ws;</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;}</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;~~~</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;Intended usage for a program using this class would be:</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;~~~{.sh}</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;samtools view bamfile | ./program</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;~~~</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;The <span class="keyword">class </span>provides no method for parsing a SAM header.  However, doing so is trivial, and is left to the library user</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;\subsection samflags SAM flags and bit fields</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;SAM/BAM data contain &quot;SAM flag&quot; fields.  These fields are 32-bit integers containing a lot of info about the alignment.  They are represented in libsequence by Sequence::samflag.  This type contains boolean variables (Sequence::samflag::is_paired, etc.) representing the various data fields.  The parsing of the bit fields is implemented using data in namespace Sequence::sambits.</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;\subsection bam BAM files</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;<a class="code" href="classSequence_1_1bamreader.html">Sequence::bamreader</a> allows reading directly from BAM files.  The class also supports seeking within a BAM file. An alignment is represented by <a class="code" href="classSequence_1_1bamrecord.html">Sequence::bamrecord</a>, and is returned from a bamreader via <a class="code" href="classSequence_1_1bamreader.html#a89a8ae80000afaea8de6cd4818b5469e">Sequence::bamreader::next_record</a>:</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;~~~{.cpp}</div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="bamreader_8hpp.html">Sequence/bamreader.hpp</a>&gt;</span></div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;<span class="comment">/*</span></div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;<span class="comment">        The header is now parsed if the file was opened successfully</span></div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;<span class="comment">*/</span></div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;<a class="code" href="classSequence_1_1bamreader.html">Sequence::bamreader</a> r(<span class="stringliteral">&quot;file.bam&quot;</span>);</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;<span class="keywordflow">if</span> ( r )</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;{</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;        <span class="keywordflow">while</span>( !r.eof() &amp;&amp; !r.error() )</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;        {</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;                <a class="code" href="classSequence_1_1bamrecord.html">Sequence::bamrecord</a> rec = r.next_record();</div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;        }</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;}</div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;~~~</div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;You may access the BAM header info via:</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;* <a class="code" href="classSequence_1_1bamreader.html#a09798434cd979cb8659db4c3f37fbb48">Sequence::bamreader::header</a></div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;* Sequence::bamreader::operator[]</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;* <a class="code" href="classSequence_1_1bamreader.html#ac0a75ae7e8b9645271adabef0ae513b6">Sequence::bamreader::ref_cbegin</a>()</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;* <a class="code" href="classSequence_1_1bamreader.html#a0d42726baf79c66cc7326cf6eea1db7e">Sequence::bamreader::ref_cend</a>()</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;And use Sequence::bamreader::n_ref to get the number of sequences in the reference.</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;The Sequence::bamrecord class provides a set of functions to get at the alignment data.  These are direct representations of how the BAM data are stored.  See the class documentation for details.</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;Some comments:</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;* Sequence::bamreader is based on the BAM specification.  [htslib](http:<span class="comment">//htslib.org) is not used for anything other than bgzf decompression and seeking.</span></div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;* Sequence::bamrecord is move-constructable, meaning that it is lightning fast to copy alignments into containers, etc.</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;See the author&#39;s [pecnv](http:<span class="comment">//github.com/molpopgen/pecnv) for real-world use of theses classes.  Those programs scan large BAM files in minutes using these classes.</span></div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;<div class="ttc" id="classSequence_1_1PolyTable_html"><div class="ttname"><a href="classSequence_1_1PolyTable.html">Sequence::PolyTable</a></div><div class="ttdoc">The base class for polymorphism tables. </div><div class="ttdef"><b>Definition:</b> <a href="PolyTable_8hpp_source.html#l00060">PolyTable.hpp:60</a></div></div>
<div class="ttc" id="classSequence_1_1PolySites_html"><div class="ttname"><a href="classSequence_1_1PolySites.html">Sequence::PolySites</a></div><div class="ttdoc">Polymorphism tables for sequence data. </div><div class="ttdef"><b>Definition:</b> <a href="PolySites_8hpp_source.html#l00033">PolySites.hpp:33</a></div></div>
<div class="ttc" id="classSequence_1_1Fasta_html"><div class="ttname"><a href="classSequence_1_1Fasta.html">Sequence::Fasta</a></div><div class="ttdoc">FASTA sequence stream. </div><div class="ttdef"><b>Definition:</b> <a href="Fasta_8hpp_source.html#l00049">Fasta.hpp:49</a></div></div>
<div class="ttc" id="classSequence_1_1bamreader_html"><div class="ttname"><a href="classSequence_1_1bamreader.html">Sequence::bamreader</a></div><div class="ttdoc">A class managing input from BAM files. </div><div class="ttdef"><b>Definition:</b> <a href="bamreader_8hpp_source.html#l00027">bamreader.hpp:27</a></div></div>
<div class="ttc" id="classSequence_1_1Seq_html"><div class="ttname"><a href="classSequence_1_1Seq.html">Sequence::Seq</a></div><div class="ttdoc">Abstract interface to sequence objects. </div><div class="ttdef"><b>Definition:</b> <a href="Seq_8hpp_source.html#l00049">Seq.hpp:49</a></div></div>
<div class="ttc" id="classSequence_1_1bamreader_html_a89a8ae80000afaea8de6cd4818b5469e"><div class="ttname"><a href="classSequence_1_1bamreader.html#a89a8ae80000afaea8de6cd4818b5469e">Sequence::bamreader::next_record</a></div><div class="ttdeci">bamrecord next_record() const </div><div class="ttdef"><b>Definition:</b> <a href="bamreader_8cc_source.html#l00084">bamreader.cc:84</a></div></div>
<div class="ttc" id="classSequence_1_1PolySNP_html"><div class="ttname"><a href="classSequence_1_1PolySNP.html">Sequence::PolySNP</a></div><div class="ttdoc">Molecular population genetic analysis. </div><div class="ttdef"><b>Definition:</b> <a href="PolySNP_8hpp_source.html#l00083">PolySNP.hpp:83</a></div></div>
<div class="ttc" id="classSequence_1_1PolyTable_html_a0ad9fa4c28b8568a1bde74e13d10f1b3"><div class="ttname"><a href="classSequence_1_1PolyTable.html#a0ad9fa4c28b8568a1bde74e13d10f1b3">Sequence::PolyTable::size</a></div><div class="ttdeci">size_type size(void) const </div><div class="ttdef"><b>Definition:</b> <a href="PolyTable_8hpp_source.html#l00267">PolyTable.hpp:267</a></div></div>
<div class="ttc" id="classSequence_1_1FST_html"><div class="ttname"><a href="classSequence_1_1FST.html">Sequence::FST</a></div><div class="ttdoc">analysis of population structure using  </div><div class="ttdef"><b>Definition:</b> <a href="FST_8hpp_source.html#l00040">FST.hpp:40</a></div></div>
<div class="ttc" id="FST_8hpp_html"><div class="ttname"><a href="FST_8hpp.html">FST.hpp</a></div><div class="ttdoc">delcaration of a class (Sequence::FST) to analyze population structure </div></div>
<div class="ttc" id="classSequence_1_1PolyTable_html_a7096e7ad3abcb257a8e7ac8c28a23e5c"><div class="ttname"><a href="classSequence_1_1PolyTable.html#a7096e7ad3abcb257a8e7ac8c28a23e5c">Sequence::PolyTable::const_site_iterator</a></div><div class="ttdeci">Sequence::polySiteVector::const_iterator const_site_iterator</div><div class="ttdoc">Const iterator to segregating sites Const iterator to segregating sites. The value_type of this itera...</div><div class="ttdef"><b>Definition:</b> <a href="PolyTable_8hpp_source.html#l00099">PolyTable.hpp:99</a></div></div>
<div class="ttc" id="classSequence_1_1bamreader_html_a0d42726baf79c66cc7326cf6eea1db7e"><div class="ttname"><a href="classSequence_1_1bamreader.html#a0d42726baf79c66cc7326cf6eea1db7e">Sequence::bamreader::ref_cend</a></div><div class="ttdeci">refdata_citr ref_cend() const </div><div class="ttdef"><b>Definition:</b> <a href="bamreader_8cc_source.html#l00177">bamreader.cc:177</a></div></div>
<div class="ttc" id="classSequence_1_1bamrecord_html"><div class="ttname"><a href="classSequence_1_1bamrecord.html">Sequence::bamrecord</a></div><div class="ttdoc">A single alignment record from a BAM file. </div><div class="ttdef"><b>Definition:</b> <a href="bamrecord_8hpp_source.html#l00072">bamrecord.hpp:72</a></div></div>
<div class="ttc" id="classSequence_1_1bamreader_html_a09798434cd979cb8659db4c3f37fbb48"><div class="ttname"><a href="classSequence_1_1bamreader.html#a09798434cd979cb8659db4c3f37fbb48">Sequence::bamreader::header</a></div><div class="ttdeci">std::string header() const </div><div class="ttdef"><b>Definition:</b> <a href="bamreader_8cc_source.html#l00182">bamreader.cc:182</a></div></div>
<div class="ttc" id="bamreader_8hpp_html"><div class="ttname"><a href="bamreader_8hpp.html">bamreader.hpp</a></div><div class="ttdoc">BAM input stream. </div></div>
<div class="ttc" id="classSequence_1_1PolyTable_html_a05bb8d5b84760082a5b20a3598fa4f57"><div class="ttname"><a href="classSequence_1_1PolyTable.html#a05bb8d5b84760082a5b20a3598fa4f57">Sequence::PolyTable::size_type</a></div><div class="ttdeci">std::vector&lt; std::string &gt;::size_type size_type</div><div class="ttdoc">The size_type for the haplotype vector. </div><div class="ttdef"><b>Definition:</b> <a href="PolyTable_8hpp_source.html#l00074">PolyTable.hpp:74</a></div></div>
<div class="ttc" id="PolySNP_8hpp_html"><div class="ttname"><a href="PolySNP_8hpp.html">PolySNP.hpp</a></div><div class="ttdoc">declaration of Sequence::PolySNP, a class to analyze SNP data </div></div>
<div class="ttc" id="structSequence_1_1invalidPolyChar_html"><div class="ttname"><a href="structSequence_1_1invalidPolyChar.html">Sequence::invalidPolyChar</a></div><div class="ttdoc">This functor can be used to determine if a range contains characters that the SNP analysis routines i...</div><div class="ttdef"><b>Definition:</b> <a href="SeqAlphabets_8hpp_source.html#l00083">SeqAlphabets.hpp:83</a></div></div>
<div class="ttc" id="classSequence_1_1PolyTable_html_afe610e36cc38d3a77dfe9d6254deb789"><div class="ttname"><a href="classSequence_1_1PolyTable.html#afe610e36cc38d3a77dfe9d6254deb789">Sequence::PolyTable::send</a></div><div class="ttdeci">const_site_iterator send() const </div><div class="ttdef"><b>Definition:</b> <a href="PolyTable_8cc_source.html#l00301">PolyTable.cc:301</a></div></div>
<div class="ttc" id="namespaceSequence_html_aa52c570782b66af0cddf21ccaa86c768"><div class="ttname"><a href="namespaceSequence.html#aa52c570782b66af0cddf21ccaa86c768">Sequence::polySiteVector</a></div><div class="ttdeci">std::vector&lt; polymorphicSite &gt; polySiteVector</div><div class="ttdef"><b>Definition:</b> <a href="polySiteVector_8hpp_source.html#l00051">polySiteVector.hpp:51</a></div></div>
<div class="ttc" id="classSequence_1_1Seq_html_a6e8fd025d52d0183b70ecc327a9f2eb4"><div class="ttname"><a href="classSequence_1_1Seq.html#a6e8fd025d52d0183b70ecc327a9f2eb4">Sequence::Seq::read</a></div><div class="ttdeci">virtual std::istream &amp; read(std::istream &amp;s)=0</div></div>
<div class="ttc" id="classSequence_1_1PolyTable_html_a9c5e337cb00acba2ab83174ac933bb9e"><div class="ttname"><a href="classSequence_1_1PolyTable.html#a9c5e337cb00acba2ab83174ac933bb9e">Sequence::PolyTable::sbegin</a></div><div class="ttdeci">const_site_iterator sbegin() const </div><div class="ttdef"><b>Definition:</b> <a href="PolyTable_8cc_source.html#l00286">PolyTable.cc:286</a></div></div>
<div class="ttc" id="PolySites_8hpp_html"><div class="ttname"><a href="PolySites_8hpp.html">PolySites.hpp</a></div><div class="ttdoc">Sequence::PolySites, generates polymorphism tables from data. </div></div>
<div class="ttc" id="classSequence_1_1SimpleSNP_html"><div class="ttname"><a href="classSequence_1_1SimpleSNP.html">Sequence::SimpleSNP</a></div><div class="ttdoc">SNP table data format. </div><div class="ttdef"><b>Definition:</b> <a href="SimpleSNP_8hpp_source.html#l00067">SimpleSNP.hpp:67</a></div></div>
<div class="ttc" id="classSequence_1_1PolyTable_html_aae81867f990cacbd36bce631c8c95bf3"><div class="ttname"><a href="classSequence_1_1PolyTable.html#aae81867f990cacbd36bce631c8c95bf3">Sequence::PolyTable::pbegin</a></div><div class="ttdeci">pos_iterator pbegin()</div><div class="ttdef"><b>Definition:</b> <a href="PolyTable_8cc_source.html#l00234">PolyTable.cc:234</a></div></div>
<div class="ttc" id="Fasta_8hpp_html"><div class="ttname"><a href="Fasta_8hpp.html">Fasta.hpp</a></div><div class="ttdoc">Declaration of Sequence::Fasta streams. </div></div>
<div class="ttc" id="classSequence_1_1PolyTable_html_a906a808ab8ae90406a1f66fc7d38da38"><div class="ttname"><a href="classSequence_1_1PolyTable.html#a906a808ab8ae90406a1f66fc7d38da38">Sequence::PolyTable::pend</a></div><div class="ttdeci">pos_iterator pend()</div><div class="ttdef"><b>Definition:</b> <a href="PolyTable_8cc_source.html#l00243">PolyTable.cc:243</a></div></div>
<div class="ttc" id="classSequence_1_1badFormat_html"><div class="ttname"><a href="classSequence_1_1badFormat.html">Sequence::badFormat</a></div><div class="ttdef"><b>Definition:</b> <a href="SeqExceptions_8hpp_source.html#l00065">SeqExceptions.hpp:65</a></div></div>
<div class="ttc" id="SimData_8hpp_html"><div class="ttname"><a href="SimData_8hpp.html">SimData.hpp</a></div><div class="ttdoc">Declaration of Sequence::SimData, a class representing polymorphism data from coalescent simulations ...</div></div>
<div class="ttc" id="classSequence_1_1fastq_html"><div class="ttname"><a href="classSequence_1_1fastq.html">Sequence::fastq</a></div><div class="ttdef"><b>Definition:</b> <a href="fastq_8hpp_source.html#l00018">fastq.hpp:18</a></div></div>
<div class="ttc" id="classSequence_1_1bamreader_html_ac0a75ae7e8b9645271adabef0ae513b6"><div class="ttname"><a href="classSequence_1_1bamreader.html#ac0a75ae7e8b9645271adabef0ae513b6">Sequence::bamreader::ref_cbegin</a></div><div class="ttdeci">refdata_citr ref_cbegin() const </div><div class="ttdef"><b>Definition:</b> <a href="bamreader_8cc_source.html#l00172">bamreader.cc:172</a></div></div>
<div class="ttc" id="classSequence_1_1SimData_html"><div class="ttname"><a href="classSequence_1_1SimData.html">Sequence::SimData</a></div><div class="ttdoc">Data from coalescent simulations. </div><div class="ttdef"><b>Definition:</b> <a href="SimData_8hpp_source.html#l00069">SimData.hpp:69</a></div></div>
<div class="ttc" id="classSequence_1_1PolyTable_html_a27a62e9ee28d31f4b386c79a7af167a0"><div class="ttname"><a href="classSequence_1_1PolyTable.html#a27a62e9ee28d31f4b386c79a7af167a0">Sequence::PolyTable::read</a></div><div class="ttdeci">virtual std::istream &amp; read(std::istream &amp;h)=0</div></div>
<div class="ttc" id="classSequence_1_1PolySIM_html"><div class="ttname"><a href="classSequence_1_1PolySIM.html">Sequence::PolySIM</a></div><div class="ttdoc">Analysis of coalescent simulation data. </div><div class="ttdef"><b>Definition:</b> <a href="PolySIM_8hpp_source.html#l00044">PolySIM.hpp:44</a></div></div>
<div class="ttc" id="group__popgen_html_ga490ad3c8b4e548d1cf850806b6a5be1d"><div class="ttname"><a href="group__popgen.html#ga490ad3c8b4e548d1cf850806b6a5be1d">Sequence::calcHKA</a></div><div class="ttdeci">HKAresults calcHKA(const std::vector&lt; HKAdata &gt; &amp;data)</div><div class="ttdef"><b>Definition:</b> <a href="HKA_8cc_source.html#l00100">HKA.cc:100</a></div></div>
<div class="ttc" id="namespaceSequence_html_a08841c3bd3b0999a40dfdadbee4a6b0d"><div class="ttname"><a href="namespaceSequence.html#a08841c3bd3b0999a40dfdadbee4a6b0d">Sequence::polymorphicSite</a></div><div class="ttdeci">std::pair&lt; double, std::string &gt; polymorphicSite</div><div class="ttdef"><b>Definition:</b> <a href="polySiteVector_8hpp_source.html#l00045">polySiteVector.hpp:45</a></div></div>
<div class="ttc" id="classSequence_1_1PolyTable_html_a131a61d74eb612a3e419aa4ae1c38a24"><div class="ttname"><a href="classSequence_1_1PolyTable.html#a131a61d74eb612a3e419aa4ae1c38a24">Sequence::PolyTable::empty</a></div><div class="ttdeci">bool empty() const </div><div class="ttdef"><b>Definition:</b> <a href="PolyTable_8cc_source.html#l00077">PolyTable.cc:77</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>tutorial.md</b></li>
    <li class="footer">Generated on Sat Jul 4 2015 09:59:14 for libsequence by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
